(function () {
    'use strict';

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * True if the custom elements polyfill is in use.
     */
    const isCEPolyfill = typeof window !== 'undefined' &&
        window.customElements != null &&
        window.customElements.polyfillWrapFlushCallback !==
            undefined;
    /**
     * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
     * `container`.
     */
    const removeNodes = (container, start, end = null) => {
        while (start !== end) {
            const n = start.nextSibling;
            container.removeChild(start);
            start = n;
        }
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * An expression marker with embedded unique key to avoid collision with
     * possible text in templates.
     */
    const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
    /**
     * An expression marker used text-positions, multi-binding attributes, and
     * attributes with markup-like text values.
     */
    const nodeMarker = `<!--${marker}-->`;
    const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
    /**
     * Suffix appended to all bound attribute names.
     */
    const boundAttributeSuffix = '$lit$';
    /**
     * An updatable Template that tracks the location of dynamic parts.
     */
    class Template {
        constructor(result, element) {
            this.parts = [];
            this.element = element;
            const nodesToRemove = [];
            const stack = [];
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
            const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
            // Keeps track of the last index associated with a part. We try to delete
            // unnecessary nodes, but we never want to associate two different parts
            // to the same index. They must have a constant node between.
            let lastPartIndex = 0;
            let index = -1;
            let partIndex = 0;
            const { strings, values: { length } } = result;
            while (partIndex < length) {
                const node = walker.nextNode();
                if (node === null) {
                    // We've exhausted the content inside a nested template element.
                    // Because we still have parts (the outer for-loop), we know:
                    // - There is a template in the stack
                    // - The walker will find a nextNode outside the template
                    walker.currentNode = stack.pop();
                    continue;
                }
                index++;
                if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                    if (node.hasAttributes()) {
                        const attributes = node.attributes;
                        const { length } = attributes;
                        // Per
                        // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
                        // attributes are not guaranteed to be returned in document order.
                        // In particular, Edge/IE can return them out of order, so we cannot
                        // assume a correspondence between part index and attribute index.
                        let count = 0;
                        for (let i = 0; i < length; i++) {
                            if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                                count++;
                            }
                        }
                        while (count-- > 0) {
                            // Get the template literal section leading up to the first
                            // expression in this attribute
                            const stringForPart = strings[partIndex];
                            // Find the attribute name
                            const name = lastAttributeNameRegex.exec(stringForPart)[2];
                            // Find the corresponding attribute
                            // All bound attributes have had a suffix added in
                            // TemplateResult#getHTML to opt out of special attribute
                            // handling. To look up the attribute value we also need to add
                            // the suffix.
                            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
                            const attributeValue = node.getAttribute(attributeLookupName);
                            node.removeAttribute(attributeLookupName);
                            const statics = attributeValue.split(markerRegex);
                            this.parts.push({ type: 'attribute', index, name, strings: statics });
                            partIndex += statics.length - 1;
                        }
                    }
                    if (node.tagName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                }
                else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                    const data = node.data;
                    if (data.indexOf(marker) >= 0) {
                        const parent = node.parentNode;
                        const strings = data.split(markerRegex);
                        const lastIndex = strings.length - 1;
                        // Generate a new text node for each literal section
                        // These nodes are also used as the markers for node parts
                        for (let i = 0; i < lastIndex; i++) {
                            let insert;
                            let s = strings[i];
                            if (s === '') {
                                insert = createMarker();
                            }
                            else {
                                const match = lastAttributeNameRegex.exec(s);
                                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                                    s = s.slice(0, match.index) + match[1] +
                                        match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                                }
                                insert = document.createTextNode(s);
                            }
                            parent.insertBefore(insert, node);
                            this.parts.push({ type: 'node', index: ++index });
                        }
                        // If there's no text, we must insert a comment to mark our place.
                        // Else, we can trust it will stick around after cloning.
                        if (strings[lastIndex] === '') {
                            parent.insertBefore(createMarker(), node);
                            nodesToRemove.push(node);
                        }
                        else {
                            node.data = strings[lastIndex];
                        }
                        // We have a part for each match found
                        partIndex += lastIndex;
                    }
                }
                else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {
                    if (node.data === marker) {
                        const parent = node.parentNode;
                        // Add a new marker node to be the startNode of the Part if any of
                        // the following are true:
                        //  * We don't have a previousSibling
                        //  * The previousSibling is already the start of a previous part
                        if (node.previousSibling === null || index === lastPartIndex) {
                            index++;
                            parent.insertBefore(createMarker(), node);
                        }
                        lastPartIndex = index;
                        this.parts.push({ type: 'node', index });
                        // If we don't have a nextSibling, keep this node so we have an end.
                        // Else, we can remove it to save future costs.
                        if (node.nextSibling === null) {
                            node.data = '';
                        }
                        else {
                            nodesToRemove.push(node);
                            index--;
                        }
                        partIndex++;
                    }
                    else {
                        let i = -1;
                        while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                            // Comment node has a binding marker inside, make an inactive part
                            // The binding won't work, but subsequent bindings will
                            // TODO (justinfagnani): consider whether it's even worth it to
                            // make bindings in comments work
                            this.parts.push({ type: 'node', index: -1 });
                            partIndex++;
                        }
                    }
                }
            }
            // Remove text binding nodes after the walk to not disturb the TreeWalker
            for (const n of nodesToRemove) {
                n.parentNode.removeChild(n);
            }
        }
    }
    const endsWith = (str, suffix) => {
        const index = str.length - suffix.length;
        return index >= 0 && str.slice(index) === suffix;
    };
    const isTemplatePartActive = (part) => part.index !== -1;
    // Allows `document.createComment('')` to be renamed for a
    // small manual size-savings.
    const createMarker = () => document.createComment('');
    /**
     * This regex extracts the attribute name preceding an attribute-position
     * expression. It does this by matching the syntax allowed for attributes
     * against the string literal directly preceding the expression, assuming that
     * the expression is in an attribute-value position.
     *
     * See attributes in the HTML spec:
     * https://www.w3.org/TR/html5/syntax.html#elements-attributes
     *
     * " \x09\x0a\x0c\x0d" are HTML space characters:
     * https://www.w3.org/TR/html5/infrastructure.html#space-characters
     *
     * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
     * space character except " ".
     *
     * So an attribute is:
     *  * The name: any character except a control character, space character, ('),
     *    ("), ">", "=", or "/"
     *  * Followed by zero or more space characters
     *  * Followed by "="
     *  * Followed by zero or more space characters
     *  * Followed by:
     *    * Any character except space, ('), ("), "<", ">", "=", (`), or
     *    * (") then any non-("), or
     *    * (') then any non-(')
     */
    const lastAttributeNameRegex = 
    // eslint-disable-next-line no-control-regex
    /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;
    /**
     * Removes the list of nodes from a Template safely. In addition to removing
     * nodes from the Template, the Template part indices are updated to match
     * the mutated Template DOM.
     *
     * As the template is walked the removal state is tracked and
     * part indices are adjusted as needed.
     *
     * div
     *   div#1 (remove) <-- start removing (removing node is div#1)
     *     div
     *       div#2 (remove)  <-- continue removing (removing node is still div#1)
     *         div
     * div <-- stop removing since previous sibling is the removing node (div#1,
     * removed 4 nodes)
     */
    function removeNodesFromTemplate(template, nodesToRemove) {
        const { element: { content }, parts } = template;
        const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
        let partIndex = nextActiveIndexInTemplateParts(parts);
        let part = parts[partIndex];
        let nodeIndex = -1;
        let removeCount = 0;
        const nodesToRemoveInTemplate = [];
        let currentRemovingNode = null;
        while (walker.nextNode()) {
            nodeIndex++;
            const node = walker.currentNode;
            // End removal if stepped past the removing node
            if (node.previousSibling === currentRemovingNode) {
                currentRemovingNode = null;
            }
            // A node to remove was found in the template
            if (nodesToRemove.has(node)) {
                nodesToRemoveInTemplate.push(node);
                // Track node we're removing
                if (currentRemovingNode === null) {
                    currentRemovingNode = node;
                }
            }
            // When removing, increment count by which to adjust subsequent part indices
            if (currentRemovingNode !== null) {
                removeCount++;
            }
            while (part !== undefined && part.index === nodeIndex) {
                // If part is in a removed node deactivate it by setting index to -1 or
                // adjust the index as needed.
                part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
                // go to the next active part.
                partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
                part = parts[partIndex];
            }
        }
        nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));
    }
    const countNodes = (node) => {
        let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;
        const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
        while (walker.nextNode()) {
            count++;
        }
        return count;
    };
    const nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {
        for (let i = startIndex + 1; i < parts.length; i++) {
            const part = parts[i];
            if (isTemplatePartActive(part)) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Inserts the given node into the Template, optionally before the given
     * refNode. In addition to inserting the node into the Template, the Template
     * part indices are updated to match the mutated Template DOM.
     */
    function insertNodeIntoTemplate(template, node, refNode = null) {
        const { element: { content }, parts } = template;
        // If there's no refNode, then put node at end of template.
        // No part indices need to be shifted in this case.
        if (refNode === null || refNode === undefined) {
            content.appendChild(node);
            return;
        }
        const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
        let partIndex = nextActiveIndexInTemplateParts(parts);
        let insertCount = 0;
        let walkerIndex = -1;
        while (walker.nextNode()) {
            walkerIndex++;
            const walkerNode = walker.currentNode;
            if (walkerNode === refNode) {
                insertCount = countNodes(node);
                refNode.parentNode.insertBefore(node, refNode);
            }
            while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
                // If we've inserted the node, simply adjust all subsequent parts
                if (insertCount > 0) {
                    while (partIndex !== -1) {
                        parts[partIndex].index += insertCount;
                        partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
                    }
                    return;
                }
                partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
            }
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const directives = new WeakMap();
    const isDirective = (o) => {
        return typeof o === 'function' && directives.has(o);
    };

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * A sentinel value that signals that a value was handled by a directive and
     * should not be written to the DOM.
     */
    const noChange = {};
    /**
     * A sentinel value that signals a NodePart to fully clear its content.
     */
    const nothing = {};

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * An instance of a `Template` that can be attached to the DOM and updated
     * with new values.
     */
    class TemplateInstance {
        constructor(template, processor, options) {
            this.__parts = [];
            this.template = template;
            this.processor = processor;
            this.options = options;
        }
        update(values) {
            let i = 0;
            for (const part of this.__parts) {
                if (part !== undefined) {
                    part.setValue(values[i]);
                }
                i++;
            }
            for (const part of this.__parts) {
                if (part !== undefined) {
                    part.commit();
                }
            }
        }
        _clone() {
            // There are a number of steps in the lifecycle of a template instance's
            // DOM fragment:
            //  1. Clone - create the instance fragment
            //  2. Adopt - adopt into the main document
            //  3. Process - find part markers and create parts
            //  4. Upgrade - upgrade custom elements
            //  5. Update - set node, attribute, property, etc., values
            //  6. Connect - connect to the document. Optional and outside of this
            //     method.
            //
            // We have a few constraints on the ordering of these steps:
            //  * We need to upgrade before updating, so that property values will pass
            //    through any property setters.
            //  * We would like to process before upgrading so that we're sure that the
            //    cloned fragment is inert and not disturbed by self-modifying DOM.
            //  * We want custom elements to upgrade even in disconnected fragments.
            //
            // Given these constraints, with full custom elements support we would
            // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
            //
            // But Safari does not implement CustomElementRegistry#upgrade, so we
            // can not implement that order and still have upgrade-before-update and
            // upgrade disconnected fragments. So we instead sacrifice the
            // process-before-upgrade constraint, since in Custom Elements v1 elements
            // must not modify their light DOM in the constructor. We still have issues
            // when co-existing with CEv0 elements like Polymer 1, and with polyfills
            // that don't strictly adhere to the no-modification rule because shadow
            // DOM, which may be created in the constructor, is emulated by being placed
            // in the light DOM.
            //
            // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
            // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
            // in one step.
            //
            // The Custom Elements v1 polyfill supports upgrade(), so the order when
            // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
            // Connect.
            const fragment = isCEPolyfill ?
                this.template.element.content.cloneNode(true) :
                document.importNode(this.template.element.content, true);
            const stack = [];
            const parts = this.template.parts;
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
            let partIndex = 0;
            let nodeIndex = 0;
            let part;
            let node = walker.nextNode();
            // Loop through all the nodes and parts of a template
            while (partIndex < parts.length) {
                part = parts[partIndex];
                if (!isTemplatePartActive(part)) {
                    this.__parts.push(undefined);
                    partIndex++;
                    continue;
                }
                // Progress the tree walker until we find our next part's node.
                // Note that multiple parts may share the same node (attribute parts
                // on a single element), so this loop may not run at all.
                while (nodeIndex < part.index) {
                    nodeIndex++;
                    if (node.nodeName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                    if ((node = walker.nextNode()) === null) {
                        // We've exhausted the content inside a nested template element.
                        // Because we still have parts (the outer for-loop), we know:
                        // - There is a template in the stack
                        // - The walker will find a nextNode outside the template
                        walker.currentNode = stack.pop();
                        node = walker.nextNode();
                    }
                }
                // We've arrived at our part's node.
                if (part.type === 'node') {
                    const part = this.processor.handleTextExpression(this.options);
                    part.insertAfterNode(node.previousSibling);
                    this.__parts.push(part);
                }
                else {
                    this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
                }
                partIndex++;
            }
            if (isCEPolyfill) {
                document.adoptNode(fragment);
                customElements.upgrade(fragment);
            }
            return fragment;
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Our TrustedTypePolicy for HTML which is declared using the html template
     * tag function.
     *
     * That HTML is a developer-authored constant, and is parsed with innerHTML
     * before any untrusted expressions have been mixed in. Therefor it is
     * considered safe by construction.
     */
    const policy = window.trustedTypes &&
        trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });
    const commentMarker = ` ${marker} `;
    /**
     * The return type of `html`, which holds a Template and the values from
     * interpolated expressions.
     */
    class TemplateResult {
        constructor(strings, values, type, processor) {
            this.strings = strings;
            this.values = values;
            this.type = type;
            this.processor = processor;
        }
        /**
         * Returns a string of HTML used to create a `<template>` element.
         */
        getHTML() {
            const l = this.strings.length - 1;
            let html = '';
            let isCommentBinding = false;
            for (let i = 0; i < l; i++) {
                const s = this.strings[i];
                // For each binding we want to determine the kind of marker to insert
                // into the template source before it's parsed by the browser's HTML
                // parser. The marker type is based on whether the expression is in an
                // attribute, text, or comment position.
                //   * For node-position bindings we insert a comment with the marker
                //     sentinel as its text content, like <!--{{lit-guid}}-->.
                //   * For attribute bindings we insert just the marker sentinel for the
                //     first binding, so that we support unquoted attribute bindings.
                //     Subsequent bindings can use a comment marker because multi-binding
                //     attributes must be quoted.
                //   * For comment bindings we insert just the marker sentinel so we don't
                //     close the comment.
                //
                // The following code scans the template source, but is *not* an HTML
                // parser. We don't need to track the tree structure of the HTML, only
                // whether a binding is inside a comment, and if not, if it appears to be
                // the first binding in an attribute.
                const commentOpen = s.lastIndexOf('<!--');
                // We're in comment position if we have a comment open with no following
                // comment close. Because <-- can appear in an attribute value there can
                // be false positives.
                isCommentBinding = (commentOpen > -1 || isCommentBinding) &&
                    s.indexOf('-->', commentOpen + 1) === -1;
                // Check to see if we have an attribute-like sequence preceding the
                // expression. This can match "name=value" like structures in text,
                // comments, and attribute values, so there can be false-positives.
                const attributeMatch = lastAttributeNameRegex.exec(s);
                if (attributeMatch === null) {
                    // We're only in this branch if we don't have a attribute-like
                    // preceding sequence. For comments, this guards against unusual
                    // attribute values like <div foo="<!--${'bar'}">. Cases like
                    // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
                    // below.
                    html += s + (isCommentBinding ? commentMarker : nodeMarker);
                }
                else {
                    // For attributes we use just a marker sentinel, and also append a
                    // $lit$ suffix to the name to opt-out of attribute-specific parsing
                    // that IE and Edge do for style and certain SVG attributes.
                    html += s.substr(0, attributeMatch.index) + attributeMatch[1] +
                        attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +
                        marker;
                }
            }
            html += this.strings[l];
            return html;
        }
        getTemplateElement() {
            const template = document.createElement('template');
            let value = this.getHTML();
            if (policy !== undefined) {
                // this is secure because `this.strings` is a TemplateStringsArray.
                // TODO: validate this when
                // https://github.com/tc39/proposal-array-is-template-object is
                // implemented.
                value = policy.createHTML(value);
            }
            template.innerHTML = value;
            return template;
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const isPrimitive = (value) => {
        return (value === null ||
            !(typeof value === 'object' || typeof value === 'function'));
    };
    const isIterable = (value) => {
        return Array.isArray(value) ||
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            !!(value && value[Symbol.iterator]);
    };
    /**
     * Writes attribute values to the DOM for a group of AttributeParts bound to a
     * single attribute. The value is only set once even if there are multiple parts
     * for an attribute.
     */
    class AttributeCommitter {
        constructor(element, name, strings) {
            this.dirty = true;
            this.element = element;
            this.name = name;
            this.strings = strings;
            this.parts = [];
            for (let i = 0; i < strings.length - 1; i++) {
                this.parts[i] = this._createPart();
            }
        }
        /**
         * Creates a single part. Override this to create a differnt type of part.
         */
        _createPart() {
            return new AttributePart(this);
        }
        _getValue() {
            const strings = this.strings;
            const l = strings.length - 1;
            const parts = this.parts;
            // If we're assigning an attribute via syntax like:
            //    attr="${foo}"  or  attr=${foo}
            // but not
            //    attr="${foo} ${bar}" or attr="${foo} baz"
            // then we don't want to coerce the attribute value into one long
            // string. Instead we want to just return the value itself directly,
            // so that sanitizeDOMValue can get the actual value rather than
            // String(value)
            // The exception is if v is an array, in which case we do want to smash
            // it together into a string without calling String() on the array.
            //
            // This also allows trusted values (when using TrustedTypes) being
            // assigned to DOM sinks without being stringified in the process.
            if (l === 1 && strings[0] === '' && strings[1] === '') {
                const v = parts[0].value;
                if (typeof v === 'symbol') {
                    return String(v);
                }
                if (typeof v === 'string' || !isIterable(v)) {
                    return v;
                }
            }
            let text = '';
            for (let i = 0; i < l; i++) {
                text += strings[i];
                const part = parts[i];
                if (part !== undefined) {
                    const v = part.value;
                    if (isPrimitive(v) || !isIterable(v)) {
                        text += typeof v === 'string' ? v : String(v);
                    }
                    else {
                        for (const t of v) {
                            text += typeof t === 'string' ? t : String(t);
                        }
                    }
                }
            }
            text += strings[l];
            return text;
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                this.element.setAttribute(this.name, this._getValue());
            }
        }
    }
    /**
     * A Part that controls all or part of an attribute value.
     */
    class AttributePart {
        constructor(committer) {
            this.value = undefined;
            this.committer = committer;
        }
        setValue(value) {
            if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
                this.value = value;
                // If the value is a not a directive, dirty the committer so that it'll
                // call setAttribute. If the value is a directive, it'll dirty the
                // committer if it calls setValue().
                if (!isDirective(value)) {
                    this.committer.dirty = true;
                }
            }
        }
        commit() {
            while (isDirective(this.value)) {
                const directive = this.value;
                this.value = noChange;
                directive(this);
            }
            if (this.value === noChange) {
                return;
            }
            this.committer.commit();
        }
    }
    /**
     * A Part that controls a location within a Node tree. Like a Range, NodePart
     * has start and end locations and can set and update the Nodes between those
     * locations.
     *
     * NodeParts support several value types: primitives, Nodes, TemplateResults,
     * as well as arrays and iterables of those types.
     */
    class NodePart {
        constructor(options) {
            this.value = undefined;
            this.__pendingValue = undefined;
            this.options = options;
        }
        /**
         * Appends this part into a container.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        appendInto(container) {
            this.startNode = container.appendChild(createMarker());
            this.endNode = container.appendChild(createMarker());
        }
        /**
         * Inserts this part after the `ref` node (between `ref` and `ref`'s next
         * sibling). Both `ref` and its next sibling must be static, unchanging nodes
         * such as those that appear in a literal section of a template.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        insertAfterNode(ref) {
            this.startNode = ref;
            this.endNode = ref.nextSibling;
        }
        /**
         * Appends this part into a parent part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        appendIntoPart(part) {
            part.__insert(this.startNode = createMarker());
            part.__insert(this.endNode = createMarker());
        }
        /**
         * Inserts this part after the `ref` part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        insertAfterPart(ref) {
            ref.__insert(this.startNode = createMarker());
            this.endNode = ref.endNode;
            ref.endNode = this.startNode;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            if (this.startNode.parentNode === null) {
                return;
            }
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            const value = this.__pendingValue;
            if (value === noChange) {
                return;
            }
            if (isPrimitive(value)) {
                if (value !== this.value) {
                    this.__commitText(value);
                }
            }
            else if (value instanceof TemplateResult) {
                this.__commitTemplateResult(value);
            }
            else if (value instanceof Node) {
                this.__commitNode(value);
            }
            else if (isIterable(value)) {
                this.__commitIterable(value);
            }
            else if (value === nothing) {
                this.value = nothing;
                this.clear();
            }
            else {
                // Fallback, will render the string representation
                this.__commitText(value);
            }
        }
        __insert(node) {
            this.endNode.parentNode.insertBefore(node, this.endNode);
        }
        __commitNode(value) {
            if (this.value === value) {
                return;
            }
            this.clear();
            this.__insert(value);
            this.value = value;
        }
        __commitText(value) {
            const node = this.startNode.nextSibling;
            value = value == null ? '' : value;
            // If `value` isn't already a string, we explicitly convert it here in case
            // it can't be implicitly converted - i.e. it's a symbol.
            const valueAsString = typeof value === 'string' ? value : String(value);
            if (node === this.endNode.previousSibling &&
                node.nodeType === 3 /* Node.TEXT_NODE */) {
                // If we only have a single text node between the markers, we can just
                // set its value, rather than replacing it.
                // TODO(justinfagnani): Can we just check if this.value is primitive?
                node.data = valueAsString;
            }
            else {
                this.__commitNode(document.createTextNode(valueAsString));
            }
            this.value = value;
        }
        __commitTemplateResult(value) {
            const template = this.options.templateFactory(value);
            if (this.value instanceof TemplateInstance &&
                this.value.template === template) {
                this.value.update(value.values);
            }
            else {
                // Make sure we propagate the template processor from the TemplateResult
                // so that we use its syntax extension, etc. The template factory comes
                // from the render function options so that it can control template
                // caching and preprocessing.
                const instance = new TemplateInstance(template, value.processor, this.options);
                const fragment = instance._clone();
                instance.update(value.values);
                this.__commitNode(fragment);
                this.value = instance;
            }
        }
        __commitIterable(value) {
            // For an Iterable, we create a new InstancePart per item, then set its
            // value to the item. This is a little bit of overhead for every item in
            // an Iterable, but it lets us recurse easily and efficiently update Arrays
            // of TemplateResults that will be commonly returned from expressions like:
            // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
            // If _value is an array, then the previous render was of an
            // iterable and _value will contain the NodeParts from the previous
            // render. If _value is not an array, clear this part and make a new
            // array for NodeParts.
            if (!Array.isArray(this.value)) {
                this.value = [];
                this.clear();
            }
            // Lets us keep track of how many items we stamped so we can clear leftover
            // items from a previous render
            const itemParts = this.value;
            let partIndex = 0;
            let itemPart;
            for (const item of value) {
                // Try to reuse an existing part
                itemPart = itemParts[partIndex];
                // If no existing part, create a new one
                if (itemPart === undefined) {
                    itemPart = new NodePart(this.options);
                    itemParts.push(itemPart);
                    if (partIndex === 0) {
                        itemPart.appendIntoPart(this);
                    }
                    else {
                        itemPart.insertAfterPart(itemParts[partIndex - 1]);
                    }
                }
                itemPart.setValue(item);
                itemPart.commit();
                partIndex++;
            }
            if (partIndex < itemParts.length) {
                // Truncate the parts array so _value reflects the current state
                itemParts.length = partIndex;
                this.clear(itemPart && itemPart.endNode);
            }
        }
        clear(startNode = this.startNode) {
            removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
        }
    }
    /**
     * Implements a boolean attribute, roughly as defined in the HTML
     * specification.
     *
     * If the value is truthy, then the attribute is present with a value of
     * ''. If the value is falsey, the attribute is removed.
     */
    class BooleanAttributePart {
        constructor(element, name, strings) {
            this.value = undefined;
            this.__pendingValue = undefined;
            if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
                throw new Error('Boolean attributes can only contain a single expression');
            }
            this.element = element;
            this.name = name;
            this.strings = strings;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const value = !!this.__pendingValue;
            if (this.value !== value) {
                if (value) {
                    this.element.setAttribute(this.name, '');
                }
                else {
                    this.element.removeAttribute(this.name);
                }
                this.value = value;
            }
            this.__pendingValue = noChange;
        }
    }
    /**
     * Sets attribute values for PropertyParts, so that the value is only set once
     * even if there are multiple parts for a property.
     *
     * If an expression controls the whole property value, then the value is simply
     * assigned to the property under control. If there are string literals or
     * multiple expressions, then the strings are expressions are interpolated into
     * a string first.
     */
    class PropertyCommitter extends AttributeCommitter {
        constructor(element, name, strings) {
            super(element, name, strings);
            this.single =
                (strings.length === 2 && strings[0] === '' && strings[1] === '');
        }
        _createPart() {
            return new PropertyPart(this);
        }
        _getValue() {
            if (this.single) {
                return this.parts[0].value;
            }
            return super._getValue();
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this.element[this.name] = this._getValue();
            }
        }
    }
    class PropertyPart extends AttributePart {
    }
    // Detect event listener options support. If the `capture` property is read
    // from the options object, then options are supported. If not, then the third
    // argument to add/removeEventListener is interpreted as the boolean capture
    // value so we should only pass the `capture` property.
    let eventOptionsSupported = false;
    // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
    // blocks right into the body of a module
    (() => {
        try {
            const options = {
                get capture() {
                    eventOptionsSupported = true;
                    return false;
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.addEventListener('test', options, options);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.removeEventListener('test', options, options);
        }
        catch (_e) {
            // event options not supported
        }
    })();
    class EventPart {
        constructor(element, eventName, eventContext) {
            this.value = undefined;
            this.__pendingValue = undefined;
            this.element = element;
            this.eventName = eventName;
            this.eventContext = eventContext;
            this.__boundHandleEvent = (e) => this.handleEvent(e);
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const newListener = this.__pendingValue;
            const oldListener = this.value;
            const shouldRemoveListener = newListener == null ||
                oldListener != null &&
                    (newListener.capture !== oldListener.capture ||
                        newListener.once !== oldListener.once ||
                        newListener.passive !== oldListener.passive);
            const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
            if (shouldRemoveListener) {
                this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            if (shouldAddListener) {
                this.__options = getOptions(newListener);
                this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            this.value = newListener;
            this.__pendingValue = noChange;
        }
        handleEvent(event) {
            if (typeof this.value === 'function') {
                this.value.call(this.eventContext || this.element, event);
            }
            else {
                this.value.handleEvent(event);
            }
        }
    }
    // We copy options because of the inconsistent behavior of browsers when reading
    // the third argument of add/removeEventListener. IE11 doesn't support options
    // at all. Chrome 41 only reads `capture` if the argument is an object.
    const getOptions = (o) => o &&
        (eventOptionsSupported ?
            { capture: o.capture, passive: o.passive, once: o.once } :
            o.capture);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * The default TemplateFactory which caches Templates keyed on
     * result.type and result.strings.
     */
    function templateFactory(result) {
        let templateCache = templateCaches.get(result.type);
        if (templateCache === undefined) {
            templateCache = {
                stringsArray: new WeakMap(),
                keyString: new Map()
            };
            templateCaches.set(result.type, templateCache);
        }
        let template = templateCache.stringsArray.get(result.strings);
        if (template !== undefined) {
            return template;
        }
        // If the TemplateStringsArray is new, generate a key from the strings
        // This key is shared between all templates with identical content
        const key = result.strings.join(marker);
        // Check if we already have a Template for this key
        template = templateCache.keyString.get(key);
        if (template === undefined) {
            // If we have not seen this key before, create a new Template
            template = new Template(result, result.getTemplateElement());
            // Cache the Template for this key
            templateCache.keyString.set(key, template);
        }
        // Cache all future queries for this TemplateStringsArray
        templateCache.stringsArray.set(result.strings, template);
        return template;
    }
    const templateCaches = new Map();

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const parts = new WeakMap();
    /**
     * Renders a template result or other value to a container.
     *
     * To update a container with new values, reevaluate the template literal and
     * call `render` with the new result.
     *
     * @param result Any value renderable by NodePart - typically a TemplateResult
     *     created by evaluating a template tag like `html` or `svg`.
     * @param container A DOM parent to render to. The entire contents are either
     *     replaced, or efficiently updated if the same result type was previous
     *     rendered there.
     * @param options RenderOptions for the entire render tree rendered to this
     *     container. Render options must *not* change between renders to the same
     *     container, as those changes will not effect previously rendered DOM.
     */
    const render$1 = (result, container, options) => {
        let part = parts.get(container);
        if (part === undefined) {
            removeNodes(container, container.firstChild);
            parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));
            part.appendInto(container);
        }
        part.setValue(result);
        part.commit();
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Creates Parts when a template is instantiated.
     */
    class DefaultTemplateProcessor {
        /**
         * Create parts for an attribute-position binding, given the event, attribute
         * name, and string literals.
         *
         * @param element The element containing the binding
         * @param name  The attribute name
         * @param strings The string literals. There are always at least two strings,
         *   event for fully-controlled bindings with a single expression.
         */
        handleAttributeExpressions(element, name, strings, options) {
            const prefix = name[0];
            if (prefix === '.') {
                const committer = new PropertyCommitter(element, name.slice(1), strings);
                return committer.parts;
            }
            if (prefix === '@') {
                return [new EventPart(element, name.slice(1), options.eventContext)];
            }
            if (prefix === '?') {
                return [new BooleanAttributePart(element, name.slice(1), strings)];
            }
            const committer = new AttributeCommitter(element, name, strings);
            return committer.parts;
        }
        /**
         * Create parts for a text-position binding.
         * @param templateFactory
         */
        handleTextExpression(options) {
            return new NodePart(options);
        }
    }
    const defaultTemplateProcessor = new DefaultTemplateProcessor();

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // IMPORTANT: do not change the property name or the assignment expression.
    // This line will be used in regexes to search for lit-html usage.
    // TODO(justinfagnani): inject version number at build time
    if (typeof window !== 'undefined') {
        (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.4.1');
    }
    /**
     * Interprets a template literal as an HTML template that can efficiently
     * render to and update a container.
     */
    const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // Get a key to lookup in `templateCaches`.
    const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
    let compatibleShadyCSSVersion = true;
    if (typeof window.ShadyCSS === 'undefined') {
        compatibleShadyCSSVersion = false;
    }
    else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
        console.warn(`Incompatible ShadyCSS version detected. ` +
            `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +
            `@webcomponents/shadycss@1.3.1.`);
        compatibleShadyCSSVersion = false;
    }
    /**
     * Template factory which scopes template DOM using ShadyCSS.
     * @param scopeName {string}
     */
    const shadyTemplateFactory = (scopeName) => (result) => {
        const cacheKey = getTemplateCacheKey(result.type, scopeName);
        let templateCache = templateCaches.get(cacheKey);
        if (templateCache === undefined) {
            templateCache = {
                stringsArray: new WeakMap(),
                keyString: new Map()
            };
            templateCaches.set(cacheKey, templateCache);
        }
        let template = templateCache.stringsArray.get(result.strings);
        if (template !== undefined) {
            return template;
        }
        const key = result.strings.join(marker);
        template = templateCache.keyString.get(key);
        if (template === undefined) {
            const element = result.getTemplateElement();
            if (compatibleShadyCSSVersion) {
                window.ShadyCSS.prepareTemplateDom(element, scopeName);
            }
            template = new Template(result, element);
            templateCache.keyString.set(key, template);
        }
        templateCache.stringsArray.set(result.strings, template);
        return template;
    };
    const TEMPLATE_TYPES = ['html', 'svg'];
    /**
     * Removes all style elements from Templates for the given scopeName.
     */
    const removeStylesFromLitTemplates = (scopeName) => {
        TEMPLATE_TYPES.forEach((type) => {
            const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));
            if (templates !== undefined) {
                templates.keyString.forEach((template) => {
                    const { element: { content } } = template;
                    // IE 11 doesn't support the iterable param Set constructor
                    const styles = new Set();
                    Array.from(content.querySelectorAll('style')).forEach((s) => {
                        styles.add(s);
                    });
                    removeNodesFromTemplate(template, styles);
                });
            }
        });
    };
    const shadyRenderSet = new Set();
    /**
     * For the given scope name, ensures that ShadyCSS style scoping is performed.
     * This is done just once per scope name so the fragment and template cannot
     * be modified.
     * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
     * to be scoped and appended to the document
     * (2) removes style elements from all lit-html Templates for this scope name.
     *
     * Note, <style> elements can only be placed into templates for the
     * initial rendering of the scope. If <style> elements are included in templates
     * dynamically rendered to the scope (after the first scope render), they will
     * not be scoped and the <style> will be left in the template and rendered
     * output.
     */
    const prepareTemplateStyles = (scopeName, renderedDOM, template) => {
        shadyRenderSet.add(scopeName);
        // If `renderedDOM` is stamped from a Template, then we need to edit that
        // Template's underlying template element. Otherwise, we create one here
        // to give to ShadyCSS, which still requires one while scoping.
        const templateElement = !!template ? template.element : document.createElement('template');
        // Move styles out of rendered DOM and store.
        const styles = renderedDOM.querySelectorAll('style');
        const { length } = styles;
        // If there are no styles, skip unnecessary work
        if (length === 0) {
            // Ensure prepareTemplateStyles is called to support adding
            // styles via `prepareAdoptedCssText` since that requires that
            // `prepareTemplateStyles` is called.
            //
            // ShadyCSS will only update styles containing @apply in the template
            // given to `prepareTemplateStyles`. If no lit Template was given,
            // ShadyCSS will not be able to update uses of @apply in any relevant
            // template. However, this is not a problem because we only create the
            // template for the purpose of supporting `prepareAdoptedCssText`,
            // which doesn't support @apply at all.
            window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
            return;
        }
        const condensedStyle = document.createElement('style');
        // Collect styles into a single style. This helps us make sure ShadyCSS
        // manipulations will not prevent us from being able to fix up template
        // part indices.
        // NOTE: collecting styles is inefficient for browsers but ShadyCSS
        // currently does this anyway. When it does not, this should be changed.
        for (let i = 0; i < length; i++) {
            const style = styles[i];
            style.parentNode.removeChild(style);
            condensedStyle.textContent += style.textContent;
        }
        // Remove styles from nested templates in this scope.
        removeStylesFromLitTemplates(scopeName);
        // And then put the condensed style into the "root" template passed in as
        // `template`.
        const content = templateElement.content;
        if (!!template) {
            insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
        }
        else {
            content.insertBefore(condensedStyle, content.firstChild);
        }
        // Note, it's important that ShadyCSS gets the template that `lit-html`
        // will actually render so that it can update the style inside when
        // needed (e.g. @apply native Shadow DOM case).
        window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
        const style = content.querySelector('style');
        if (window.ShadyCSS.nativeShadow && style !== null) {
            // When in native Shadow DOM, ensure the style created by ShadyCSS is
            // included in initially rendered output (`renderedDOM`).
            renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
        }
        else if (!!template) {
            // When no style is left in the template, parts will be broken as a
            // result. To fix this, we put back the style node ShadyCSS removed
            // and then tell lit to remove that node from the template.
            // There can be no style in the template in 2 cases (1) when Shady DOM
            // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM
            // is in use ShadyCSS removes the style if it contains no content.
            // NOTE, ShadyCSS creates its own style so we can safely add/remove
            // `condensedStyle` here.
            content.insertBefore(condensedStyle, content.firstChild);
            const removes = new Set();
            removes.add(condensedStyle);
            removeNodesFromTemplate(template, removes);
        }
    };
    /**
     * Extension to the standard `render` method which supports rendering
     * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)
     * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used
     * or when the webcomponentsjs
     * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.
     *
     * Adds a `scopeName` option which is used to scope element DOM and stylesheets
     * when native ShadowDOM is unavailable. The `scopeName` will be added to
     * the class attribute of all rendered DOM. In addition, any style elements will
     * be automatically re-written with this `scopeName` selector and moved out
     * of the rendered DOM and into the document `<head>`.
     *
     * It is common to use this render method in conjunction with a custom element
     * which renders a shadowRoot. When this is done, typically the element's
     * `localName` should be used as the `scopeName`.
     *
     * In addition to DOM scoping, ShadyCSS also supports a basic shim for css
     * custom properties (needed only on older browsers like IE11) and a shim for
     * a deprecated feature called `@apply` that supports applying a set of css
     * custom properties to a given location.
     *
     * Usage considerations:
     *
     * * Part values in `<style>` elements are only applied the first time a given
     * `scopeName` renders. Subsequent changes to parts in style elements will have
     * no effect. Because of this, parts in style elements should only be used for
     * values that will never change, for example parts that set scope-wide theme
     * values or parts which render shared style elements.
     *
     * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a
     * custom element's `constructor` is not supported. Instead rendering should
     * either done asynchronously, for example at microtask timing (for example
     * `Promise.resolve()`), or be deferred until the first time the element's
     * `connectedCallback` runs.
     *
     * Usage considerations when using shimmed custom properties or `@apply`:
     *
     * * Whenever any dynamic changes are made which affect
     * css custom properties, `ShadyCSS.styleElement(element)` must be called
     * to update the element. There are two cases when this is needed:
     * (1) the element is connected to a new parent, (2) a class is added to the
     * element that causes it to match different custom properties.
     * To address the first case when rendering a custom element, `styleElement`
     * should be called in the element's `connectedCallback`.
     *
     * * Shimmed custom properties may only be defined either for an entire
     * shadowRoot (for example, in a `:host` rule) or via a rule that directly
     * matches an element with a shadowRoot. In other words, instead of flowing from
     * parent to child as do native css custom properties, shimmed custom properties
     * flow only from shadowRoots to nested shadowRoots.
     *
     * * When using `@apply` mixing css shorthand property names with
     * non-shorthand names (for example `border` and `border-width`) is not
     * supported.
     */
    const render = (result, container, options) => {
        if (!options || typeof options !== 'object' || !options.scopeName) {
            throw new Error('The `scopeName` option is required.');
        }
        const scopeName = options.scopeName;
        const hasRendered = parts.has(container);
        const needsScoping = compatibleShadyCSSVersion &&
            container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&
            !!container.host;
        // Handle first render to a scope specially...
        const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
        // On first scope render, render into a fragment; this cannot be a single
        // fragment that is reused since nested renders can occur synchronously.
        const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
        render$1(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));
        // When performing first scope render,
        // (1) We've rendered into a fragment so that there's a chance to
        // `prepareTemplateStyles` before sub-elements hit the DOM
        // (which might cause them to render based on a common pattern of
        // rendering in a custom element's `connectedCallback`);
        // (2) Scope the template with ShadyCSS one time only for this scope.
        // (3) Render the fragment into the container and make sure the
        // container knows its `part` is the one we just rendered. This ensures
        // DOM will be re-used on subsequent renders.
        if (firstScopeRender) {
            const part = parts.get(renderContainer);
            parts.delete(renderContainer);
            // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)
            // that should apply to `renderContainer` even if the rendered value is
            // not a TemplateInstance. However, it will only insert scoped styles
            // into the document if `prepareTemplateStyles` has already been called
            // for the given scope name.
            const template = part.value instanceof TemplateInstance ?
                part.value.template :
                undefined;
            prepareTemplateStyles(scopeName, renderContainer, template);
            removeNodes(container, container.firstChild);
            container.appendChild(renderContainer);
            parts.set(container, part);
        }
        // After elements have hit the DOM, update styling if this is the
        // initial render to this container.
        // This is needed whenever dynamic changes are made so it would be
        // safest to do every render; however, this would regress performance
        // so we leave it up to the user to call `ShadyCSS.styleElement`
        // for dynamic changes.
        if (!hasRendered && needsScoping) {
            window.ShadyCSS.styleElement(container.host);
        }
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    var _a;
    /**
     * Use this module if you want to create your own base class extending
     * [[UpdatingElement]].
     * @packageDocumentation
     */
    /*
     * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
     * replaced at compile time by the munged name for object[property]. We cannot
     * alias this function, so we have to use a small shim that has the same
     * behavior when not compiling.
     */
    window.JSCompiler_renameProperty =
        (prop, _obj) => prop;
    const defaultConverter = {
        toAttribute(value, type) {
            switch (type) {
                case Boolean:
                    return value ? '' : null;
                case Object:
                case Array:
                    // if the value is `null` or `undefined` pass this through
                    // to allow removing/no change behavior.
                    return value == null ? value : JSON.stringify(value);
            }
            return value;
        },
        fromAttribute(value, type) {
            switch (type) {
                case Boolean:
                    return value !== null;
                case Number:
                    return value === null ? null : Number(value);
                case Object:
                case Array:
                    // Type assert to adhere to Bazel's "must type assert JSON parse" rule.
                    return JSON.parse(value);
            }
            return value;
        }
    };
    /**
     * Change function that returns true if `value` is different from `oldValue`.
     * This method is used as the default for a property's `hasChanged` function.
     */
    const notEqual = (value, old) => {
        // This ensures (old==NaN, value==NaN) always returns false
        return old !== value && (old === old || value === value);
    };
    const defaultPropertyDeclaration = {
        attribute: true,
        type: String,
        converter: defaultConverter,
        reflect: false,
        hasChanged: notEqual
    };
    const STATE_HAS_UPDATED = 1;
    const STATE_UPDATE_REQUESTED = 1 << 2;
    const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
    const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
    /**
     * The Closure JS Compiler doesn't currently have good support for static
     * property semantics where "this" is dynamic (e.g.
     * https://github.com/google/closure-compiler/issues/3177 and others) so we use
     * this hack to bypass any rewriting by the compiler.
     */
    const finalized = 'finalized';
    /**
     * Base element class which manages element properties and attributes. When
     * properties change, the `update` method is asynchronously called. This method
     * should be supplied by subclassers to render updates as desired.
     * @noInheritDoc
     */
    class UpdatingElement extends HTMLElement {
        constructor() {
            super();
            this.initialize();
        }
        /**
         * Returns a list of attributes corresponding to the registered properties.
         * @nocollapse
         */
        static get observedAttributes() {
            // note: piggy backing on this to ensure we're finalized.
            this.finalize();
            const attributes = [];
            // Use forEach so this works even if for/of loops are compiled to for loops
            // expecting arrays
            this._classProperties.forEach((v, p) => {
                const attr = this._attributeNameForProperty(p, v);
                if (attr !== undefined) {
                    this._attributeToPropertyMap.set(attr, p);
                    attributes.push(attr);
                }
            });
            return attributes;
        }
        /**
         * Ensures the private `_classProperties` property metadata is created.
         * In addition to `finalize` this is also called in `createProperty` to
         * ensure the `@property` decorator can add property metadata.
         */
        /** @nocollapse */
        static _ensureClassProperties() {
            // ensure private storage for property declarations.
            if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
                this._classProperties = new Map();
                // NOTE: Workaround IE11 not supporting Map constructor argument.
                const superProperties = Object.getPrototypeOf(this)._classProperties;
                if (superProperties !== undefined) {
                    superProperties.forEach((v, k) => this._classProperties.set(k, v));
                }
            }
        }
        /**
         * Creates a property accessor on the element prototype if one does not exist
         * and stores a PropertyDeclaration for the property with the given options.
         * The property setter calls the property's `hasChanged` property option
         * or uses a strict identity check to determine whether or not to request
         * an update.
         *
         * This method may be overridden to customize properties; however,
         * when doing so, it's important to call `super.createProperty` to ensure
         * the property is setup correctly. This method calls
         * `getPropertyDescriptor` internally to get a descriptor to install.
         * To customize what properties do when they are get or set, override
         * `getPropertyDescriptor`. To customize the options for a property,
         * implement `createProperty` like this:
         *
         * static createProperty(name, options) {
         *   options = Object.assign(options, {myOption: true});
         *   super.createProperty(name, options);
         * }
         *
         * @nocollapse
         */
        static createProperty(name, options = defaultPropertyDeclaration) {
            // Note, since this can be called by the `@property` decorator which
            // is called before `finalize`, we ensure storage exists for property
            // metadata.
            this._ensureClassProperties();
            this._classProperties.set(name, options);
            // Do not generate an accessor if the prototype already has one, since
            // it would be lost otherwise and that would never be the user's intention;
            // Instead, we expect users to call `requestUpdate` themselves from
            // user-defined accessors. Note that if the super has an accessor we will
            // still overwrite it
            if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
                return;
            }
            const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
            const descriptor = this.getPropertyDescriptor(name, key, options);
            if (descriptor !== undefined) {
                Object.defineProperty(this.prototype, name, descriptor);
            }
        }
        /**
         * Returns a property descriptor to be defined on the given named property.
         * If no descriptor is returned, the property will not become an accessor.
         * For example,
         *
         *   class MyElement extends LitElement {
         *     static getPropertyDescriptor(name, key, options) {
         *       const defaultDescriptor =
         *           super.getPropertyDescriptor(name, key, options);
         *       const setter = defaultDescriptor.set;
         *       return {
         *         get: defaultDescriptor.get,
         *         set(value) {
         *           setter.call(this, value);
         *           // custom action.
         *         },
         *         configurable: true,
         *         enumerable: true
         *       }
         *     }
         *   }
         *
         * @nocollapse
         */
        static getPropertyDescriptor(name, key, options) {
            return {
                // tslint:disable-next-line:no-any no symbol in index
                get() {
                    return this[key];
                },
                set(value) {
                    const oldValue = this[name];
                    this[key] = value;
                    this
                        .requestUpdateInternal(name, oldValue, options);
                },
                configurable: true,
                enumerable: true
            };
        }
        /**
         * Returns the property options associated with the given property.
         * These options are defined with a PropertyDeclaration via the `properties`
         * object or the `@property` decorator and are registered in
         * `createProperty(...)`.
         *
         * Note, this method should be considered "final" and not overridden. To
         * customize the options for a given property, override `createProperty`.
         *
         * @nocollapse
         * @final
         */
        static getPropertyOptions(name) {
            return this._classProperties && this._classProperties.get(name) ||
                defaultPropertyDeclaration;
        }
        /**
         * Creates property accessors for registered properties and ensures
         * any superclasses are also finalized.
         * @nocollapse
         */
        static finalize() {
            // finalize any superclasses
            const superCtor = Object.getPrototypeOf(this);
            if (!superCtor.hasOwnProperty(finalized)) {
                superCtor.finalize();
            }
            this[finalized] = true;
            this._ensureClassProperties();
            // initialize Map populated in observedAttributes
            this._attributeToPropertyMap = new Map();
            // make any properties
            // Note, only process "own" properties since this element will inherit
            // any properties defined on the superClass, and finalization ensures
            // the entire prototype chain is finalized.
            if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
                const props = this.properties;
                // support symbols in properties (IE11 does not support this)
                const propKeys = [
                    ...Object.getOwnPropertyNames(props),
                    ...(typeof Object.getOwnPropertySymbols === 'function') ?
                        Object.getOwnPropertySymbols(props) :
                        []
                ];
                // This for/of is ok because propKeys is an array
                for (const p of propKeys) {
                    // note, use of `any` is due to TypeSript lack of support for symbol in
                    // index types
                    // tslint:disable-next-line:no-any no symbol in index
                    this.createProperty(p, props[p]);
                }
            }
        }
        /**
         * Returns the property name for the given attribute `name`.
         * @nocollapse
         */
        static _attributeNameForProperty(name, options) {
            const attribute = options.attribute;
            return attribute === false ?
                undefined :
                (typeof attribute === 'string' ?
                    attribute :
                    (typeof name === 'string' ? name.toLowerCase() : undefined));
        }
        /**
         * Returns true if a property should request an update.
         * Called when a property value is set and uses the `hasChanged`
         * option for the property if present or a strict identity check.
         * @nocollapse
         */
        static _valueHasChanged(value, old, hasChanged = notEqual) {
            return hasChanged(value, old);
        }
        /**
         * Returns the property value for the given attribute value.
         * Called via the `attributeChangedCallback` and uses the property's
         * `converter` or `converter.fromAttribute` property option.
         * @nocollapse
         */
        static _propertyValueFromAttribute(value, options) {
            const type = options.type;
            const converter = options.converter || defaultConverter;
            const fromAttribute = (typeof converter === 'function' ? converter : converter.fromAttribute);
            return fromAttribute ? fromAttribute(value, type) : value;
        }
        /**
         * Returns the attribute value for the given property value. If this
         * returns undefined, the property will *not* be reflected to an attribute.
         * If this returns null, the attribute will be removed, otherwise the
         * attribute will be set to the value.
         * This uses the property's `reflect` and `type.toAttribute` property options.
         * @nocollapse
         */
        static _propertyValueToAttribute(value, options) {
            if (options.reflect === undefined) {
                return;
            }
            const type = options.type;
            const converter = options.converter;
            const toAttribute = converter && converter.toAttribute ||
                defaultConverter.toAttribute;
            return toAttribute(value, type);
        }
        /**
         * Performs element initialization. By default captures any pre-set values for
         * registered properties.
         */
        initialize() {
            this._updateState = 0;
            this._updatePromise =
                new Promise((res) => this._enableUpdatingResolver = res);
            this._changedProperties = new Map();
            this._saveInstanceProperties();
            // ensures first update will be caught by an early access of
            // `updateComplete`
            this.requestUpdateInternal();
        }
        /**
         * Fixes any properties set on the instance before upgrade time.
         * Otherwise these would shadow the accessor and break these properties.
         * The properties are stored in a Map which is played back after the
         * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
         * (<=41), properties created for native platform properties like (`id` or
         * `name`) may not have default values set in the element constructor. On
         * these browsers native properties appear on instances and therefore their
         * default value will overwrite any element default (e.g. if the element sets
         * this.id = 'id' in the constructor, the 'id' will become '' since this is
         * the native platform default).
         */
        _saveInstanceProperties() {
            // Use forEach so this works even if for/of loops are compiled to for loops
            // expecting arrays
            this.constructor
                ._classProperties.forEach((_v, p) => {
                if (this.hasOwnProperty(p)) {
                    const value = this[p];
                    delete this[p];
                    if (!this._instanceProperties) {
                        this._instanceProperties = new Map();
                    }
                    this._instanceProperties.set(p, value);
                }
            });
        }
        /**
         * Applies previously saved instance properties.
         */
        _applyInstanceProperties() {
            // Use forEach so this works even if for/of loops are compiled to for loops
            // expecting arrays
            // tslint:disable-next-line:no-any
            this._instanceProperties.forEach((v, p) => this[p] = v);
            this._instanceProperties = undefined;
        }
        connectedCallback() {
            // Ensure first connection completes an update. Updates cannot complete
            // before connection.
            this.enableUpdating();
        }
        enableUpdating() {
            if (this._enableUpdatingResolver !== undefined) {
                this._enableUpdatingResolver();
                this._enableUpdatingResolver = undefined;
            }
        }
        /**
         * Allows for `super.disconnectedCallback()` in extensions while
         * reserving the possibility of making non-breaking feature additions
         * when disconnecting at some point in the future.
         */
        disconnectedCallback() {
        }
        /**
         * Synchronizes property values when attributes change.
         */
        attributeChangedCallback(name, old, value) {
            if (old !== value) {
                this._attributeToProperty(name, value);
            }
        }
        _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
            const ctor = this.constructor;
            const attr = ctor._attributeNameForProperty(name, options);
            if (attr !== undefined) {
                const attrValue = ctor._propertyValueToAttribute(value, options);
                // an undefined value does not change the attribute.
                if (attrValue === undefined) {
                    return;
                }
                // Track if the property is being reflected to avoid
                // setting the property again via `attributeChangedCallback`. Note:
                // 1. this takes advantage of the fact that the callback is synchronous.
                // 2. will behave incorrectly if multiple attributes are in the reaction
                // stack at time of calling. However, since we process attributes
                // in `update` this should not be possible (or an extreme corner case
                // that we'd like to discover).
                // mark state reflecting
                this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
                if (attrValue == null) {
                    this.removeAttribute(attr);
                }
                else {
                    this.setAttribute(attr, attrValue);
                }
                // mark state not reflecting
                this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
            }
        }
        _attributeToProperty(name, value) {
            // Use tracking info to avoid deserializing attribute value if it was
            // just set from a property setter.
            if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
                return;
            }
            const ctor = this.constructor;
            // Note, hint this as an `AttributeMap` so closure clearly understands
            // the type; it has issues with tracking types through statics
            // tslint:disable-next-line:no-unnecessary-type-assertion
            const propName = ctor._attributeToPropertyMap.get(name);
            if (propName !== undefined) {
                const options = ctor.getPropertyOptions(propName);
                // mark state reflecting
                this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
                this[propName] =
                    // tslint:disable-next-line:no-any
                    ctor._propertyValueFromAttribute(value, options);
                // mark state not reflecting
                this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
            }
        }
        /**
         * This protected version of `requestUpdate` does not access or return the
         * `updateComplete` promise. This promise can be overridden and is therefore
         * not free to access.
         */
        requestUpdateInternal(name, oldValue, options) {
            let shouldRequestUpdate = true;
            // If we have a property key, perform property update steps.
            if (name !== undefined) {
                const ctor = this.constructor;
                options = options || ctor.getPropertyOptions(name);
                if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
                    if (!this._changedProperties.has(name)) {
                        this._changedProperties.set(name, oldValue);
                    }
                    // Add to reflecting properties set.
                    // Note, it's important that every change has a chance to add the
                    // property to `_reflectingProperties`. This ensures setting
                    // attribute + property reflects correctly.
                    if (options.reflect === true &&
                        !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
                        if (this._reflectingProperties === undefined) {
                            this._reflectingProperties = new Map();
                        }
                        this._reflectingProperties.set(name, options);
                    }
                }
                else {
                    // Abort the request if the property should not be considered changed.
                    shouldRequestUpdate = false;
                }
            }
            if (!this._hasRequestedUpdate && shouldRequestUpdate) {
                this._updatePromise = this._enqueueUpdate();
            }
        }
        /**
         * Requests an update which is processed asynchronously. This should
         * be called when an element should update based on some state not triggered
         * by setting a property. In this case, pass no arguments. It should also be
         * called when manually implementing a property setter. In this case, pass the
         * property `name` and `oldValue` to ensure that any configured property
         * options are honored. Returns the `updateComplete` Promise which is resolved
         * when the update completes.
         *
         * @param name {PropertyKey} (optional) name of requesting property
         * @param oldValue {any} (optional) old value of requesting property
         * @returns {Promise} A Promise that is resolved when the update completes.
         */
        requestUpdate(name, oldValue) {
            this.requestUpdateInternal(name, oldValue);
            return this.updateComplete;
        }
        /**
         * Sets up the element to asynchronously update.
         */
        async _enqueueUpdate() {
            this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
            try {
                // Ensure any previous update has resolved before updating.
                // This `await` also ensures that property changes are batched.
                await this._updatePromise;
            }
            catch (e) {
                // Ignore any previous errors. We only care that the previous cycle is
                // done. Any error should have been handled in the previous update.
            }
            const result = this.performUpdate();
            // If `performUpdate` returns a Promise, we await it. This is done to
            // enable coordinating updates with a scheduler. Note, the result is
            // checked to avoid delaying an additional microtask unless we need to.
            if (result != null) {
                await result;
            }
            return !this._hasRequestedUpdate;
        }
        get _hasRequestedUpdate() {
            return (this._updateState & STATE_UPDATE_REQUESTED);
        }
        get hasUpdated() {
            return (this._updateState & STATE_HAS_UPDATED);
        }
        /**
         * Performs an element update. Note, if an exception is thrown during the
         * update, `firstUpdated` and `updated` will not be called.
         *
         * You can override this method to change the timing of updates. If this
         * method is overridden, `super.performUpdate()` must be called.
         *
         * For instance, to schedule updates to occur just before the next frame:
         *
         * ```
         * protected async performUpdate(): Promise<unknown> {
         *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
         *   super.performUpdate();
         * }
         * ```
         */
        performUpdate() {
            // Abort any update if one is not pending when this is called.
            // This can happen if `performUpdate` is called early to "flush"
            // the update.
            if (!this._hasRequestedUpdate) {
                return;
            }
            // Mixin instance properties once, if they exist.
            if (this._instanceProperties) {
                this._applyInstanceProperties();
            }
            let shouldUpdate = false;
            const changedProperties = this._changedProperties;
            try {
                shouldUpdate = this.shouldUpdate(changedProperties);
                if (shouldUpdate) {
                    this.update(changedProperties);
                }
                else {
                    this._markUpdated();
                }
            }
            catch (e) {
                // Prevent `firstUpdated` and `updated` from running when there's an
                // update exception.
                shouldUpdate = false;
                // Ensure element can accept additional updates after an exception.
                this._markUpdated();
                throw e;
            }
            if (shouldUpdate) {
                if (!(this._updateState & STATE_HAS_UPDATED)) {
                    this._updateState = this._updateState | STATE_HAS_UPDATED;
                    this.firstUpdated(changedProperties);
                }
                this.updated(changedProperties);
            }
        }
        _markUpdated() {
            this._changedProperties = new Map();
            this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
        }
        /**
         * Returns a Promise that resolves when the element has completed updating.
         * The Promise value is a boolean that is `true` if the element completed the
         * update without triggering another update. The Promise result is `false` if
         * a property was set inside `updated()`. If the Promise is rejected, an
         * exception was thrown during the update.
         *
         * To await additional asynchronous work, override the `_getUpdateComplete`
         * method. For example, it is sometimes useful to await a rendered element
         * before fulfilling this Promise. To do this, first await
         * `super._getUpdateComplete()`, then any subsequent state.
         *
         * @returns {Promise} The Promise returns a boolean that indicates if the
         * update resolved without triggering another update.
         */
        get updateComplete() {
            return this._getUpdateComplete();
        }
        /**
         * Override point for the `updateComplete` promise.
         *
         * It is not safe to override the `updateComplete` getter directly due to a
         * limitation in TypeScript which means it is not possible to call a
         * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
         * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
         * This method should be overridden instead. For example:
         *
         *   class MyElement extends LitElement {
         *     async _getUpdateComplete() {
         *       await super._getUpdateComplete();
         *       await this._myChild.updateComplete;
         *     }
         *   }
         * @deprecated Override `getUpdateComplete()` instead for forward
         *     compatibility with `lit-element` 3.0 / `@lit/reactive-element`.
         */
        _getUpdateComplete() {
            return this.getUpdateComplete();
        }
        /**
         * Override point for the `updateComplete` promise.
         *
         * It is not safe to override the `updateComplete` getter directly due to a
         * limitation in TypeScript which means it is not possible to call a
         * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
         * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
         * This method should be overridden instead. For example:
         *
         *   class MyElement extends LitElement {
         *     async getUpdateComplete() {
         *       await super.getUpdateComplete();
         *       await this._myChild.updateComplete;
         *     }
         *   }
         */
        getUpdateComplete() {
            return this._updatePromise;
        }
        /**
         * Controls whether or not `update` should be called when the element requests
         * an update. By default, this method always returns `true`, but this can be
         * customized to control when to update.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        shouldUpdate(_changedProperties) {
            return true;
        }
        /**
         * Updates the element. This method reflects property values to attributes.
         * It can be overridden to render and keep updated element DOM.
         * Setting properties inside this method will *not* trigger
         * another update.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        update(_changedProperties) {
            if (this._reflectingProperties !== undefined &&
                this._reflectingProperties.size > 0) {
                // Use forEach so this works even if for/of loops are compiled to for
                // loops expecting arrays
                this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));
                this._reflectingProperties = undefined;
            }
            this._markUpdated();
        }
        /**
         * Invoked whenever the element is updated. Implement to perform
         * post-updating tasks via DOM APIs, for example, focusing an element.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        updated(_changedProperties) {
        }
        /**
         * Invoked when the element is first updated. Implement to perform one time
         * work on the element after update.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        firstUpdated(_changedProperties) {
        }
    }
    _a = finalized;
    /**
     * Marks class as having finished creating properties.
     */
    UpdatingElement[_a] = true;

    /**
    @license
    Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at
    http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
    http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
    found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
    part of the polymer project is also subject to an additional IP rights grant
    found at http://polymer.github.io/PATENTS.txt
    */
    /**
     * Whether the current browser supports `adoptedStyleSheets`.
     */
    const supportsAdoptingStyleSheets = (window.ShadowRoot) &&
        (window.ShadyCSS === undefined || window.ShadyCSS.nativeShadow) &&
        ('adoptedStyleSheets' in Document.prototype) &&
        ('replace' in CSSStyleSheet.prototype);
    const constructionToken = Symbol();
    class CSSResult {
        constructor(cssText, safeToken) {
            if (safeToken !== constructionToken) {
                throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
            }
            this.cssText = cssText;
        }
        // Note, this is a getter so that it's lazy. In practice, this means
        // stylesheets are not created until the first element instance is made.
        get styleSheet() {
            if (this._styleSheet === undefined) {
                // Note, if `supportsAdoptingStyleSheets` is true then we assume
                // CSSStyleSheet is constructable.
                if (supportsAdoptingStyleSheets) {
                    this._styleSheet = new CSSStyleSheet();
                    this._styleSheet.replaceSync(this.cssText);
                }
                else {
                    this._styleSheet = null;
                }
            }
            return this._styleSheet;
        }
        toString() {
            return this.cssText;
        }
    }
    /**
     * Wrap a value for interpolation in a [[`css`]] tagged template literal.
     *
     * This is unsafe because untrusted CSS text can be used to phone home
     * or exfiltrate data to an attacker controlled site. Take care to only use
     * this with trusted input.
     */
    const unsafeCSS = (value) => {
        return new CSSResult(String(value), constructionToken);
    };
    const textFromCSSResult = (value) => {
        if (value instanceof CSSResult) {
            return value.cssText;
        }
        else if (typeof value === 'number') {
            return value;
        }
        else {
            throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
        }
    };
    /**
     * Template tag which which can be used with LitElement's [[LitElement.styles |
     * `styles`]] property to set element styles. For security reasons, only literal
     * string values may be used. To incorporate non-literal values [[`unsafeCSS`]]
     * may be used inside a template string part.
     */
    const css = (strings, ...values) => {
        const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
        return new CSSResult(cssText, constructionToken);
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // IMPORTANT: do not change the property name or the assignment expression.
    // This line will be used in regexes to search for LitElement usage.
    // TODO(justinfagnani): inject version number at build time
    (window['litElementVersions'] || (window['litElementVersions'] = []))
        .push('2.5.1');
    /**
     * Sentinal value used to avoid calling lit-html's render function when
     * subclasses do not implement `render`
     */
    const renderNotImplemented = {};
    /**
     * Base element class that manages element properties and attributes, and
     * renders a lit-html template.
     *
     * To define a component, subclass `LitElement` and implement a
     * `render` method to provide the component's template. Define properties
     * using the [[`properties`]] property or the [[`property`]] decorator.
     */
    class LitElement extends UpdatingElement {
        /**
         * Return the array of styles to apply to the element.
         * Override this method to integrate into a style management system.
         *
         * @nocollapse
         */
        static getStyles() {
            return this.styles;
        }
        /** @nocollapse */
        static _getUniqueStyles() {
            // Only gather styles once per class
            if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {
                return;
            }
            // Take care not to call `this.getStyles()` multiple times since this
            // generates new CSSResults each time.
            // TODO(sorvell): Since we do not cache CSSResults by input, any
            // shared styles will generate new stylesheet objects, which is wasteful.
            // This should be addressed when a browser ships constructable
            // stylesheets.
            const userStyles = this.getStyles();
            if (Array.isArray(userStyles)) {
                // De-duplicate styles preserving the _last_ instance in the set.
                // This is a performance optimization to avoid duplicated styles that can
                // occur especially when composing via subclassing.
                // The last item is kept to try to preserve the cascade order with the
                // assumption that it's most important that last added styles override
                // previous styles.
                const addStyles = (styles, set) => styles.reduceRight((set, s) => 
                // Note: On IE set.add() does not return the set
                Array.isArray(s) ? addStyles(s, set) : (set.add(s), set), set);
                // Array.from does not work on Set in IE, otherwise return
                // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()
                const set = addStyles(userStyles, new Set());
                const styles = [];
                set.forEach((v) => styles.unshift(v));
                this._styles = styles;
            }
            else {
                this._styles = userStyles === undefined ? [] : [userStyles];
            }
            // Ensure that there are no invalid CSSStyleSheet instances here. They are
            // invalid in two conditions.
            // (1) the sheet is non-constructible (`sheet` of a HTMLStyleElement), but
            //     this is impossible to check except via .replaceSync or use
            // (2) the ShadyCSS polyfill is enabled (:. supportsAdoptingStyleSheets is
            //     false)
            this._styles = this._styles.map((s) => {
                if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
                    // Flatten the cssText from the passed constructible stylesheet (or
                    // undetectable non-constructible stylesheet). The user might have
                    // expected to update their stylesheets over time, but the alternative
                    // is a crash.
                    const cssText = Array.prototype.slice.call(s.cssRules)
                        .reduce((css, rule) => css + rule.cssText, '');
                    return unsafeCSS(cssText);
                }
                return s;
            });
        }
        /**
         * Performs element initialization. By default this calls
         * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and
         * captures any pre-set values for registered properties.
         */
        initialize() {
            super.initialize();
            this.constructor._getUniqueStyles();
            this.renderRoot = this.createRenderRoot();
            // Note, if renderRoot is not a shadowRoot, styles would/could apply to the
            // element's getRootNode(). While this could be done, we're choosing not to
            // support this now since it would require different logic around de-duping.
            if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
                this.adoptStyles();
            }
        }
        /**
         * Returns the node into which the element should render and by default
         * creates and returns an open shadowRoot. Implement to customize where the
         * element's DOM is rendered. For example, to render into the element's
         * childNodes, return `this`.
         * @returns {Element|DocumentFragment} Returns a node into which to render.
         */
        createRenderRoot() {
            return this.attachShadow(this.constructor.shadowRootOptions);
        }
        /**
         * Applies styling to the element shadowRoot using the [[`styles`]]
         * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
         * available and will fallback otherwise. When Shadow DOM is polyfilled,
         * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
         * is available but `adoptedStyleSheets` is not, styles are appended to the
         * end of the `shadowRoot` to [mimic spec
         * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
         */
        adoptStyles() {
            const styles = this.constructor._styles;
            if (styles.length === 0) {
                return;
            }
            // There are three separate cases here based on Shadow DOM support.
            // (1) shadowRoot polyfilled: use ShadyCSS
            // (2) shadowRoot.adoptedStyleSheets available: use it
            // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
            // rendering
            if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {
                window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);
            }
            else if (supportsAdoptingStyleSheets) {
                this.renderRoot.adoptedStyleSheets =
                    styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
            }
            else {
                // This must be done after rendering so the actual style insertion is done
                // in `update`.
                this._needsShimAdoptedStyleSheets = true;
            }
        }
        connectedCallback() {
            super.connectedCallback();
            // Note, first update/render handles styleElement so we only call this if
            // connected after first update.
            if (this.hasUpdated && window.ShadyCSS !== undefined) {
                window.ShadyCSS.styleElement(this);
            }
        }
        /**
         * Updates the element. This method reflects property values to attributes
         * and calls `render` to render DOM via lit-html. Setting properties inside
         * this method will *not* trigger another update.
         * @param _changedProperties Map of changed properties with old values
         */
        update(changedProperties) {
            // Setting properties in `render` should not trigger an update. Since
            // updates are allowed after super.update, it's important to call `render`
            // before that.
            const templateResult = this.render();
            super.update(changedProperties);
            // If render is not implemented by the component, don't call lit-html render
            if (templateResult !== renderNotImplemented) {
                this.constructor
                    .render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
            }
            // When native Shadow DOM is used but adoptedStyles are not supported,
            // insert styling after rendering to ensure adoptedStyles have highest
            // priority.
            if (this._needsShimAdoptedStyleSheets) {
                this._needsShimAdoptedStyleSheets = false;
                this.constructor._styles.forEach((s) => {
                    const style = document.createElement('style');
                    style.textContent = s.cssText;
                    this.renderRoot.appendChild(style);
                });
            }
        }
        /**
         * Invoked on each update to perform rendering tasks. This method may return
         * any value renderable by lit-html's `NodePart` - typically a
         * `TemplateResult`. Setting properties inside this method will *not* trigger
         * the element to update.
         */
        render() {
            return renderNotImplemented;
        }
    }
    /**
     * Ensure this class is marked as `finalized` as an optimization ensuring
     * it will not needlessly try to `finalize`.
     *
     * Note this property name is a string to prevent breaking Closure JS Compiler
     * optimizations. See updating-element.ts for more information.
     */
    LitElement['finalized'] = true;
    /**
     * Reference to the underlying library method used to render the element's
     * DOM. By default, points to the `render` method from lit-html's shady-render
     * module.
     *
     * **Most users will never need to touch this property.**
     *
     * This  property should not be confused with the `render` instance method,
     * which should be overridden to define a template for the element.
     *
     * Advanced users creating a new base class based on LitElement can override
     * this property to point to a custom render method with a signature that
     * matches [shady-render's `render`
     * method](https://lit-html.polymer-project.org/api/modules/shady_render.html#render).
     *
     * @nocollapse
     */
    LitElement.render = render;
    /** @nocollapse */
    LitElement.shadowRootOptions = { mode: 'open' };

    class Component$1 extends LitElement {}

    const _shadowRoot$1 = Symbol("shadowRoot");
    const _handleButtonClick = Symbol("_handleButtonClick");

    class MenuDisplay extends Component$1 {
    	static get styles() {
    		return css`
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			*:focus {
				outline: var(--focus-outline, 2px solid #0af);
			}

			:host([theme="concrete"]) button {
				position: relative;
				display: block;
				margin: var(--menu-gapsize, 0.15rem);
				padding: 0;
				border: none;
				background: transparent;
			}

			.panel {
				display: none;
			}

			:host([open]) .panel {
				display: block;
			}

			:host([theme="concrete"]) .panel {
				position: absolute;
				left: var(--menu-lanesize, 1rem);
				right: var(--menu-lanesize, 1rem);
				width: var(--menu-panel-width, 640px);
				max-width: calc(100% - calc(var(--menu-lanesize, 1rem) * 2));
				margin-top: var(--menu-gapsize, 0.15rem);
				margin-left: auto;
				padding: var(--menu-panel-padding, 1rem);
				background: var(--menu-panel-background, white);
				border-radius: var(--menu-panel-border-radius, 0);
				box-shadow: var(--menu-panel-box-shadow, none);
				backdrop-filter: var(--menu-panel-backdrop-filter, none);
				--webkit-backdrop-filter: var(--menu-panel-backdrop-filter, none);
			}

			:host([theme="concrete"][sticky]) .panel {
				top: 100%;
			}

			:host([theme="concrete"][lefty]) .panel {
				margin-left: unset;
				margin-right: auto;
			}
		`
    	}

    	static get properties() {
    		return {
    			toggle: {type: Function},
    			open: {type: Boolean, reflect: true},
    			theme: {type: String, reflect: true},
    			lefty: {type: Boolean, reflect: true},
    			sticky: {type: Boolean, reflect: true}
    		}
    	}

    	constructor() {
    		super();
    		this.theme = "";
    		this.open = false;
    		this.toggle = () => {};
    		this[_handleButtonClick] = () => this.toggle();
    	}

    	createRenderRoot() {
    		this[_shadowRoot$1] = this.attachShadow({mode: "closed"});
    		return this[_shadowRoot$1]
    	}

    	updated(changedProperties) {
    		if (changedProperties.has("open") && this.open)
    			this[_shadowRoot$1].querySelector("button").focus();
    	}

    	render() {
    		return html`
			<div class="display">
				<button @click="${this[_handleButtonClick]}">
					<slot name="button"></slot>
				</button>
				<div class="panel">
					<slot></slot>
				</div>
			</div>
		`
    	}
    }

    function getEdgeVersion(userAgent = navigator.userAgent) {
    	const result = /(?:^|\s)Edge\/([\d\.]+)(?:\s|$)/i.exec(userAgent);
    	return result
    		? result[1]
    		: false
    }

    const scrollUpdateEvents = ["scroll", "resize"];

    function makeScrollMarmot({onScrollUpdate}) {
    	function handleScrollUpdate() {
    		const scrollTop = window.pageYOffset
    			|| document.documentElement.scrollTop
    			|| document.body.scrollTop
    			|| 0;
    		onScrollUpdate(scrollTop);
    	}

    	for (const event of scrollUpdateEvents)
    		window.addEventListener(event, handleScrollUpdate);

    	handleScrollUpdate();

    	return {
    		dispose() {
    			for (const event of scrollUpdateEvents)
    				window.removeEventListener(event, handleScrollUpdate, {passive: true});
    		}
    	}
    }

    function getAssignedElements(slot) {
    	return Array.from(slot.assignedNodes())
    		.filter(node => node instanceof HTMLElement)
    }

    const _scrollTop = Symbol("scrollTop");
    const _shadowRoot = Symbol("shadowRoot");
    const _activeIndex = Symbol("activeIndex");
    const _toggleIndex = Symbol("toggleIndex");
    const _scrollMarmot = Symbol("scrollMarmot");
    const _getMenuDisplays = Symbol("getMenuDisplays");
    const _updateScrollPoint = Symbol("updateScrollPoint");
    const _handleBlanketClick = Symbol("handleBlanketClick");

    const isEdge17 = (getEdgeVersion() || "").startsWith("17.");

    class MenuSystem extends Component$1 {
    	static get properties() {
    		return {
    			["initially-hidden"]: {type: Boolean, reflect: true},
    			theme: {type: String, reflect: true},
    			lefty: {type: Boolean, reflect: true},
    			active: {type: Boolean, reflect: true},
    			sticky: {type: Boolean, reflect: true},
    			[_scrollTop]: {type: Number},
    			[_activeIndex]: {type: String}
    		}
    	}

    	constructor() {
    		super();

    		this.theme = "concrete";
    		this.active = false;
    		this.sticky = false;
    		this.lefty = false;
    		if (isEdge17) this.setAttribute("data-edge-17", "data-edge-17");

    		this[_activeIndex] = undefined;
    		this[_scrollTop] = 0;
    		this[_scrollMarmot] = undefined;

    		this[_updateScrollPoint] = scrollPoint => {
    			if (!this.active) this[_scrollTop] = scrollPoint;
    		};

    		this[_handleBlanketClick] = () => {
    			this[_toggleIndex](this[_activeIndex]);
    		};

    		this[_toggleIndex] = index => {
    			this[_activeIndex] = index === this[_activeIndex]
    				? undefined
    				: index;
    			this.active = this[_activeIndex] !== undefined;
    		};

    		this[_getMenuDisplays] = () => {
    			const slot = this[_shadowRoot].querySelector("slot");
    			return getAssignedElements(slot).filter(
    				element => element instanceof MenuDisplay
    			)
    		};
    	}

    	createRenderRoot() {
    		this[_shadowRoot] = this.attachShadow({mode: "closed"});
    		this[_shadowRoot].addEventListener("slotchange", () => this.requestUpdate());
    		return this[_shadowRoot]
    	}

    	_initScrollMarmot() {
    		if (this.sticky && !this[_scrollMarmot])
    			this[_scrollMarmot] = makeScrollMarmot({
    				onScrollUpdate: this[_updateScrollPoint]
    			});
    	}

    	_disposeScrollMarmot() {
    		if (this[_scrollMarmot]) {
    			this[_scrollMarmot].dispose();
    			this[_scrollMarmot] = null;
    		}
    	}

    	connectedCallback() {
    		super.connectedCallback();
    		if (this.isConnected) this._initScrollMarmot();
    	}

    	disconnectedCallback() {
    		super.disconnectedCallback();
    		this._disposeScrollMarmot();
    	}

    	updated() {
    		this._initScrollMarmot();
    		if (!this.sticky) this._disposeScrollMarmot();

    		this[_getMenuDisplays]().forEach((display, index) => {
    			display.theme = this.theme;
    			display.lefty = this.lefty;
    			display.toggle = () => this[_toggleIndex](index);
    			display.open = index === this[_activeIndex];
    		});
    	}

    	firstUpdated() {
    		this["initially-hidden"] = false;
    	}

    	static get styles() {
    		return css`
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			*:focus {
				outline: var(--focus-outline, 2px solid cyan);
			}

			.system {
				position: static;
				margin: var(--menu-margin, auto);
			}

			:host([theme="concrete"]) .system {
				display: flex;
				align-items: flex-end;
				justify-content: flex-end;
			}

			:host([theme="concrete"][sticky]) .system {
				pointer-events: none;
				position: absolute;
				width: 100%;
				right: 0;
			}

			:host([theme="concrete"][sticky]) .system > * {
				pointer-events: all;
			}

			:host([theme="concrete"][lefty]) .system {
				right: auto;
				left: 0;
				align-items: flex-start;
				justify-content: flex-start;
			}

			:host([theme="concrete"]) .blanket {
				z-index: 99;
				display: none;
				position: fixed;
				background: var(--menu-blanket-background, rgba(0,0,0, 0.5));
				backdrop-filter: var(--menu-blanket-backdrop-filter, blur(5px));
				--webkit-backdrop-filter: var(--menu-blanket-backdrop-filter, blur(5px));
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
			}

			:host([theme="concrete"][active]) .blanket {
				display: block;
			}

			:host([theme="concrete"]) .list {
				z-index: 100;
				display: flex;
				align-items: flex-end;
				justify-content: flex-end;
				padding: var(--menu-gapsize, 0.15rem);
				background: var(--menu-background, rgba(240, 240, 240, 0.5));
			}

			:host([theme="concrete"][sticky]) .list {
				margin-right: var(--menu-lanesize, 1rem);
			}

			:host([theme="concrete"][sticky][lefty]) .list {
				margin-right: unset;
				margin-left: var(--menu-lanesize, 1rem);
			}

			:host([theme="concrete"]) .list slot::slotted(menu-display) {
				display: block;
				flex: 0 0 auto;
			}

			/* gross edge 17 stuff we all want to forget about */

			:host([data-edge-17][theme="concrete"]) .system {
				z-index: 100;
				position: absolute;
				width: 100%;
				right: 0;
			}

			:host([data-edge-17][theme="concrete"]) .blanket {
				z-index: 0;
			}
		`
    	}

    	render() {
    		const top = this.sticky
    			? this[_scrollTop]
    			: 0;
    		return html`
			<div class="system" style="${`top: ${top}px`}">
				<div class="blanket" @click="${this[_handleBlanketClick]}"></div>
				<div class="list">
					<slot></slot>
				</div>
			</div>
		`
    	}
    }

    function dashify$1(camel) {
    	return camel.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase()
    }

    function registerComponents$1(components) {
    	for (const componentName of Object.keys(components))
    		customElements.define(
    			dashify$1(componentName),
    			components[componentName]
    		);
    }

    registerComponents$1({MenuSystem, MenuDisplay});

    function mockPopups({ mockStripeOperations }) {
        return {
            triggerStripeConnectPopup: (async ({ stripeAccountId }) => {
                await mockStripeOperations.linkStripeAccount(stripeAccountId);
            }),
            triggerCheckoutPopup: (async ({ stripeAccountId }) => {
                console.log("");
            }),
        };
    }

    async function mockRegisterApp({ ownerEmail, adminEmail, appOrigins, backend }) {
        const mockBrowserForPlatform = await backend.mockBrowser();
        const mockWindowForPlatform = await mockBrowserForPlatform.mockAppWindow({
            appId: backend.platformAppId,
        });
        const { accessModel, appsModel } = mockWindowForPlatform.models;
        await accessModel.sendLoginLink(ownerEmail);
        await accessModel.login(backend.emails.recallLatestLoginEmail().loginToken);
        const { appId } = await appsModel.registerApp({
            label: "Mock App",
            home: window.location.href,
            origins: appOrigins,
        });
        console.log("mock: register app", appId);
        await appsModel.appEditService.assignAdmin({
            appId,
            email: adminEmail,
        });
        // TODO reactivate store
        // // link bank account with stripe
        // await mockWindowForPlatform.models.storeModel.shares.bank.setupStripeAccount(appId)
        // const stripeDetails = await mockWindowForPlatform.models.bankModel.getStripeAccountDetails(appId)
        // console.log("mock: app stripe details", stripeDetails)
        return appId;
    }

    class ApiError extends Error {
        name = this.constructor.name;
        code;
        constructor(code, message) {
            super(message);
            this.code = code;
        }
    }

    function objectMap$1(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }

    const is_service = Symbol("is_service");

    const mock = (options = {}) => ({
        forService: (service) => mockService(service, [], options),
        forApi(api) {
            return {
                withMetaMap(map, getHeaders = async () => undefined) {
                    const recurse2 = prepareRecursiveMapping((service, getter, path) => mockService(service, path, options).withMeta(getter, getHeaders));
                    return recurse2(api, map);
                },
                withAuthMap(map) {
                    const recurse2 = prepareRecursiveMapping((service, getter, path) => mockService(service, path, options).withAuth(getter));
                    return recurse2(api, map);
                },
            };
        },
    });
    function mockService(service, path, options) {
        function prepareProxy(getAuth) {
            const overrides = {};
            return new Proxy({}, {
                set: (t, key, value) => {
                    overrides[key] = value;
                    return true;
                },
                get: (t, key) => (overrides[key] ?? (async (...params) => {
                    const auth = await getAuth();
                    const method = service.expose(auth)[key];
                    if (method) {
                        return options.spike
                            ? options.spike([...path, key].join("."), method, ...params)
                            : method(...params);
                    }
                    else
                        throw new ApiError(400, `renraku remote method "${key}" not found`);
                })),
            });
        }
        return {
            withMeta(getMeta, getHeaders = async () => undefined) {
                return prepareProxy(async () => service.policy(await getMeta(), await getHeaders()));
            },
            withAuth(getAuth) {
                return prepareProxy(getAuth);
            },
        };
    }
    function prepareRecursiveMapping(handler) {
        return function recursiveMapping(apiGroup, mapGroup, path = []) {
            return objectMap$1(apiGroup, (value, key) => {
                const newPath = [...path, key];
                if (value[is_service]) {
                    const service = value;
                    return handler(service, mapGroup[key], newPath);
                }
                else {
                    const nextApiGroup = value;
                    const nextMapGroup = mapGroup[key];
                    return recursiveMapping(nextApiGroup, nextMapGroup, newPath);
                }
            });
        };
    }

    const service = () => ({
        policy(p) {
            return {
                expose(e) {
                    return {
                        [is_service]: is_service,
                        expose: e,
                        policy: p,
                    };
                },
            };
        },
    });
    function api(api) {
        return api;
    }

    async function waitForMockLatency(mockLatency) {
        if (mockLatency) {
            const { min, max } = mockLatency;
            if (min > max)
                throw new Error("invalid mock latency (min cannot exceed max)");
            const difference = max - min;
            const latency = min + (Math.random() * difference);
            return new Promise(resolve => setTimeout(resolve, latency));
        }
    }

    /**
     * create a pub/sub context
     */
    function pubsub() {
        let listeners = [];
        return {
            publish: (async (...args) => {
                const operations = listeners.map(listener => listener(...args));
                await Promise.all(operations);
            }),
            subscribe(func) {
                listeners.push(func);
                return () => {
                    listeners = listeners.filter(listener => listener !== func);
                };
            },
            dispose: () => {
                listeners = [];
            },
        };
    }
    /**
     * create a separated group of publish and subscribe functions
     */
    function pubsubs(obj) {
        const publishers = {};
        const subscribers = {};
        for (const [key, original] of Object.entries(obj)) {
            publishers[key] = original.publish;
            subscribers[key] = original.subscribe;
        }
        return { publishers, subscribers };
    }

    const browser = typeof atob === "function";
    function encode(text) {
        return browser
            ? btoa(text)
            : Buffer.from(text).toString("base64");
    }
    function decode(base64) {
        return browser
            ? atob(base64)
            : Buffer.from(base64, "base64").toString("binary");
    }
    const url$1 = Object.freeze({
        encode: (text) => {
            const base64 = encode(text);
            const base64url = addEqualsPadding(base64
                .replace(/=/g, "")
                .replace(/\+/g, "-")
                .replace(/\//g, "_"));
            return base64url;
        },
        decode: (base64url) => {
            const base64 = base64url
                .replace(/-/g, "+")
                .replace(/_/g, "/");
            return decode(base64);
        },
    });
    function addEqualsPadding(base64) {
        return base64 + Array((4 - base64.length % 4) % 4 + 1).join("=");
    }

    const tokenDecode = function decode(token) {
        const [headerPart, dataPart] = token.split(".");
        const header = decodePart(headerPart);
        const data = decodePart(dataPart);
        return { header, data };
    };
    function decodePart(part) {
        return JSON.parse(decodeURIComponent(url$1.decode(part)
            .split("")
            .map(c => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2))
            .join("")));
    }

    const expiryRenewalCushion = 60 * 1000;
    function isTokenTimingExpired(exp) {
        const expiry = exp * 1000;
        return Date.now() > (expiry - expiryRenewalCushion);
    }

    function isTokenValid(token) {
        return !!token
            && !isTokenTimingExpired(tokenDecode(token).data.exp);
    }

    const decodeAccessToken = (accessToken) => {
        return tokenDecode(accessToken).data.payload;
    };

    function makeAuthMediator({ appId, storage, greenService, }) {
        const tokenChangeEvent = pubsub();
        const accessEvent = pubsub();
        const key = `auth-tokens-${appId}`;
        const emptyTokens = () => ({ accessToken: undefined, refreshToken: undefined });
        const getTokens = async () => await storage.read(key) ?? emptyTokens();
        const setTokens = async (tokens) => storage.write(key, tokens);
        async function commitTokens(tokens) {
            const access = decodeAccessToken(tokens.accessToken);
            await setTokens(tokens);
            tokenChangeEvent.publish();
            await accessEvent.publish(access);
            return access;
        }
        async function authorize(refreshToken) {
            const accessToken = await greenService.authorize({
                appId,
                refreshToken,
                scope: { core: true },
            });
            const access = await commitTokens({ accessToken, refreshToken });
            return { access, accessToken };
        }
        const obtainAccessAndReauthorizeIfNecessary = (async () => {
            const { accessToken, refreshToken } = await getTokens();
            return isTokenValid(accessToken)
                ? { accessToken, access: decodeAccessToken(accessToken) }
                : isTokenValid(refreshToken)
                    ? authorize(refreshToken)
                    : authorize(undefined);
        });
        return {
            subscribeToAccessChange: accessEvent.subscribe,
            subscribeToTokenChange: tokenChangeEvent.subscribe,
            async initialize() {
                const { access } = await obtainAccessAndReauthorizeIfNecessary();
                await accessEvent.publish(access);
                return access;
            },
            async getValidAccess() {
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
            async getValidAccessToken() {
                return (await obtainAccessAndReauthorizeIfNecessary()).accessToken;
            },
            async login(tokens) {
                return commitTokens(tokens);
            },
            async logout() {
                await setTokens(emptyTokens());
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
            async reauthorize() {
                const tokens = await getTokens();
                await setTokens({ ...tokens, accessToken: undefined });
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
        };
    }

    function prepareApiShape({ appId, storage }) {
        let authMediator;
        async function getStandardMeta() {
            return {
                accessToken: await authMediator.getValidAccessToken(),
            };
        }
        const metaMap = {
            auth: {
                apps: {
                    appService: getStandardMeta,
                    appEditService: getStandardMeta,
                },
                permissions: {
                    permissionsService: getStandardMeta,
                },
                users: {
                    greenService: async () => undefined,
                    loginService: getStandardMeta,
                    personalService: getStandardMeta,
                    userService: getStandardMeta,
                },
            },
            example: {
                exampleService: getStandardMeta,
            },
            administrative: {
                roleAssignmentService: getStandardMeta,
            },
            questions: {
                questionsModerationService: getStandardMeta,
                questionsPostingService: getStandardMeta,
                questionsReadingService: getStandardMeta,
                questionsAnsweringService: getStandardMeta,
            },
            videos: {
                dacastService: getStandardMeta,
                contentService: getStandardMeta,
            },
            notes: {
                notesService: getStandardMeta,
            },
        };
        function installAuthMediator({ greenService }) {
            authMediator = makeAuthMediator({
                appId,
                storage,
                greenService,
            });
            return authMediator;
        }
        return {
            metaMap,
            installAuthMediator,
        };
    }

    async function stopwatch(promise) {
        const start = Date.now();
        const result = await promise;
        const time = Date.now() - start;
        return [time, result];
    }

    function mockRemote({ api, appId, storage, headers, logging, }) {
        const { metaMap, installAuthMediator } = prepareApiShape({
            appId,
            storage,
        });
        let mockLatency;
        function setMockLatency(value) {
            mockLatency = value;
        }
        const spike = async (method, func, ...params) => {
            const [mockTime] = await stopwatch(waitForMockLatency(mockLatency));
            const [executionTime, result] = await stopwatch(func(...params));
            if (logging)
                console.log(` ${method}() ${executionTime}ms + mock ${mockTime}ms`);
            return result;
        };
        const remote = mock({ spike })
            .forApi(api)
            .withMetaMap(metaMap, async () => headers);
        const authMediator = installAuthMediator({
            greenService: remote.auth.users.greenService,
        });
        return { remote, authMediator, setMockLatency };
    }

    (function(global) {
        var channels = [];

        function BroadcastChannel(channel) {
            var $this = this;
            channel = String(channel);

            var id = '$BroadcastChannel$' + channel + '$';

            channels[id] = channels[id] || [];
            channels[id].push(this);

            this._name = channel;
            this._id = id;
            this._closed = false;
            this._mc = new MessageChannel();
            this._mc.port1.start();
            this._mc.port2.start();

            global.addEventListener('storage', function(e) {
                if (e.storageArea !== global.localStorage) return;
                if (e.newValue == null || e.newValue === '') return;
                if (e.key.substring(0, id.length) !== id) return;
                var data = JSON.parse(e.newValue);
                $this._mc.port2.postMessage(data);
            });
        }

        BroadcastChannel.prototype = {
            // BroadcastChannel API
            get name() {
                return this._name;
            },
            postMessage: function(message) {
                var $this = this;
                if (this._closed) {
                    var e = new Error();
                    e.name = 'InvalidStateError';
                    throw e;
                }
                var value = JSON.stringify(message);

                // Broadcast to other contexts via storage events...
                var key = this._id + String(Date.now()) + '$' + String(Math.random());
                global.localStorage.setItem(key, value);
                setTimeout(function() {
                    global.localStorage.removeItem(key);
                }, 500);

                // Broadcast to current context via ports
                channels[this._id].forEach(function(bc) {
                    if (bc === $this) return;
                    bc._mc.port2.postMessage(JSON.parse(value));
                });
            },
            close: function() {
                if (this._closed) return;
                this._closed = true;
                this._mc.port1.close();
                this._mc.port2.close();

                var index = channels[this._id].indexOf(this);
                channels[this._id].splice(index, 1);
            },

            // EventTarget API
            get onmessage() {
                return this._mc.port1.onmessage;
            },
            set onmessage(value) {
                this._mc.port1.onmessage = value;
            },
            addEventListener: function(/*type, listener , useCapture*/) {
                return this._mc.port1.addEventListener.apply(this._mc.port1, arguments);
            },
            removeEventListener: function(/*type, listener , useCapture*/) {
                return this._mc.port1.removeEventListener.apply(this._mc.port1, arguments);
            },
            dispatchEvent: function(/*event*/) {
                return this._mc.port1.dispatchEvent.apply(this._mc.port1, arguments);
            },
        };

        global.BroadcastChannel = global.BroadcastChannel || BroadcastChannel;
    })(self);

    function wireMediatorBroadcastChannel({ appId, authMediator }) {
        const channel = new BroadcastChannel("tokenChangeEvent");
        authMediator.subscribeToTokenChange(() => channel.postMessage({ appId }));
        channel.onmessage = (event) => {
            if (event.data.appId === appId)
                authMediator.initialize();
        };
    }

    async function mockWiredRemote({ appId, appOrigin, storage, backend, }) {
        const { remote, authMediator, setMockLatency } = mockRemote({
            appId,
            storage,
            logging: true,
            api: backend.api,
            headers: { origin: appOrigin },
        });
        wireMediatorBroadcastChannel({ appId, authMediator });
        return { remote, authMediator, setMockLatency };
    }

    const second = 1000;
    const minute = 60 * second;
    const hour = 60 * minute;
    const day = 24 * hour;
    const year = 365 * day;
    const month = year / 12;

    const mockConfig = ({ platformHome, platformOrigins }) => ({
        server: {
            port: 4999,
            detailedLogs: true,
        },
        platform: {
            legalLink: "https://xiome.io/legal",
            technician: {
                email: "chasemoskal@gmail.com",
            },
            appDetails: {
                appId: "27a9f4e61286d562c85df1862e88c50e6b5c0707cc84e3e1df4aeb9d9c236814",
                label: "Xiome Cloud",
                home: platformHome,
                origins: platformOrigins,
            },
        },
        dacast: "mock-mode",
        email: "mock-console",
        database: "mock-storage",
        stripe: "mock-mode",
        chat: {
            port: 8001
        },
        crypto: {
            keys: "mock-mode",
            tokenLifespans: {
                login: 5 * minute,
                refresh: 30 * day,
                access: 5 * minute,
                external: 5 * minute,
            },
        },
    });

    const isNode = (typeof process !== "undefined")
        && (process?.release?.name === "node");

    function encodeHex(binary) {
        let result = "";
        for (const byte of new Uint8Array(binary))
            result += ("0" + (byte & 0xFF).toString(16)).slice(-2);
        return result;
    }
    const hexabet = "0123456789abcdef";
    function isStrictHex(text) {
        for (const character of text)
            if (!hexabet.includes(character))
                return false;
        return true;
    }
    function isHex(text) {
        return isStrictHex(text.toLowerCase());
    }
    function decodeHex(text) {
        const hex = text.toLowerCase();
        if (!isStrictHex(hex))
            throw new Error("decodeHex: invalid hex");
        const result = [];
        for (let i = 0; i < hex.length; i += 2)
            result.push(parseInt(hex.substr(i, 2), 16));
        return new Uint8Array(result).buffer;
    }

    var __classPrivateFieldSet$d = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$h = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _DamnId_binary, _DamnId_string;
    class DamnId {
        constructor(binary) {
            _DamnId_binary.set(this, void 0);
            _DamnId_string.set(this, void 0);
            __classPrivateFieldSet$d(this, _DamnId_binary, binary, "f");
            __classPrivateFieldSet$d(this, _DamnId_string, encodeHex(binary), "f");
        }
        static fromBinary(binary) {
            return new DamnId(binary);
        }
        static fromString(text) {
            const binary = decodeHex(text);
            return new DamnId(binary);
        }
        static isId(text) {
            return text.length === 64 && isHex(text);
        }
        get binary() { return __classPrivateFieldGet$h(this, _DamnId_binary, "f"); }
        get string() { return __classPrivateFieldGet$h(this, _DamnId_string, "f"); }
        toBinary() { return __classPrivateFieldGet$h(this, _DamnId_binary, "f"); }
        toString() { return __classPrivateFieldGet$h(this, _DamnId_string, "f"); }
    }
    _DamnId_binary = new WeakMap(), _DamnId_string = new WeakMap();

    async function getRando({ isNode: isNode$1 = isNode } = {}) {
        const randomBuffer = isNode$1
            ? await (async () => {
                const crypto = await import('crypto');
                return (bytes) => crypto.randomBytes(bytes).buffer;
            })()
            : (bytes) => crypto.getRandomValues(new Uint8Array(bytes)).buffer;
        const compare = isNode$1
            ? await (async () => {
                const crypto = await import('crypto');
                return (a, b) => crypto.timingSafeEqual(Buffer.from(a, "utf8"), Buffer.from(b, "utf8"));
            })()
            : (a, b) => {
                console.warn("insecure compare");
                return a === b;
            };
        function random() {
            const buffer = randomBuffer(8);
            const ints = new Int8Array(buffer);
            ints[7] = 63;
            ints[6] |= 0xf0;
            const view = new DataView(buffer);
            return view.getFloat64(0, true) - 1;
        }
        // function randomId_old() {
        // 	const buffer = randomBuffer(32)
        // 	return identifierFromBinary(buffer)
        // }
        function randomId() {
            const buffer = randomBuffer(32);
            return new DamnId(buffer);
        }
        function randomSample(palette) {
            return palette[Math.floor(random() * palette.length)];
        }
        function randomSequence(length, palette) {
            const results = [];
            while (results.length < length) {
                const sample = randomSample(palette);
                results.push(sample);
            }
            return results.join("");
        }
        return {
            random,
            compare,
            randomId,
            randomBuffer,
            randomSample,
            randomSequence,
        };
    }

    function pub() {
        const records = new Map();
        return {
            subscribe(...listeners) {
                if (listeners.length) {
                    const id = Symbol();
                    records.set(id, listeners);
                    return () => {
                        records.delete(id);
                    };
                }
            },
            async publish(...args) {
                await Promise.all(Array.from(records.values())
                    .flat()
                    .map(listener => listener(...args)));
            },
            clear() {
                records.clear();
            },
        };
    }

    function onesie(operation) {
        let activeOperation;
        return async function (...args) {
            if (activeOperation)
                return activeOperation;
            else {
                activeOperation = operation(...args);
                const result = await activeOperation;
                activeOperation = undefined;
                return result;
            }
        };
    }

    var Ops;
    (function (Ops) {
        (function (Mode) {
            Mode[Mode["None"] = 0] = "None";
            Mode[Mode["Loading"] = 1] = "Loading";
            Mode[Mode["Error"] = 2] = "Error";
            Mode[Mode["Ready"] = 3] = "Ready";
        })(Ops.Mode || (Ops.Mode = {}));
    })(Ops || (Ops = {}));
    const ops = {
        none: () => ({
            mode: Ops.Mode.None,
        }),
        loading: () => ({
            mode: Ops.Mode.Loading,
        }),
        error: (reason) => ({
            mode: Ops.Mode.Error,
            reason,
        }),
        ready: (value) => ({
            mode: Ops.Mode.Ready,
            value,
        }),
        replaceValue(op, value) {
            return op.mode === Ops.Mode.Ready
                ? { ...op, value }
                : op;
        },
        isNone: (op) => op.mode === Ops.Mode.Ready,
        isLoading: (op) => op.mode === Ops.Mode.Loading,
        isError: (op) => op.mode === Ops.Mode.Error,
        isReady: (op) => op.mode === Ops.Mode.Ready,
        value(op) {
            return op.mode === Ops.Mode.Ready
                ? op.value
                : undefined;
        },
        select(op, options) {
            switch (op.mode) {
                case Ops.Mode.None: return options.none();
                case Ops.Mode.Loading: return options.loading();
                case Ops.Mode.Error: return options.error(op.reason);
                case Ops.Mode.Ready: return options.ready(op.value);
            }
        },
        async operation({ promise, errorReason = "an error occurred", setOp, }) {
            setOp(ops.loading());
            try {
                const value = await promise;
                setOp(ops.ready(value));
                return value;
            }
            catch (error) {
                setOp(ops.error(errorReason));
                throw error;
            }
        },
        mode(op) {
            return ops.select(op, {
                none: () => "none",
                loading: () => "loading",
                error: () => "error",
                ready: () => "ready",
            });
        },
        combine(...ops) {
            const isAnyError = !!ops.find(op => op.mode === Ops.Mode.Error);
            const isAnyLoading = !!ops.find(op => op.mode === Ops.Mode.Loading);
            const isAnyNotReady = !!ops.find(op => op.mode !== Ops.Mode.Ready);
            return isAnyError
                ? { mode: Ops.Mode.Error, reason: "error" }
                : isAnyLoading
                    ? { mode: Ops.Mode.Loading }
                    : isAnyNotReady
                        ? { mode: Ops.Mode.None }
                        : { mode: Ops.Mode.Ready, value: undefined };
        },
        debug(op) {
            return ops.select(op, {
                none: () => [`<op {mode: None}>`],
                loading: () => [`<op {mode: Loading}>`],
                error: reason => [`<op {mode: Error, reason: "${reason}"}>`],
                ready: value => [`<op {mode: Ready, value: `, value, `}>`],
            });
        },
    };

    function subbies() {
        const memory = new Map();
        return {
            subscribe(listener) {
                const symbol = Symbol();
                memory.set(symbol, listener);
                return () => {
                    memory.delete(symbol);
                };
            },
            publish: (context => {
                for (const [, listener] of memory)
                    listener(context);
            }),
            clear() {
                memory.clear();
            },
        };
    }

    function debounce(delay, action) {
        let latestArgs;
        let timeout;
        let promise;
        let resolve;
        let reject;
        function reset() {
            latestArgs = undefined;
            if (timeout)
                clearTimeout(timeout);
            timeout = undefined;
            promise = new Promise((res, rej) => {
                resolve = res;
                reject = rej;
            });
        }
        reset();
        return ((...args) => {
            latestArgs = args;
            if (timeout)
                clearTimeout(timeout);
            timeout = setTimeout(() => {
                Promise.resolve(action(...latestArgs))
                    .then(r => resolve(r))
                    .catch(err => reject(err))
                    .finally(() => reset());
            }, delay);
            return promise;
        });
    }

    const debounceDelay = 1;

    class SnapstateError extends Error {
        constructor() {
            super(...arguments);
            this.name = this.constructor.name;
        }
    }
    class SnapstateReadonlyError extends SnapstateError {
    }
    class SnapstateCircularError extends SnapstateError {
    }

    function trackingMechanics() {
        let activeWatch;
        const sessions = new Map();
        function unsubscribe(identifier) {
            for (const [, record] of sessions)
                record.delete(identifier);
        }
        let waiter = Promise.resolve();
        return {
            get wait() { return waiter; },
            track(state, observer, reaction) {
                const identifier = Symbol();
                activeWatch = { identifier, session: { observer, reaction } };
                observer(state);
                activeWatch = undefined;
                return () => unsubscribe(identifier);
            },
            avoidCircular(key) {
                if (activeWatch)
                    throw new SnapstateCircularError(`cannot set any properties within a reaction, not even "${key}"`);
            },
            triggerReactions: (() => {
                const reactionsQueue = new Set();
                const fireReactionsQueue = debounce(debounceDelay, (state) => {
                    for (const key of reactionsQueue) {
                        for (const [, { observer, reaction }] of sessions.get(key) ?? []) {
                            if (reaction)
                                reaction(observer(state));
                            else
                                observer(state);
                        }
                    }
                    reactionsQueue.clear();
                });
                return (state, key) => {
                    reactionsQueue.add(key);
                    const promise = fireReactionsQueue(state);
                    waiter = waiter.then(() => promise);
                };
            })(),
            reactionRegistration(key) {
                if (activeWatch) {
                    let record = sessions.get(key);
                    if (!record) {
                        record = new Map();
                        sessions.set(key, record);
                    }
                    record.set(activeWatch.identifier, activeWatch.session);
                }
            },
        };
    }

    function snapstate(actual) {
        const tracking = trackingMechanics();
        function get(t, key) {
            tracking.reactionRegistration(key);
            return actual[key];
        }
        const readable = new Proxy(actual, {
            get,
            set(t, key) {
                throw new SnapstateReadonlyError(`readonly state property "${key}"`);
            },
        });
        const { publish: rawPublish, subscribe } = subbies();
        const publishReadable = debounce(debounceDelay, () => rawPublish(readable));
        let waiter = Promise.resolve();
        const writable = new Proxy(actual, {
            get,
            set(t, key, value) {
                tracking.avoidCircular(key);
                actual[key] = value;
                tracking.triggerReactions(readable, key);
                waiter = publishReadable();
                return true;
            },
        });
        return {
            readable,
            writable,
            subscribe,
            track(observer, reaction) {
                return tracking.track(readable, observer, reaction);
            },
            async wait() {
                await Promise.all([waiter, tracking.wait]);
            },
        };
    }

    function makeChatState() {
        return snapstate({
            accessOp: ops.none(),
            connectionOp: ops.none(),
            cache: {
                mutedUserIds: [],
                rooms: {},
            },
        });
    }

    const chatRegularPrivileges = {
        "view all chats": "985dc13378d1129e4dd6303fe9e52dff97d53568ce10814805f481159c788710",
        "participate in all chats": "bd0c8dfdf3eef893a5d9f8b5d0a6cad19ad80e949ebd70428f0d7525099cdd10",
    };
    const chatPowerPrivileges = {
        "moderate all chats": "693d969777a3998de6f9a4a5583917f4e672bb96ed08c571fc7486593ca98993",
    };
    const chatPrivileges = {
        ...chatRegularPrivileges,
        ...chatPowerPrivileges,
    };

    function asPermissions(permissions) {
        return permissions;
    }
    function has(privileges, hasPrivilege) {
        const hasPrivileges = {};
        for (const key of Object.keys(privileges))
            hasPrivileges[key] = hasPrivilege;
        return hasPrivileges;
    }
    function mutable(active, privileges) {
        return has(privileges, { active, immutable: false });
    }
    function immutable(active, privileges) {
        return has(privileges, { active, immutable: true });
    }

    const storePowerPrivileges = {
        "control stripe account": "f236bd2175fbecf7925483884b8c2a2ffe0dd2f0a864cbd638046f6fc58944b5",
        "manage store": "bea0ef0db58a0d8c9ab96bb9b14f889a19893064361b0877626b510b798c6fb8",
        "give away freebies": "c2712efd490c67b44946bc6e1bbe82aee5b8ede384cff614ba7435d429993ec6",
    };

    const videoPowerPrivileges = {
        "view all videos": "22f380eb0c5c7463b8a16fcdfc2f5e58257d38f94972924e70d27a08fabb5506",
        "moderate videos": "1b19013344a59cb49bfd9bddc8dd817a9e4cfa29003437021df24bdc832ec246",
    };
    const videoPrivileges = { ...videoPowerPrivileges };

    const universalPrivilege = "c1cb5ac1000af6081ff47e80804de7542b57a1425c3faac8153e708aaf79271a";
    const commonPrivileges = {
        "read questions": "5b19b929648cbbe26c052a5016892b370f048eead1e6a303a50b7f5234ec5161",
        "post questions": "aeaae6139d05f77193ca7c272a65977c70cb188f3070359866237a5ade84ba15",
        "like questions": "5490898c541d733956b28664e7536673842e73b289fc45ab9caf143138c14a3e",
        "report questions": "f2f89d433f398b267e320e0e3b9929eb3934af5c02f7e3fb2e032fd19399ad21",
        ...chatRegularPrivileges,
    };
    const commonPowerPrivileges = {
        "edit any profile": "4240ca0331e8679a444c6c4c6a803d8a12893f1554460af426064b980164c8ee",
        "customize permissions": "f380d9b4d1001da8dc86a6e0b6a0721b92ed8060c52cd4ba433e76cbd9efe6b5",
        "answer questions": "afaa00f7bc9ab09d3bbc61a26f6d9bc666cd9bb7ac270ebbdeba3cf4dd3ab9a9",
        "moderate questions": "f6a3152a13f313a60f84d82ba8f7765afb19f70c04ef14688d802237a5d2ab5e",
        "view stats": "092866ae6378833e43ec7001188aa1829d4cf2858e42da0ad3f44a2fedbcb07b",
        "administrate user roles": "a072e9dd003a762e7d693658d8ac724be352b18da240843f691595c89020e350",
        ...videoPowerPrivileges,
        ...storePowerPrivileges,
        ...chatPowerPrivileges,
    };
    const platformPowerPrivileges = {
        "edit any app": "e5fadb4b03badd6699b355ec43e1d150d6f4df81ecc291b5b742f06ebe62a0f8",
        "view platform stats": "eec7d2ddc20df6080c4166a3dea0b2643b483ce61326cbefad95e45824810692",
    };
    const appPowerPrivileges = {};
    const active = true;
    const INACTIVE = false;
    const universalPermissions = asPermissions({
        privileges: {
            ...commonPrivileges,
            ...commonPowerPrivileges,
            "universal": universalPrivilege,
            "banned": "ffff9ebcbe8f69f3520ec574f5a1489a70bf04521d7a85fcbd25c54cc22802f1",
        },
        roles: {
            "everybody": {
                roleId: "aaaa777dc7d7e9b5e9e0386abf0cf2f059cda4f71779cc910b85e8f504452b23",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(INACTIVE, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "universal": { active: true, immutable: true },
                    "banned": { active: false, immutable: true },
                    "read questions": { active: true, immutable: false },
                    "view all chats": { active: true, immutable: false },
                },
            },
            "authenticated": {
                roleId: "bbbb642d549d06113953a01fb52a8e010150edc502b929395bfb32d250d44b1c",
                public: false,
                assignable: false,
                hasPrivileges: {
                    ...mutable(active, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: false, immutable: true },
                },
            },
            "banned": {
                roleId: "dead633608412f8eefbb40f4678ef2bafaeb7883d09a6094dafe5f69dd6a8684",
                public: true,
                assignable: true,
                hasPrivileges: {
                    ...immutable(INACTIVE, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: true, immutable: true },
                },
            },
            "technician": {
                roleId: "9999d97119a83ea3853273a93e24ae0a1f2a994eccb21dacacab6ff860d8d869",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: false, immutable: true },
                },
            },
        },
    });
    const platformPermissions = asPermissions({
        privileges: {
            ...universalPermissions.privileges,
            ...platformPowerPrivileges,
        },
        roles: {
            ...universalPermissions.roles,
            "everybody": {
                ...universalPermissions.roles.everybody,
                hasPrivileges: {
                    ...universalPermissions.roles.everybody.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "authenticated": {
                ...universalPermissions.roles.authenticated,
                hasPrivileges: {
                    ...universalPermissions.roles.authenticated.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "banned": {
                ...universalPermissions.roles.banned,
                hasPrivileges: {
                    ...universalPermissions.roles.banned.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "technician": {
                ...universalPermissions.roles.technician,
                hasPrivileges: {
                    ...universalPermissions.roles.technician.hasPrivileges,
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, platformPowerPrivileges),
                },
            },
        },
    });
    const appPermissions = asPermissions({
        privileges: {
            ...universalPermissions.privileges,
            ...appPowerPrivileges,
        },
        roles: {
            ...universalPermissions.roles,
            "everybody": {
                ...universalPermissions.roles.everybody,
                hasPrivileges: {
                    ...universalPermissions.roles.everybody.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "authenticated": {
                ...universalPermissions.roles.authenticated,
                hasPrivileges: {
                    ...universalPermissions.roles.authenticated.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "banned": {
                ...universalPermissions.roles.banned,
                hasPrivileges: {
                    ...universalPermissions.roles.banned.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "admin": {
                roleId: "d21e66058b95b3b2e80c1a00c82abd56b8ec7a4b20f0424c2a00cc6ba352efeb",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(active, appPowerPrivileges),
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: false, immutable: true },
                },
            },
            "technician": {
                ...universalPermissions.roles.technician,
                hasPrivileges: {
                    ...universalPermissions.roles.technician.hasPrivileges,
                    ...immutable(active, appPowerPrivileges),
                },
            },
        },
    });

    function chatAllowance(privileges) {
        return {
            moderateAllChats: privileges.includes(chatPrivileges["moderate all chats"]),
            participateInAllChats: privileges.includes(chatPrivileges["moderate all chats"]) ||
                privileges.includes(chatPrivileges["participate in all chats"]),
            viewAllChats: privileges.includes(chatPrivileges["moderate all chats"]) ||
                privileges.includes(chatPrivileges["participate in all chats"]) ||
                privileges.includes(chatPrivileges["view all chats"]),
            banned: privileges.includes(appPermissions.privileges["banned"]),
        };
    }

    var ChatStatus;
    (function (ChatStatus) {
        ChatStatus[ChatStatus["Offline"] = 0] = "Offline";
        ChatStatus[ChatStatus["Online"] = 1] = "Online";
    })(ChatStatus || (ChatStatus = {}));

    function makeChatRoom({ label, serverside, state }) {
        const getRoomCache = () => state.readable.cache.rooms[label];
        const getAccess = () => ops.value(state.readable.accessOp);
        return {
            get posts() {
                return getRoomCache()?.posts ?? [];
            },
            get status() {
                return getRoomCache()?.status ?? ChatStatus.Offline;
            },
            get muted() {
                return state.readable.cache.mutedUserIds;
            },
            get weAreMuted() {
                const { user: { userId } } = getAccess();
                return state.readable.cache.mutedUserIds.includes(userId);
            },
            get weAreBanned() {
                const { permit: { privileges } } = getAccess();
                return privileges.includes(appPermissions.privileges["banned"]);
            },
            setRoomStatus(status) {
                serverside.chatServer.setRoomStatus(label, status);
            },
            post(draft) {
                serverside.chatServer.post(label, draft);
            },
            remove(postIds) {
                serverside.chatServer.remove(label, postIds);
            },
            clear() {
                serverside.chatServer.clear(label);
            },
            mute(userId) {
                serverside.chatServer.mute([userId]);
            },
            unmute(userId) {
                serverside.chatServer.unmute([userId]);
            },
            unmuteAll() {
                serverside.chatServer.unmuteAll();
            },
        };
    }

    function setupRoomManagement({ state, reconnect, disconnect }) {
        async function assertConnection() {
            return ops.isReady(state.readable.connectionOp)
                ? ops.value(state.readable.connectionOp)
                : reconnect();
        }
        const followers = new Map();
        const rooms = new Map();
        function assertFollowing(label) {
            let following = followers.get(label);
            if (!following) {
                following = new Set();
                followers.set(label, following);
            }
            return following;
        }
        function assertRoom(label) {
            let room = rooms.get(label);
            if (!room) {
                room = assertConnection()
                    .then(connection => connection.serverside.chatServer.roomSubscribe(label)
                    .then(() => connection))
                    .then(connection => makeChatRoom({
                    label,
                    state,
                    serverside: connection.serverside,
                }));
                rooms.set(label, room);
            }
            return room;
        }
        function removeRoom(label) {
            const room = rooms.get(label);
            assertConnection()
                .then(connection => room.then(r => {
                connection.serverside.chatServer.roomUnsubscribe(label);
            }))
                .then(() => {
                rooms.delete(label);
                if (rooms.size === 0) {
                    return disconnect();
                }
            });
        }
        async function getRoomSession(label) {
            const following = assertFollowing(label);
            const follower = Symbol();
            following.add(follower);
            function dispose() {
                following.delete(follower);
                if (following.size === 0)
                    removeRoom(label);
            }
            return {
                dispose,
                room: await assertRoom(label),
            };
        }
        async function updateAuthSituation(auth) {
            if (auth) {
                if (rooms.size > 0)
                    await assertConnection();
            }
            else if (rooms.size === 0)
                await disconnect();
        }
        return { getRoomSession, updateAuthSituation };
    }

    const chatPostCoolOff = 3000;
    const chatRateLimitingInterval = 60000;
    const maximumNumberOfPostsShownAtOnce = 50;

    const makeChatClientside = ({ state, onChange }) => api({
        chatClient: service()
            .policy(async () => { })
            .expose(() => {
            async function triggerChange() {
                await state.wait();
                onChange();
            }
            return {
                async roomStatusChanged(room, status) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                status,
                            },
                        },
                    };
                    await triggerChange();
                },
                async postsAdded(room, posts) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                posts: [
                                    ...state.writable.cache.rooms[room]?.posts ?? [],
                                    ...posts,
                                ].slice(0, maximumNumberOfPostsShownAtOnce)
                            },
                        },
                    };
                    await triggerChange();
                },
                async postsRemoved(room, postIds) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                posts: (state.writable.cache.rooms[room]?.posts ?? [])
                                    .filter(post => !postIds.includes(post.postId))
                            },
                        },
                    };
                    await triggerChange();
                },
                async roomCleared(room) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                posts: [],
                            },
                        },
                    };
                    await triggerChange();
                },
                async usersMuted(userIds) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        mutedUserIds: [
                            ...state.writable.cache.mutedUserIds,
                            ...userIds,
                        ],
                    };
                    await triggerChange();
                },
                async usersUnmuted(userIds) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        mutedUserIds: state.writable.cache.mutedUserIds
                            .filter(userId => !userIds.includes(userId)),
                    };
                    await triggerChange();
                },
                async unmuteAll() {
                    state.writable.cache = {
                        ...state.writable.cache,
                        mutedUserIds: [],
                    };
                    await triggerChange();
                },
            };
        })
    });

    function makeChatModel({ chatConnect, getChatMeta }) {
        const changeEvent = pub();
        const state = makeChatState();
        const clientsideApi = makeChatClientside({
            state,
            onChange: changeEvent.publish,
        });
        const reconnect = onesie(async function () {
            const connection = ops.value(state.readable.connectionOp)
                ?? await ops.operation({
                    setOp: op => state.writable.connectionOp = op,
                    promise: chatConnect({
                        clientsideApi,
                        handleDisconnect: () => state.writable.connectionOp = ops.none(),
                    }),
                });
            const meta = await getChatMeta();
            await connection.serverside.chatServer.updateUserMeta(meta);
            return connection;
        });
        async function disconnect() {
            const connection = ops.value(state.readable.connectionOp);
            if (connection) {
                state.writable.connectionOp = ops.none();
                await connection.disconnect();
            }
        }
        const roomManagement = setupRoomManagement({
            state,
            reconnect,
            disconnect,
        });
        return {
            state: state.readable,
            subscribe: state.subscribe,
            subscribeToChange: changeEvent.subscribe,
            get allowance() {
                const access = ops.value(state.readable.accessOp);
                const privileges = access?.permit.privileges ?? [];
                return chatAllowance(privileges);
            },
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                const access = ops.value(op);
                await roomManagement.updateAuthSituation(!!access);
                const connection = ops.value(state.readable.connectionOp);
                if (connection) {
                    const meta = await getChatMeta();
                    await connection.serverside.chatServer.updateUserMeta(meta);
                }
            },
            session: roomManagement.getRoomSession,
            disconnect,
            reconnect,
        };
    }

    function prepareNotesCacheCreator({ propagateChangeToOtherTabs, notesService, getStats, loadStats, getIsLoggedIn, }) {
        async function loadNewNotes(pagination) {
            return notesService.getNewNotes(pagination);
        }
        async function loadOldNotes(pagination) {
            return notesService.getOldNotes(pagination);
        }
        async function markNotesNewOrOld(old, noteIds) {
            await notesService.markNotesNewOrOld({ old, noteIds });
            await loadStats();
            propagateChangeToOtherTabs.publish(undefined);
        }
        return function createNotesCache() {
            const cacheState = snapstate({
                old: false,
                pageNumber: 1,
                pageSize: 10,
                notesOp: ops.none(),
            });
            function resetPagination() {
                cacheState.writable.pageNumber = 1;
                cacheState.writable.pageSize = 10;
            }
            async function fetchAppropriateNotes() {
                if (!getIsLoggedIn()) {
                    cacheState.writable.notesOp = ops.ready([]);
                    return [];
                }
                const { old, pageNumber, pageSize } = cacheState.readable;
                const pagination = {
                    offset: ((pageNumber - 1) * pageSize),
                    limit: pageSize,
                };
                await ops.operation({
                    setOp: op => cacheState.writable.notesOp = op,
                    promise: old
                        ? loadOldNotes(pagination)
                        : loadNewNotes(pagination),
                });
            }
            function totalNumberOfPages() {
                const { old, pageSize } = cacheState.readable;
                const { oldCount, newCount } = getStats();
                const count = old
                    ? oldCount
                    : newCount;
                return Math.ceil(count / pageSize);
            }
            const isPageAvailable = {
                next: () => cacheState.writable.pageNumber < totalNumberOfPages(),
                previous: () => cacheState.writable.pageNumber > 1,
            };
            return {
                subscribe: cacheState.subscribe,
                cacheState: cacheState.readable,
                async loginStatusChanged() {
                    resetPagination();
                    await fetchAppropriateNotes();
                },
                get notes() {
                    return ops.value(cacheState.readable.notesOp);
                },
                fetchAppropriateNotes,
                async switchTabNew() {
                    cacheState.writable.old = false;
                    resetPagination();
                    await fetchAppropriateNotes();
                },
                async switchTabOld() {
                    cacheState.writable.old = true;
                    resetPagination();
                    await fetchAppropriateNotes();
                },
                get isNextPageAvailable() {
                    return isPageAvailable.next();
                },
                get isPreviousPageAvailable() {
                    return isPageAvailable.previous();
                },
                async nextPage() {
                    if (isPageAvailable.next()) {
                        cacheState.writable.pageNumber += 1;
                        await fetchAppropriateNotes();
                    }
                    else
                        throw new Error("no next page");
                },
                async previousPage() {
                    if (isPageAvailable.previous()) {
                        cacheState.writable.pageNumber -= 1;
                        await fetchAppropriateNotes();
                    }
                    else
                        throw new Error("no previous page");
                },
                async markAllNotesOld() {
                    await notesService.markAllNotesOld();
                    await loadStats();
                    propagateChangeToOtherTabs.publish(undefined);
                    await fetchAppropriateNotes();
                },
                async markSpecificNoteOld(noteId) {
                    await markNotesNewOrOld(true, [noteId]);
                    cacheState.readable.pageNumber > totalNumberOfPages() && cacheState.readable.pageNumber > 1
                        ? cacheState.writable.pageNumber -= 1
                        : null;
                    await fetchAppropriateNotes();
                },
                async markSpecificNoteNew(noteId) {
                    await markNotesNewOrOld(false, [noteId]);
                    cacheState.readable.pageNumber > totalNumberOfPages() && cacheState.readable.pageNumber > 1
                        ? cacheState.writable.pageNumber -= 1
                        : null;
                    await fetchAppropriateNotes();
                },
                get totalPages() {
                    return totalNumberOfPages();
                },
            };
        };
    }

    function makeNotesModel({ notesService }) {
        const state = snapstate({
            accessOp: ops.none(),
            statsOp: ops.none(),
        });
        const accessUpdate = subbies();
        const propagateChangeToOtherTabs = subbies();
        function getIsLoggedIn() {
            return !!ops.value(state.readable.accessOp)?.user;
        }
        function getStats() {
            return ops.value(state.readable.statsOp) ?? {
                newCount: 0,
                oldCount: 0,
            };
        }
        const loadStats = onesie(async function loadStats() {
            return ops.operation({
                promise: notesService.getNotesStats(),
                setOp: op => state.writable.statsOp = op,
            });
        });
        let initialized = false;
        async function initialize() {
            if (!initialized) {
                initialized = true;
                if (getIsLoggedIn()) {
                    return loadStats();
                }
            }
        }
        async function loadIfInitialized() {
            if (initialized)
                return loadStats();
        }
        return {
            initialize,
            state: state.readable,
            stateSubscribe: state.subscribe,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                if (getIsLoggedIn())
                    await loadIfInitialized();
                accessUpdate.publish(ops.value(op));
            },
            get isLoggedIn() {
                return getIsLoggedIn();
            },
            get stats() {
                return getStats();
            },
            propagateChangeToOtherTabs,
            loadStats,
            overwriteStatsOp(op) {
                state.writable.statsOp = op;
            },
            createNotesCacheDetails: (() => {
                const create = prepareNotesCacheCreator({
                    notesService,
                    propagateChangeToOtherTabs,
                    getStats,
                    loadStats,
                    getIsLoggedIn,
                });
                return () => {
                    const cache = create();
                    return {
                        cache,
                        setup: () => accessUpdate.subscribe(() => cache.loginStatusChanged()),
                    };
                };
            })(),
        };
    }

    function makeDacastModel({ dacastService }) {
        const linkChange = subbies();
        const state = snapstate({
            accessOp: ops.none(),
            linkedAccountOp: ops.none(),
        });
        let alreadyInitialized = false;
        const isModerator = () => {
            const access = ops.value(state.readable.accessOp);
            return access && access.permit.privileges.includes(videoPrivileges["moderate videos"]);
        };
        async function loadLinkedAccount() {
            return ops.operation({
                promise: dacastService.getLink(),
                setOp: op => state.writable.linkedAccountOp = op,
            });
        }
        async function refresh() {
            if (alreadyInitialized && isModerator()) {
                await loadLinkedAccount();
            }
        }
        return {
            state: state.readable,
            subscribe: state.subscribe,
            onLinkChange: linkChange.subscribe,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                state.writable.linkedAccountOp = ops.none();
                await refresh();
            },
            async initialize() {
                if (!alreadyInitialized) {
                    alreadyInitialized = true;
                    await refresh();
                }
            },
            get linkedAccount() {
                return ops.value(state.readable.linkedAccountOp);
            },
            async linkAccount({ apiKey }) {
                return ops.operation({
                    setOp: op => state.writable.linkedAccountOp = op,
                    promise: dacastService.setLink({ apiKey })
                        .then(link => {
                        linkChange.publish(link);
                        return link;
                    }),
                });
            },
            async unlinkAccount() {
                return ops.operation({
                    setOp: op => state.writable.linkedAccountOp = op,
                    promise: dacastService.clearLink()
                        .then(() => linkChange.publish(undefined)),
                });
            },
        };
    }

    function makeContentModel({ contentService, }) {
        const state = snapstate({
            accessOp: ops.none(),
            catalogOp: ops.none(),
            viewsOp: ops.none(),
            privilegesOp: ops.none(),
            showsOp: ops.none(),
        });
        const activeShowLabels = new Set();
        const currentlyLoadingShows = new Set();
        function getAccess() {
            return ops.value(state.readable.accessOp);
        }
        let initialized = false;
        async function loadModerationData() {
            initialized = true;
            const access = getAccess();
            const isModerator = access && access.permit
                .privileges.includes(videoPrivileges["moderate videos"]);
            if (isModerator) {
                await ops.operation({
                    promise: contentService.fetchModerationData(),
                    setOp: op => {
                        const data = ops.value(op);
                        state.writable.catalogOp = ops.replaceValue(op, data?.catalog ?? []);
                        state.writable.viewsOp = ops.replaceValue(op, data?.views ?? []);
                        state.writable.privilegesOp = ops.replaceValue(op, data?.privileges ?? []);
                    },
                });
            }
        }
        async function loadShow(label) {
            initialized = true;
            if (!getAccess() || currentlyLoadingShows.has(label))
                return undefined;
            currentlyLoadingShows.add(label);
            activeShowLabels.add(label);
            const oldShows = ops.value(state.readable.showsOp) ?? [];
            let updatedShow;
            await ops.operation({
                setOp: op => state.writable.showsOp = op,
                promise: contentService.getShows({ labels: [label] })
                    .then(shows => shows[0])
                    .then(show => updatedShow = show)
                    .then(show => [
                    ...oldShows.filter(s => s.label !== label),
                    ...(show ? [show] : [{ label, details: undefined }]),
                ]),
            });
            currentlyLoadingShows.delete(label);
            return updatedShow;
        }
        async function refreshShows() {
            initialized = true;
            if (!getAccess())
                return undefined;
            const labels = Array.from(activeShowLabels)
                .filter(label => !currentlyLoadingShows.has(label));
            if (labels.length) {
                for (const label of labels)
                    currentlyLoadingShows.add(label);
                await ops.operation({
                    setOp: op => state.writable.showsOp = op,
                    promise: contentService.getShows({ labels })
                        .then(shows => shows.filter(s => !!s))
                });
                for (const label of labels)
                    currentlyLoadingShows.delete(label);
            }
        }
        return {
            state: state.readable,
            subscribe: state.subscribe,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                state.writable.catalogOp = ops.none();
                state.writable.viewsOp = ops.none();
                if (initialized) {
                    await loadModerationData();
                    await refreshShows();
                }
            },
            async onVideoHostingUpdate() {
                if (initialized) {
                    await loadModerationData();
                    await refreshShows();
                }
            },
            async initializeForModerationData() {
                if (!initialized) {
                    await loadModerationData();
                }
            },
            async initializeForVideo(label) {
                if (!initialized) {
                    await loadShow(label);
                    await loadModerationData();
                }
                else {
                    activeShowLabels.add(label);
                }
            },
            get allowance() {
                const access = ops.value(state.readable.accessOp);
                const can = (p) => access
                    ? access.permit.privileges.includes(videoPrivileges[p])
                    : false;
                return {
                    canModerateVideos: can("moderate videos"),
                    canViewAllVideos: can("moderate videos") || can("view all videos"),
                };
            },
            get catalog() {
                return ops.value(state.readable.catalogOp) ?? [];
            },
            get views() {
                return ops.value(state.readable.viewsOp) ?? [];
            },
            get privileges() {
                return ops.value(state.readable.privilegesOp) ?? [];
            },
            get shows() {
                return ops.value(state.readable.showsOp) ?? [];
            },
            getView(label) {
                return (ops.value(state.readable.viewsOp) ?? [])
                    .find(view => view.label === label);
            },
            getPrivilege(id) {
                return (ops.value(state.readable.privilegesOp) ?? [])
                    .find(p => p.privilegeId === id);
            },
            getShow(label) {
                return (ops.value(state.readable.showsOp) ?? [])
                    .find(show => show.label === label);
            },
            async setView(options) {
                const oldViews = ops.value(state.readable.viewsOp) ?? [];
                await ops.operation({
                    setOp: op => state.writable.viewsOp = op,
                    promise: contentService.writeView(options).then(() => [
                        ...oldViews.filter(v => v.label !== options.label),
                        {
                            ...options.reference,
                            label: options.label,
                            privileges: options.privileges,
                        },
                    ]),
                });
                await loadShow(options.label);
            },
            async deleteView(label) {
                const oldViews = ops.value(state.readable.viewsOp) ?? [];
                await ops.operation({
                    setOp: op => state.writable.viewsOp = op,
                    promise: contentService.deleteView({ label })
                        .then(() => oldViews.filter(v => v.label !== label)),
                });
                const oldShows = ops.value(state.readable.showsOp) ?? [];
                state.writable.showsOp = ops.replaceValue(state.readable.showsOp, oldShows.filter(s => s.label !== label));
            },
        };
    }

    function makeVideoModels(options) {
        const dacastModel = makeDacastModel(options);
        const contentModel = makeContentModel(options);
        dacastModel.onLinkChange(contentModel.onVideoHostingUpdate);
        return {
            dacastModel,
            contentModel,
            updateAccessOp(accessOp) {
                dacastModel.updateAccessOp(accessOp);
                contentModel.updateAccessOp(accessOp);
            },
        };
    }

    function makeExampleModel({ getAccessOp }) {
        const state = snapstate({
            accessOp: getAccessOp(),
        });
        return {
            state: state.readable,
            subscribe: state.subscribe,
            updateAccessOp: (op) => {
                state.writable.accessOp = op;
            },
        };
    }

    function makeAppsModel({ appService, appEditService, getValidAccess, }) {
        const { readable, writable, subscribe } = snapstate({
            active: false,
            appRecords: ops.none(),
            addingNewApp: ops.none(),
        });
        const actions = {
            setAppRecords(op) {
                const appList = ops.value(op) ?? [];
                let records = {};
                for (const app of appList)
                    records[app.appId] = ops.ready(app);
                writable.appRecords = ops.replaceValue(op, records);
            },
            setIndividualAppRecord(appId, op) {
                if (ops.isLoading(writable.appRecords))
                    throw new Error("cannot set individual app while apps are loading");
                const apps = ops.value(writable.appRecords) ?? {};
                writable.appRecords = ops.ready({ ...apps, [appId]: op });
            },
            deleteIndividualAppRecord(appId) {
                if (ops.isReady(writable.appRecords)) {
                    const existingRecords = ops.value(writable.appRecords);
                    const records = {};
                    for (const [key, value] of Object.entries(existingRecords)) {
                        if (key !== appId)
                            records[key] = value;
                    }
                    writable.appRecords = ops.ready(records);
                }
                else
                    throw new Error("cannot delete individual app while apps are loading");
            },
        };
        async function getUserId() {
            const access = await getValidAccess();
            return access?.user?.userId;
        }
        async function loadApps() {
            writable.active = true;
            const appsPromise = ops.operation({
                promise: (async () => {
                    const userId = await getUserId();
                    return userId
                        ? appService.listApps({ ownerUserId: userId })
                        : [];
                })(),
                setOp: op => actions.setAppRecords(op),
            });
            // actions.setLoadingPromise(appsPromise.then(() => undefined))
            return appsPromise;
        }
        async function registerApp(appDraft) {
            const userId = await getUserId();
            const result = await ops.operation({
                errorReason: "failed to register app",
                promise: (async () => {
                    const result = await appService.registerApp({
                        appDraft,
                        ownerUserId: userId,
                    });
                    await appEditService.assignPlatformUserAsAdmin({
                        appId: result.appId,
                        platformUserId: userId,
                    });
                    return result;
                })(),
                setOp: op => {
                    writable.addingNewApp = ops.replaceValue(op, null);
                    if (ops.isReady(op)) {
                        const newApp = { ...ops.value(op), ...appDraft };
                        actions.setIndividualAppRecord(newApp.appId, ops.ready(newApp));
                    }
                },
            });
            return result;
        }
        async function updateApp(appId, appDraft) {
            const records = ops.value(writable.appRecords);
            if (!records)
                throw new Error("cannot update app while loading records");
            const existingApp = ops.value(records[appId]);
            if (!existingApp)
                throw new Error("cannot update app not present in records");
            return ops.operation({
                promise: appEditService.updateApp({ appId, appDraft }),
                setOp: op => actions.setIndividualAppRecord(appId, ops.replaceValue(op, { ...existingApp, ...appDraft })),
            });
        }
        function getApp(appId) {
            const records = ops.value(writable.appRecords);
            return records
                ? ops.value(records[appId])
                : undefined;
        }
        async function deleteApp(appId) {
            await ops.operation({
                promise: appEditService.deleteApp({ appId }),
                setOp: op => {
                    actions.setIndividualAppRecord(appId, ops.replaceValue(op, getApp(appId)));
                },
            });
            actions.deleteIndividualAppRecord(appId);
        }
        return {
            state: readable,
            subscribe,
            appEditService,
            getApp(appId) {
                const records = ops.value(readable.appRecords);
                return records
                    ? ops.value(records[appId])
                    : undefined;
            },
            loadApps,
            deleteApp,
            updateApp,
            registerApp,
            async updateAccessOp(op) {
                if (readable.active)
                    await loadApps();
            },
        };
    }

    function merge(newItems, oldItems, compare) {
        const result = [...newItems];
        for (const oldItem of oldItems) {
            const included = !!result.find(newItem => compare(newItem, oldItem));
            if (!included)
                result.push(oldItem);
        }
        return result;
    }

    function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    function deepFreeze(object) {
        Object.freeze(object);
        for (const value of Object.values(object)) {
            if (value && typeof value === "object")
                deepFreeze(value);
        }
        return object;
    }
    const isSet = (a) => (a !== null && a !== undefined);
    function deepEqual(a, b) {
        if (!isSet(a) || !isSet(b))
            return a === b;
        for (const [key, aValue] of Object.entries(a)) {
            if (!b.hasOwnProperty(key))
                return false;
            const bValue = b[key];
            switch (typeof aValue) {
                case "object":
                    if (!deepEqual(aValue, bValue))
                        return false;
                    break;
                case "function":
                    if (!isSet(bValue) || aValue.toString() !== bValue.toString())
                        return false;
                    break;
                default:
                    if (aValue !== bValue)
                        return false;
            }
        }
        for (const [key] of Object.entries(a))
            if (!b.hasOwnProperty(key))
                return false;
        for (const [key] of Object.entries(b))
            if (!a.hasOwnProperty(key))
                return false;
        return true;
    }

    function happystate({ state: realState, actions: makeActions, }) {
        let frozenState = deepFreeze(deepClone(realState));
        const actions = makeActions(realState);
        const { publish, subscribe: onStateChange, dispose: clearStateListeners, } = pubsub();
        const change = debounce(1, publish);
        const augmentedActions = {};
        for (const [key, action] of Object.entries(actions)) {
            augmentedActions[key] = (...args) => {
                action(...args);
                frozenState = deepFreeze(deepClone(realState));
                change();
            };
        }
        return {
            actions: augmentedActions,
            onStateChange,
            clearStateListeners,
            getState: () => frozenState,
        };
    }

    function makeQuestionsModelHappy() {
        return happystate({
            state: {
                access: undefined,
                users: [],
                questions: [],
                boardOps: {},
                postingOp: ops.ready(undefined),
            },
            actions: state => ({
                setAccess(access) {
                    state.access = access;
                },
                setBoardOp(board, op) {
                    state.boardOps = { ...state.boardOps, [board]: op };
                },
                setPostingOp(op) {
                    state.postingOp = op;
                },
                addUsers(newUsers) {
                    state.users = [...merge(newUsers.filter(u => !!u), state.users, (a, b) => a.userId === b.userId)];
                },
                addQuestions(newQuestions) {
                    state.questions = [...merge(newQuestions, state.questions, (a, b) => a.questionId === b.questionId)];
                },
                addAnswer(newAnswer) {
                    const question = state.questions
                        .find(q => q.questionId === newAnswer.questionId);
                    if (!question)
                        throw new Error(`can't find question to add answer, question id: "${newAnswer.questionId}"`);
                    const newQuestion = {
                        ...question,
                        answers: [...question.answers, newAnswer],
                    };
                    state.questions = [...merge([newQuestion], state.questions, (a, b) => a.questionId === b.questionId)];
                },
                setQuestionLike(questionId, like) {
                    state.questions = state.questions.map(question => question.questionId === questionId
                        ? {
                            ...question,
                            liked: like,
                            likes: question.liked === like
                                ? question.likes
                                : like
                                    ? question.likes + 1
                                    : question.likes - 1
                        }
                        : { ...question });
                },
                setAnswerLike(questionId, answerId, status) {
                    state.questions = state.questions.map(question => question.questionId === questionId
                        ? {
                            ...question,
                            answers: question.answers.map(answer => answer.answerId === answerId
                                ? {
                                    ...answer,
                                    liked: status,
                                    likes: answer.liked === status
                                        ? answer.likes
                                        : status
                                            ? answer.likes + 1
                                            : answer.likes - 1
                                }
                                : { ...answer })
                        }
                        : { ...question });
                },
                setAnswerReport(questionId, answerId, status) {
                    state.questions = state.questions.map(question => question.questionId === questionId
                        ? {
                            ...question,
                            answers: question.answers.map(answer => answer.answerId === answerId
                                ? {
                                    ...answer,
                                    reported: status,
                                    reports: answer.reported === status
                                        ? answer.reports
                                        : status
                                            ? answer.reports + 1
                                            : answer.reports - 1
                                }
                                : { ...answer })
                        }
                        : { ...question });
                },
                setQuestionReport(questionId, report) {
                    state.questions = state.questions.map(question => question.questionId === questionId
                        ? {
                            ...question,
                            reported: report,
                            reports: question.reported === report
                                ? question.reports
                                : report
                                    ? question.reports + 1
                                    : question.reports - 1
                        }
                        : { ...question });
                },
                setQuestionArchive(questionId, archive) {
                    state.questions = state.questions.map(question => question.questionId === questionId
                        ? { ...question, archive }
                        : { ...question });
                },
                setAnswerArchive(questionId, answerId, archive) {
                    state.questions = state.questions.map(question => question.questionId === questionId
                        ? {
                            ...question,
                            answers: question.answers.map(answer => answer.answerId === answerId
                                ? { ...answer, archive }
                                : { ...answer })
                        }
                        : { ...question });
                },
            }),
        });
    }

    function prepareQuestionsBoardModelGetter({ happy, questionsPostingService, questionsAnsweringService, questionsModerationService, getAccess, loadQuestionsForBoard, }) {
        const { actions, getState } = happy;
        return (board) => ({
            getPermissions() {
                const { access } = getState();
                return {
                    "read questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["read questions"])
                        : false,
                    "post questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["post questions"]) && !access.permit.privileges.includes(appPermissions.privileges["banned"])
                        : false,
                    "moderate questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["moderate questions"])
                        : false,
                    "answer questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["answer questions"])
                        : false,
                    "like questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["like questions"])
                        : false,
                    "report questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["report questions"])
                        : false,
                };
            },
            getBoardName() {
                return board;
            },
            getAccess() {
                return getState().access;
            },
            getBoardOp() {
                return getState().boardOps[board];
            },
            getPostingOp() {
                return getState().postingOp;
            },
            getQuestions() {
                return getState().questions
                    .filter(question => question.board === board)
                    .filter(question => question.archive === false)
                    .map(question => ({
                    ...question,
                    answers: question.answers
                        .filter(answer => answer.archive === false)
                }));
            },
            getUser(userId) {
                return getState().users.find(user => user.userId === userId);
            },
            async loadQuestions() {
                await loadQuestionsForBoard(board);
            },
            async postQuestion({ content }) {
                const question = await ops.operation({
                    promise: questionsPostingService.postQuestion({
                        questionDraft: { board, content }
                    }),
                    setOp: op => actions.setPostingOp(ops.replaceValue(op, undefined)),
                });
                actions.addQuestions([question]);
                const access = ops.value(getAccess());
                actions.addUsers([access.user]);
                return question;
            },
            async postAnswer(questionId, answerDraft) {
                const answer = await ops.operation({
                    promise: questionsAnsweringService.postAnswer({
                        questionId,
                        answerDraft,
                    }),
                    setOp: op => actions.setPostingOp(ops.replaceValue(op, undefined)),
                });
                actions.addAnswer(answer);
                const access = ops.value(getAccess());
                actions.addUsers([access.user]);
                return answer;
            },
            async likeQuestion(questionId, like) {
                await questionsPostingService.likeQuestion({
                    like: like,
                    questionId,
                });
                actions.setQuestionLike(questionId, like);
            },
            async likeAnswer(questionId, answerId, like) {
                await questionsAnsweringService.likeAnswer({ answerId, like });
                actions.setAnswerLike(questionId, answerId, like);
            },
            async reportQuestion(questionId, report) {
                await questionsPostingService.reportQuestion({
                    report,
                    questionId,
                });
                actions.setQuestionReport(questionId, report);
            },
            async reportAnswer(questionId, answerId, report) {
                await questionsAnsweringService.reportAnswer({ answerId, report });
                actions.setAnswerReport(questionId, answerId, report);
            },
            async archiveQuestion(questionId, archive) {
                await questionsPostingService.archiveQuestion({
                    archive,
                    questionId,
                });
                actions.setQuestionArchive(questionId, archive);
            },
            async archiveAnswer(questionId, answerId, archive) {
                await questionsAnsweringService.archiveAnswer({ answerId, archive });
                actions.setAnswerArchive(questionId, answerId, archive);
            },
            async archiveBoard() {
                await questionsModerationService.archiveBoard({ board });
                for (const question of getState().questions)
                    actions.setQuestionArchive(question.questionId, true);
            },
        });
    }

    function makeQuestionsModel(options) {
        const { questionsReadingService } = options;
        const happy = makeQuestionsModelHappy();
        const { actions, getState, onStateChange } = happy;
        async function loadQuestionsForBoard(board) {
            await ops.operation({
                promise: (async () => {
                    const { users, questions } = await questionsReadingService
                        .fetchQuestions({ board });
                    actions.addUsers(users);
                    actions.addQuestions(questions);
                })(),
                setOp: op => actions.setBoardOp(board, op),
            });
        }
        async function refreshAllBoards() {
            const state = getState();
            await Promise.all(Object.keys(state.boardOps).map(loadQuestionsForBoard));
        }
        return {
            onStateChange,
            makeBoardModel: prepareQuestionsBoardModelGetter({
                happy,
                loadQuestionsForBoard,
                ...options,
            }),
            accessChange: (access) => {
                actions.setAccess(access);
                if (access?.user)
                    actions.addUsers([access.user]);
                refreshAllBoards();
            },
        };
    }

    class AccessError extends Error {
    }
    class AccessLoginExpiredError extends AccessError {
        constructor() {
            super("login token has expired");
        }
    }

    function makeAccessModel({ authMediator, loginService }) {
        const state = snapstate({
            accessOp: ops.none(),
        });
        authMediator.subscribeToAccessChange(access => {
            state.writable.accessOp = ops.ready(access);
        });
        async function accessOperation(promise) {
            return ops.operation({
                promise,
                setOp: op => state.writable.accessOp = op,
            });
        }
        const loginFacilities = {
            async useExistingLogin() {
                await accessOperation(authMediator.initialize());
            },
            async sendLoginLink(email) {
                return loginService.sendLoginLink({ email });
            },
            async login(loginToken) {
                try {
                    if (isTokenValid(loginToken))
                        await accessOperation(loginService
                            .authenticateViaLoginToken({ loginToken })
                            .then(tokens => authMediator.login(tokens)));
                    else
                        throw new AccessLoginExpiredError();
                }
                catch (error) {
                    console.error(error);
                    state.writable.accessOp = ops.none();
                    await accessOperation(authMediator.initialize());
                    throw error;
                }
            },
            async logout() {
                await ops.operation({
                    promise: authMediator.logout(),
                    setOp: op => state.writable.accessOp = op,
                });
            },
            async reauthorize() {
                await accessOperation(authMediator.reauthorize());
            },
        };
        return {
            readable: state.readable,
            track: state.track,
            subscribe: state.subscribe,
            ...loginFacilities,
            getAccessOp() {
                return state.readable.accessOp;
            },
            getAccess() {
                return ops.value(state.readable.accessOp);
            },
            getValidAccess() {
                return authMediator.getValidAccess();
            },
        };
    }

    function makePersonalModel({ personalService, getAccessOp, reauthorize, }) {
        const { readable, writable, track, subscribe } = snapstate({
            accessOp: getAccessOp(),
            submitDraftOp: ops.ready(undefined),
        });
        return {
            track,
            subscribe,
            readable,
            async saveProfile(profileDraft) {
                await ops.operation({
                    promise: (async () => {
                        const { user: { userId } } = ops.value(readable.accessOp);
                        await personalService.setProfile({ userId, profileDraft });
                        await reauthorize();
                    })(),
                    errorReason: "error saving profile",
                    setOp(op) { writable.submitDraftOp = op; },
                });
            },
            updateAccessOp(op) {
                writable.accessOp = op;
            },
        };
    }

    function makeAllowanceChecker(access, privileges) {
        const allowed = {};
        for (const [key, privilegeId] of Object.entries(privileges))
            allowed[key] = access
                ? access.permit.privileges.includes(privilegeId)
                : false;
        return (privilege) => allowed[privilege];
    }

    function makeAdministrativeModel({ roleAssignmentService, reauthorize, }) {
        const state = snapstate({
            accessOp: ops.none(),
            permissionsOp: ops.none(),
        });
        function getAccess() {
            return ops.value(state.readable.accessOp);
        }
        let initializedInDom = false;
        function allowanceChecker() {
            return makeAllowanceChecker(getAccess(), appPermissions.privileges);
        }
        async function loadPermissions() {
            if (initializedInDom && allowanceChecker()("administrate user roles"))
                await ops.operation({
                    promise: roleAssignmentService.fetchPermissions(),
                    setOp: op => state.writable.permissionsOp = op,
                });
        }
        async function initialize() {
            initializedInDom = true;
            await loadPermissions();
        }
        return {
            state: state.readable,
            subscribe: state.subscribe,
            getAccess,
            initialize,
            get isAllowed() {
                return allowanceChecker();
            },
            reauthorize,
            searchUsers: roleAssignmentService.searchUsers,
            assignRoleToUser: roleAssignmentService.assignRoleToUser,
            revokeRoleFromUser: roleAssignmentService.revokeRoleFromUser,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                loadPermissions();
            },
        };
    }

    function makePermissionsModel({ permissionsService, reauthorize, }) {
        const { readable, writable, subscribe, track } = snapstate({
            active: false,
            accessOp: ops.none(),
            permissionsDisplay: ops.none(),
        });
        function getAccess() {
            return ops.value(readable.accessOp);
        }
        function sortPermissions(permissions) {
            const softPrivileges = [];
            const hardPrivileges = [];
            for (const privilege of permissions.privileges) {
                if (privilege.hard)
                    hardPrivileges.push(privilege);
                else
                    softPrivileges.push(privilege);
            }
            softPrivileges.sort((a, b) => b.time - a.time);
            return {
                ...permissions,
                privileges: [...softPrivileges, ...hardPrivileges],
            };
        }
        async function reload() {
            await ops.operation({
                promise: Promise.resolve()
                    .then(async () => getUserCanCustomizePermissions()
                    ? permissionsService.fetchPermissions().then(sortPermissions)
                    : undefined),
                setOp: op => writable.permissionsDisplay = op,
            });
        }
        function getUserCanCustomizePermissions() {
            const access = getAccess();
            return access?.user
                ? access.permit.privileges.includes(appPermissions.privileges["customize permissions"])
                : false;
        }
        async function initialize() {
            writable.active = true;
            if (getUserCanCustomizePermissions())
                await reload();
        }
        function reloadAfter(func) {
            return (async (...args) => {
                const result = await func(...args);
                await reload();
                await reauthorize();
                return result;
            });
        }
        return {
            readable,
            subscribe,
            track,
            getAccess,
            initialize,
            getUserCanCustomizePermissions,
            createRole: reloadAfter(permissionsService.createRole),
            deleteRole: reloadAfter(permissionsService.deleteRole),
            assignPrivilege: reloadAfter(permissionsService.assignPrivilege),
            unassignPrivilege: reloadAfter(permissionsService.unassignPrivilege),
            deletePrivilege: reloadAfter(permissionsService.deletePrivilege),
            createPrivilege: reloadAfter(permissionsService.createPrivilege),
            async updateAccessOp(op) {
                writable.accessOp = op;
                const access = getAccess();
                if (access?.user && writable.active)
                    await reload();
            },
        };
    }

    async function assembleModels({ appId, remote, popups, storage, authMediator, chatConnect, }) {
        const accessModel = makeAccessModel({
            authMediator,
            loginService: remote.auth.users.loginService,
        });
        const { getAccessOp, getAccess, getValidAccess, reauthorize } = accessModel;
        const exampleModel = makeExampleModel({ getAccessOp });
        const personalModel = makePersonalModel({
            personalService: remote.auth.users.personalService,
            getAccessOp,
            reauthorize,
        });
        const appsModel = makeAppsModel({
            appService: remote.auth.apps.appService,
            appEditService: remote.auth.apps.appEditService,
            getValidAccess,
        });
        const permissionsModel = makePermissionsModel({
            permissionsService: remote.auth.permissions.permissionsService,
            reauthorize,
        });
        const videoModels = makeVideoModels({
            dacastService: remote.videos.dacastService,
            contentService: remote.videos.contentService,
        });
        const chatModel = makeChatModel({
            chatConnect,
            getChatMeta: async () => ({
                accessToken: await authMediator.getValidAccessToken(),
            }),
        });
        const notesModel = makeNotesModel({
            notesService: remote.notes.notesService,
        });
        // // TODO reactivate store
        // const storeModel = makeStoreModel({
        // 	appId,
        // 	storage,
        // 	shopkeepingService: remote.store.shopkeepingService,
        // 	stripeAccountsService: remote.store.stripeConnectService,
        // 	statusCheckerService: remote.store.ecommerce.statusCheckerService,
        // 	statusTogglerService: remote.store.ecommerce.statusTogglerService,
        // 	triggerBankPopup: popups.triggerBankPopup,
        // })
        const administrativeModel = makeAdministrativeModel({
            roleAssignmentService: remote.administrative.roleAssignmentService,
            reauthorize: () => accessModel.reauthorize(),
        });
        const questionsModel = makeQuestionsModel({
            ...remote.questions,
            getAccess: getAccessOp,
        });
        accessModel.subscribe(async ({ accessOp }) => {
            const access = getAccess();
            await Promise.all([
                exampleModel.updateAccessOp(accessOp),
                personalModel.updateAccessOp(accessOp),
                appsModel.updateAccessOp(accessOp),
                permissionsModel.updateAccessOp(accessOp),
                questionsModel.accessChange(access),
                administrativeModel.updateAccessOp(accessOp),
                videoModels.dacastModel.updateAccessOp(accessOp),
                videoModels.contentModel.updateAccessOp(accessOp),
                chatModel.updateAccessOp(accessOp),
                notesModel.updateAccessOp(accessOp),
                // storeModel.accessChange(access),
            ]);
        });
        return {
            exampleModel,
            appsModel,
            chatModel,
            accessModel,
            videoModels,
            notesModel,
            // storeModel,
            personalModel,
            questionsModel,
            permissionsModel,
            administrativeModel,
        };
    }

    function mockModalSystem() {
        const nextModalResults = {
            confirm: true,
            prompt: undefined,
        };
        const modals = {
            popup() {
                return {
                    controls: {
                        close() { },
                        rerender() { },
                    },
                    modal: {},
                };
            },
            async alert() { },
            async confirm() {
                return nextModalResults.confirm;
            },
            async prompt() {
                return nextModalResults.prompt;
            },
        };
        return {
            modals,
            nextModalResults,
        };
    }

    function memoryFlexStorage() {
        const map = new Map();
        return {
            async read(key) {
                return map.get(key);
            },
            async write(key, data) {
                map.set(key, data);
            },
            async delete(key) {
                map.delete(key);
            },
        };
    }

    function chatMockClient(serverCore) {
        return async function chatConnect({ clientsideApi, handleDisconnect }) {
            const clientside = mock()
                .forApi(clientsideApi)
                .withMetaMap({ chatClient: async () => { } });
            const { api, disconnect } = serverCore.acceptNewClient({
                controls: {
                    ping() { },
                    close() { },
                },
                clientside,
                handleDisconnect: () => { },
            });
            return {
                serverside: mock()
                    .forApi(api)
                    .withMetaMap({ chatServer: async () => { } }),
                disconnect() {
                    disconnect();
                    handleDisconnect();
                },
            };
        };
    }

    function validator$1(...conditions) {
        return value => {
            let problems = [];
            for (const condition of conditions) {
                problems = condition(value);
                if (problems.length > 0)
                    break;
            }
            return problems;
        };
    }
    function schema(schematic) {
        const schematicKeys = Object.keys(schematic);
        return object => (Object.entries(object).flatMap(([key, value]) => schematicKeys.includes(key)
            ? schematic[key](value)
                .map(problem => `"${key}": ${problem}`)
            : [`"${key} not in schema"`]));
    }
    function branch(...conditions) {
        return value => {
            const results = conditions.map(condition => condition(value));
            let anySuccess = false;
            for (const problems of results)
                if (problems.length === 0)
                    anySuccess = true;
            return anySuccess
                ? []
                : results.flat()
                    .map((problem, index) => index > 0 ? `or, ${problem}` : problem);
        };
    }
    function each(...conditions) {
        return arr => {
            if (!Array.isArray(arr))
                return ["must be array"];
            const validate = validator$1(...conditions);
            const problems = [];
            arr.forEach((item, index) => {
                for (const problem of validate(item))
                    problems.push(`(${index + 1}) ${problem}`);
            });
            return problems;
        };
    }
    const notDefined = () => value => (value !== undefined && value !== null)
        ? ["must be undefined or null"]
        : [];
    const string = () => value => typeof value !== "string"
        ? ["must be a string"]
        : [];
    const number = () => value => typeof value !== "number"
        ? ["must be a number"]
        : [];
    const boolean = () => value => typeof value !== "boolean"
        ? ["must be a boolean"]
        : [];
    const min = (threshold) => value => value < threshold
        ? ["too small"]
        : [];
    const max = (threshold) => value => value > threshold
        ? ["too big"]
        : [];
    const array = () => value => Array.isArray(value)
        ? []
        : ["must be an array"];
    const length = (len) => value => value.length !== len
        ? [`length must be ${len}`]
        : [];
    const minLength = (min) => value => value.length < min
        ? ["too small"]
        : [];
    const maxLength = (max) => value => value.length > max
        ? ["too big"]
        : [];
    const notWhitespace = () => value => value.length > 0 && value.trim().length === 0
        ? ["can't be all whitespace"]
        : [];
    const zeroWhitespace = () => value => /\s/.test(value)
        ? ["must not have any spaces"]
        : [];
    const url = () => value => {
        try {
            void new URL(value);
            return [];
        }
        catch (error) {
            return ["invalid url"];
        }
    };
    const localhost = () => value => {
        return /^https?:\/\/(127\.0\.0\.1|localhost)(|:\d{1,5})(|\/\S*)$/i.test(value)
            ? []
            : ["must be a localhost address"];
    };
    const https = () => value => {
        return /^https:\/\//i.test(value)
            ? []
            : ["must be secure, starting with 'https'"];
    };
    const origin = () => value => /^https?:\/\/[a-zA-Z\.\d-]+(?:|:\d+)$/i.test(value)
        ? []
        : ["invalid origin"];
    const regex = (r, problem = "invalid string") => value => r.test(value)
        ? []
        : [problem];
    const emailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    const email = () => value => emailRegex.test(value)
        ? []
        : ["invalid email"];
    // const labelValidator = validator<string>(string(), minLength(1), maxLength(50), notWhitespace())
    // const problems = labelValidator("hello")
    // const problems2 = validator<string[]>(array(string()))

    const validateId = validator$1(string(), length(64), regex(/^[0-9a-z]{64}$/));

    const validateChatRoom = validator$1(string(), minLength(1), maxLength(32), zeroWhitespace());
    const validateChatContent = validator$1(string(), minLength(1), maxLength(280), notWhitespace());
    const validateChatDraft = schema({
        content: validateChatContent,
    });
    const validateIdArray = validator$1(array(), each(validateId));
    const validateChatStatus = validator$1(number(), min(0), max(1));

    const makeChatServerside = ({ rando, rateLimiter, clientRecord, persistence, policy, }) => api({
        chatServer: service()
            .policy(async (meta, headers) => {
            const appId = clientRecord.auth?.access.appId;
            const persistenceActions = appId
                ? persistence.namespaceForApp(appId)
                : undefined;
            return { persistenceActions, headers };
        })
            .expose(({ persistenceActions, headers }) => {
            const { clientside: { chatClient } } = clientRecord;
            const getAllowance = () => chatAllowance(clientRecord.auth?.access.permit.privileges ?? []);
            const isNotMuted = () => !persistenceActions.isMuted(clientRecord.auth?.access.user?.userId);
            const isNotBanned = () => !getAllowance().banned;
            function enforceValidation(problems) {
                if (problems.length !== 0)
                    throw new Error("chat validation error");
            }
            return {
                async updateUserMeta(meta) {
                    clientRecord.auth = await policy(meta, headers);
                },
                async roomSubscribe(room) {
                    enforceValidation(validateChatRoom(room));
                    if (!getAllowance().viewAllChats)
                        return undefined;
                    clientRecord.rooms.add(room);
                    chatClient.roomStatusChanged(room, await persistenceActions.getRoomStatus(room));
                    chatClient.postsAdded(room, await persistenceActions.fetchRecentPosts(room));
                    chatClient.usersMuted((await persistenceActions.fetchMutes())
                        .map(({ userId }) => userId));
                },
                async roomUnsubscribe(room) {
                    enforceValidation(validateChatRoom(room));
                    if (!getAllowance().viewAllChats)
                        return undefined;
                    clientRecord.rooms.delete(room);
                },
                async post(room, draft) {
                    if (rateLimiter.tooMany())
                        return undefined;
                    enforceValidation(schema({
                        room: validateChatRoom,
                        draft: validateChatDraft,
                    })({ room, draft }));
                    if (!getAllowance().participateInAllChats)
                        return undefined;
                    if (isNotMuted() && isNotBanned()) {
                        const post = {
                            ...draft,
                            room,
                            time: Date.now(),
                            postId: rando.randomId().toString(),
                            userId: clientRecord.auth.access.user.userId,
                            nickname: clientRecord.auth.access.user.profile.nickname,
                        };
                        await persistenceActions.addPosts(room, [post]);
                    }
                },
                async remove(room, postIds) {
                    enforceValidation(schema({
                        room: validateChatRoom,
                        postIds: validateIdArray,
                    })({ room, postIds }));
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.removePosts(room, postIds);
                },
                async clear(room) {
                    enforceValidation(validateChatRoom(room));
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.clearRoom(room);
                },
                async mute(userIds) {
                    enforceValidation(validateIdArray(userIds));
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.addMute(userIds);
                },
                async unmute(userIds) {
                    enforceValidation(validateIdArray(userIds));
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.removeMute(userIds);
                },
                async unmuteAll() {
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.unmuteAll();
                },
                async setRoomStatus(room, status) {
                    enforceValidation(schema({
                        room: validateChatRoom,
                        status: validateChatStatus,
                    })({ room, status }));
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.setRoomStatus(room, status);
                },
            };
        }),
    });

    var __classPrivateFieldSet$c = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$g = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Bucket_maximum, _Bucket_storage;
    class Bucket {
        constructor({ maximum }) {
            _Bucket_maximum.set(this, void 0);
            _Bucket_storage.set(this, []);
            __classPrivateFieldSet$c(this, _Bucket_maximum, maximum, "f");
        }
        add(item) {
            __classPrivateFieldGet$g(this, _Bucket_storage, "f").push(item);
            if (__classPrivateFieldGet$g(this, _Bucket_storage, "f").length > __classPrivateFieldGet$g(this, _Bucket_maximum, "f"))
                __classPrivateFieldSet$c(this, _Bucket_storage, __classPrivateFieldGet$g(this, _Bucket_storage, "f").slice(-__classPrivateFieldGet$g(this, _Bucket_maximum, "f")), "f");
        }
        read() {
            return [...__classPrivateFieldGet$g(this, _Bucket_storage, "f")];
        }
    }
    _Bucket_maximum = new WeakMap(), _Bucket_storage = new WeakMap();

    var __classPrivateFieldSet$b = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$f = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _RateLimiter_timeframe, _RateLimiter_maximum, _RateLimiter_bucket;
    class RateLimiter {
        constructor({ timeframe, maximum }) {
            _RateLimiter_timeframe.set(this, void 0);
            _RateLimiter_maximum.set(this, void 0);
            _RateLimiter_bucket.set(this, void 0);
            __classPrivateFieldSet$b(this, _RateLimiter_timeframe, timeframe, "f");
            __classPrivateFieldSet$b(this, _RateLimiter_maximum, maximum, "f");
            __classPrivateFieldSet$b(this, _RateLimiter_bucket, new Bucket({ maximum }), "f");
        }
        hit() {
            const now = Date.now();
            const old = now - __classPrivateFieldGet$f(this, _RateLimiter_timeframe, "f");
            const hitsWithinTimeframe = __classPrivateFieldGet$f(this, _RateLimiter_bucket, "f").read().filter(time => time > old);
            if (hitsWithinTimeframe.length < __classPrivateFieldGet$f(this, _RateLimiter_maximum, "f")) {
                __classPrivateFieldGet$f(this, _RateLimiter_bucket, "f").add(now);
                return true;
            }
            else {
                return false;
            }
        }
        tooMany() {
            return !this.hit();
        }
    }
    _RateLimiter_timeframe = new WeakMap(), _RateLimiter_maximum = new WeakMap(), _RateLimiter_bucket = new WeakMap();

    const pingInterval = 10 * 1000;
    function makeChatServerCore({ rando, persistence, policy, }) {
        const clientRecords = new Set();
        async function broadcastToAll(appId, action) {
            for (const record of clientRecords.values())
                if (record.auth && record.auth.access.appId === appId)
                    action(record, chatAllowance(record.auth.access.permit.privileges));
        }
        async function broadcastToRoom(appId, room, action) {
            for (const record of clientRecords.values())
                if (record.auth && record.auth.access.appId === appId && record.rooms.has(room))
                    action(record, chatAllowance(record.auth.access.permit.privileges));
        }
        persistence.events.roomStatusChanged(({ appId, room, status }) => {
            broadcastToRoom(appId, room, record => record.clientside.chatClient.roomStatusChanged(room, status));
        });
        persistence.events.postsAdded(({ appId, room, posts }) => {
            broadcastToRoom(appId, room, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.postsAdded(room, posts);
            });
        });
        persistence.events.postsRemoved(({ appId, room, postIds }) => {
            broadcastToRoom(appId, room, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.postsRemoved(room, postIds);
            });
        });
        persistence.events.mutes(({ appId, userIds }) => {
            broadcastToAll(appId, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.usersMuted(userIds);
            });
        });
        persistence.events.unmutes(({ appId, userIds }) => {
            broadcastToAll(appId, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.usersUnmuted(userIds);
            });
        });
        persistence.events.unmuteAll(({ appId }) => {
            broadcastToAll(appId, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.unmuteAll();
            });
        });
        persistence.events.roomCleared(({ appId, room }) => {
            broadcastToRoom(appId, room, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.roomCleared(room);
            });
        });
        function acceptNewClient({ controls, clientside, handleDisconnect }) {
            const clientRecord = {
                auth: undefined,
                rooms: new Set(),
                clientside,
                controls,
            };
            clientRecords.add(clientRecord);
            const rateLimiter = new RateLimiter({
                timeframe: chatRateLimitingInterval,
                maximum: chatRateLimitingInterval / chatPostCoolOff,
            });
            const interval = setInterval(controls.ping, pingInterval);
            return {
                api: makeChatServerside({
                    rando,
                    rateLimiter,
                    persistence,
                    clientRecord,
                    policy,
                }),
                disconnect() {
                    clearInterval(interval);
                    handleDisconnect();
                    clientRecords.delete(clientRecord);
                },
            };
        }
        return {
            acceptNewClient,
            get clientCount() { return clientRecords.size; },
        };
    }

    const tokenize = (object) => (url$1.encode(JSON.stringify(object)));
    function mockSignToken() {
        return async ({ payload, lifespan, }) => {
            const data = {
                payload,
                iat: Date.now() / 1000,
                exp: (Date.now() + lifespan) / 1000,
            };
            const header = {
                alg: null,
                typ: "JWT",
            };
            const signature = "fake-mock-token-signature";
            return [
                tokenize(header),
                tokenize(data),
                tokenize(signature),
            ].join(".");
        };
    }

    const mockVerifyToken = () => async (token) => {
        const decoded = tokenDecode(token);
        const expiry = decoded.data.exp * 1000;
        if (Date.now() > expiry)
            throw new Error("token expired");
        return decoded.data.payload;
    };

    const verifyToken = mockVerifyToken();
    async function mockChatPolicy({ accessToken }) {
        return { access: await verifyToken(accessToken) };
    }

    function objectMap(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }
    function objectMap2(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }

    var __classPrivateFieldSet$a = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$e = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _AssertiveMap_makeValue;
    class AssertiveMap extends Map {
        constructor(makeValue, entries) {
            super(entries);
            _AssertiveMap_makeValue.set(this, void 0);
            __classPrivateFieldSet$a(this, _AssertiveMap_makeValue, makeValue, "f");
        }
        assert(key) {
            if (this.has(key)) {
                return this.get(key);
            }
            else {
                const value = __classPrivateFieldGet$e(this, _AssertiveMap_makeValue, "f").call(this, key);
                this.set(key, value);
                return value;
            }
        }
    }
    _AssertiveMap_makeValue = new WeakMap();

    const _dbbyTableSymbol = Symbol("dbbyTable");

    function and(...conditions) {
        return ["and", ...conditions];
    }
    function or(...conditions) {
        return ["or", ...conditions];
    }
    function find(...rows) {
        return rows.length
            ? { conditions: or(...rows.map(row => ({ equal: row }))) }
            : { conditions: false };
    }
    function findAll(values, valueForRow) {
        return { conditions: or(...values.map(v => ({ equal: valueForRow(v) }))) };
    }
    function isDbbyTable(x) {
        return x && typeof x === "object" && x[_dbbyTableSymbol];
    }

    async function dbbyX(flexStorage, tableName) {
        const table = (() => {
            const serializationKey = "__serialized_type__";
            function copy(x) {
                if (x === undefined)
                    return undefined;
                return JSON.parse(JSON.stringify(x));
            }
            function serialize(table) {
                return table.map(row => {
                    const serializedRow = {};
                    for (const [key, value] of Object.entries(row)) {
                        if (value instanceof DamnId) {
                            serializedRow[key] = {
                                [serializationKey]: "DamnId",
                                serializedValue: value.toString(),
                            };
                        }
                        else
                            serializedRow[key] = copy(value);
                    }
                    return serializedRow;
                });
            }
            function deserialize(data) {
                return data.map(datum => {
                    const row = {};
                    for (const [key, value] of Object.entries(datum)) {
                        if (value && typeof value === "object" && value[serializationKey]) {
                            if (value[serializationKey] === "DamnId") {
                                row[key] = DamnId.fromString(value.serializedValue);
                            }
                            else
                                throw new Error(`dbby-x unknown serialization type "${value[serializationKey]}"`);
                        }
                        else {
                            row[key] = value;
                        }
                    }
                    return row;
                });
            }
            const storageKey = `dbby-${tableName}`;
            async function load() {
                return deserialize(await flexStorage.read(storageKey) ?? []);
            }
            async function save(rows) {
                await flexStorage.write(storageKey, serialize(rows));
            }
            return { load, save };
        })();
        const readers = (() => {
            async function select(conditional) {
                return (await table.load())
                    .filter(row => rowVersusConditional(row, conditional));
            }
            async function discriminate(conditional) {
                const yep = [];
                const nope = [];
                for (const row of await table.load()) {
                    if (rowVersusConditional(row, conditional))
                        yep.push(row);
                    else
                        nope.push(row);
                }
                return { yep, nope };
            }
            async function selectOne(conditional) {
                return (await table.load())
                    .find(row => rowVersusConditional(row, conditional));
            }
            return { select, selectOne, discriminate };
        })();
        const writers = (() => {
            async function applyPatchToRows(conditional, patch) {
                const { yep, nope } = await readers.discriminate(conditional);
                const updated = yep.map(row => ({ ...row, ...patch }));
                await table.save([...updated, ...nope]);
            }
            async function eliminateRow(conditional) {
                const flippedFilterRow = (row) => !rowVersusConditional(row, conditional);
                const rows = await table.load();
                await table.save(rows.filter(flippedFilterRow));
            }
            async function insert(...rows) {
                const old = await table.load();
                await table.save([...old, ...rows]);
            }
            return { applyPatchToRows, eliminateRow, insert };
        })();
        const sequential = (() => {
            let promiseChain = Promise.resolve();
            function functionQueuesInSequence(func) {
                return (async (...args) => {
                    const next = promiseChain.then(() => func(...args));
                    promiseChain = next.catch(() => { });
                    return next;
                });
            }
            function groupOfFunctionsQueueInSequence(obj) {
                const newObject = {};
                for (const [key, value] of Object.entries(obj)) {
                    newObject[key] = functionQueuesInSequence(value);
                }
                return newObject;
            }
            return { groupOfFunctionsQueueInSequence };
        })();
        return {
            [_dbbyTableSymbol]: true,
            ...sequential.groupOfFunctionsQueueInSequence({
                async create(...rows) {
                    await writers.insert(...rows);
                },
                async read({ order, offset = 0, limit = 1000, ...conditional }) {
                    const rows = await readers.select(conditional);
                    if (order) {
                        for (const [key, value] of Object.entries(order)) {
                            rows.sort((a, b) => value === "ascend"
                                ? a[key] > b[key] ? 1 : -1
                                : a[key] > b[key] ? -1 : 1);
                        }
                    }
                    return rows.slice(offset, offset + limit);
                },
                async one(conditional) {
                    return readers.selectOne(conditional);
                },
                async assert({ make, ...conditional }) {
                    let row = await readers.selectOne(conditional);
                    if (!row) {
                        const made = await make();
                        await writers.insert(made);
                        row = made;
                    }
                    return row;
                },
                async update({ write, whole, upsert, ...conditional }) {
                    const rows = await readers.select(conditional);
                    if (write && rows.length) {
                        await writers.applyPatchToRows(conditional, write);
                    }
                    else if (upsert) {
                        if (rows.length)
                            await writers.applyPatchToRows(conditional, upsert);
                        else
                            await writers.insert(upsert);
                    }
                    else if (whole) {
                        await writers.eliminateRow(conditional);
                        await writers.insert(whole);
                    }
                    else
                        throw new Error("invalid update");
                },
                async delete(conditional) {
                    await writers.eliminateRow(conditional);
                },
                async count(conditional) {
                    return (await readers.select(conditional)).length;
                },
            })
        };
    }
    function compare(row, conditional, evaluator) {
        let failures = 0;
        for (const [key, value] of Object.entries(conditional)) {
            if (!evaluator(row[key], value))
                failures += 1;
        }
        return !failures;
    }
    function rowVersusConditional(row, conditional) {
        function crawl(conditions) {
            if (conditions === false)
                return true;
            const [operation, ...rawconds] = conditions;
            const conds = rawconds.filter(c => !!c);
            if (conds.length === 0)
                throw new Error("empty and/or conditions are not allowed");
            const and = operation === "and";
            let valid = and;
            const applyResult = (result) => valid = and
                ? valid && result
                : valid || result;
            for (const condition of conds) {
                if (condition === false || Array.isArray(condition)) {
                    applyResult(crawl(condition));
                }
                else {
                    const result = rowVersusCondition(row, condition);
                    applyResult(result);
                }
            }
            return valid;
        }
        return crawl(conditional.conditions);
    }
    function rowVersusCondition(row, condition) {
        if (!Object.keys(condition).length)
            return true;
        let failures = 0;
        const check = (conditions, evaluator) => {
            if (conditions && !compare(row, conditions, evaluator))
                failures += 1;
        };
        const checks = {
            set: a => a !== undefined && a !== null,
            equal: (a, b) => a instanceof DamnId
                ? a.string === b.string
                : a === b,
            greater: (a, b) => a > b,
            greatery: (a, b) => a >= b,
            less: (a, b) => a < b,
            lessy: (a, b) => a <= b,
            listed: (a, b) => a.includes(b),
            search: (a, b) => typeof b === "string" ? a.includes(b) : b.test(a),
        };
        function not(evaluator) {
            return (a, b) => !evaluator(a, b);
        }
        check(condition.set, checks.set);
        check(condition.equal, checks.equal);
        check(condition.greater, checks.greater);
        check(condition.greatery, checks.greatery);
        check(condition.less, checks.less);
        check(condition.lessy, checks.lessy);
        check(condition.listed, checks.listed);
        check(condition.search, checks.search);
        check(condition.notSet, not(checks.set));
        check(condition.notEqual, not(checks.equal));
        check(condition.notGreater, not(checks.greater));
        check(condition.notGreatery, not(checks.greatery));
        check(condition.notLess, not(checks.less));
        check(condition.notLessy, not(checks.lessy));
        check(condition.notListed, not(checks.listed));
        check(condition.notSearch, not(checks.search));
        return !failures;
    }

    async function concurrent(obj) {
        const keys = Object.keys(obj);
        const awaitables = Object.values(obj);
        const values = await Promise.all(awaitables);
        const result = {};
        keys.forEach((key, i) => result[key] = values[i]);
        return result;
    }

    async function mockStorageTables(flexStorage, blueprint) {
        return await concurrent(objectMap(blueprint, async (value, key) => await dbbyX(flexStorage, key)));
    }

    const namespaceKeyAppId = "namespace-appId";

    function dbbyConstrain({ table, namespace, }) {
        const spike = (conditionTree) => (conditionTree
            ? and({ equal: namespace }, conditionTree)
            : and({ equal: namespace }));
        return {
            [_dbbyTableSymbol]: true,
            async create(...rows) {
                return table.create(...rows.map(row => ({ ...row, ...namespace })));
            },
            async read(options) {
                return table.read({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
            async one(options) {
                return table.one({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
            async assert(options) {
                return table.assert({
                    ...options,
                    conditions: spike(options.conditions),
                    make: async () => {
                        const row = await options.make();
                        return { ...row, ...namespace };
                    },
                });
            },
            async update(options) {
                const opts = options;
                return table.update({
                    ...options,
                    conditions: spike(options.conditions),
                    upsert: opts.upsert
                        ? { ...opts.upsert, ...namespace }
                        : undefined,
                    whole: opts.whole
                        ? { ...opts.whole, ...namespace }
                        : undefined,
                    write: opts.write
                        ? { ...opts.write, ...namespace }
                        : undefined,
                });
            },
            async delete(options) {
                return table.delete({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
            async count(options) {
                return table.count({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
        };
    }
    function dbbyConstrainTables({ namespace, tables, }) {
        return objectMap(tables, value => {
            return isDbbyTable(value)
                ? dbbyConstrain({ namespace, table: value })
                : dbbyConstrainTables({ namespace, tables: value });
        });
    }

    class UnconstrainedTables {
        constructor(tables) {
            this.tables = tables;
        }
        get unconstrained() {
            return this.tables;
        }
        namespaceForApp(appId) {
            return dbbyConstrainTables({
                tables: this.tables,
                namespace: { [namespaceKeyAppId]: appId },
            });
        }
    }
    // export type UnconstrainedTables<xTables extends DbbyTables> = (
    // 	DbbyUnconstrainTables<AppNamespaceRow, xTables>
    // )
    // export type ConstrainedTables<xTables extends DbbyTables> = (
    // 	DbbyConstrainTables<AppNamespaceRow, xTables>
    // )
    // export type SafelyConstrainedTable<xTable extends DbbyTable<DbbyRow>> = (
    // 	xTable extends DbbyTable<infer xRow>
    // 		? xRow extends AppNamespaceRow
    // 			? never
    // 			: DbbyTable<xRow>
    // 		: never
    // )
    // export type SafelyConstrainedTables<xTables extends DbbyTables> = {
    // 	[P in keyof xTables]: xTables[P] extends SafelyConstrainedTable<DbbyTable<DbbyRow>>
    // 		? xTables[P] extends DbbyTables
    // 			? SafelyConstrainedTables<xTables[P]>
    // 			: never
    // 		: never
    // }
    // type LolTable = DbbyTable<{a: number}>
    // type LolUnconstrained = DbbyUnconstrainTable<AppNamespaceRow, LolTable>
    // type LolConstrained = DbbyConstrainTable<AppNamespaceRow, LolTable>
    // let unconstrainedTable: LolUnconstrained
    // let constrainedTable: LolConstrained
    // let T: SafelyConstrainedTable<LolUnconstrained>
    // unconstrainedTable.create({a: 1, "appId-namespace": DamnId.fromString("")})
    // constrainedTable.create({a: 1})
    // function test(table: SafelyConstrainedTable<LolUnconstrained>) {}
    // test(unconstrainedTable)
    // type DisallowB<Stuff> = 
    // function userQuery(stuff: ) {}

    async function mockChatPersistence(storage) {
        const chatTablesUnconstrained = new UnconstrainedTables(await mockStorageTables(storage, {
            posts: true,
            mutes: true,
            roomStatuses: true,
        }));
        const events = {
            roomStatusChanged: subbies(),
            postsAdded: subbies(),
            postsRemoved: subbies(),
            roomCleared: subbies(),
            mutes: subbies(),
            unmutes: subbies(),
            unmuteAll: subbies(),
        };
        const eventSubscribers = objectMap(events, (event) => event.subscribe);
        const getAppCache = (() => {
            const appCaches = new AssertiveMap(() => ({
                mutedUserIds: new Set()
            }));
            return (appId) => appCaches.assert(appId);
        })();
        // listen to events to update cache
        {
            eventSubscribers.mutes(({ appId, userIds }) => {
                const cache = getAppCache(appId);
                for (const userId of userIds)
                    cache.mutedUserIds.add(userId);
            });
            eventSubscribers.unmutes(({ appId, userIds }) => {
                const cache = getAppCache(appId);
                for (const userId of userIds)
                    cache.mutedUserIds.delete(userId);
            });
            eventSubscribers.unmuteAll(({ appId }) => {
                const cache = getAppCache(appId);
                cache.mutedUserIds.clear();
            });
        }
        function namespaceForApp(appId) {
            const appCache = getAppCache(appId);
            const chatTables = chatTablesUnconstrained
                .namespaceForApp(DamnId.fromString(appId));
            return {
                isMuted(userId) {
                    return appCache.mutedUserIds.has(userId);
                },
                async addPosts(room, posts) {
                    await chatTables.posts.create(...posts.map(post => ({
                        room: post.room,
                        time: post.time,
                        content: post.content,
                        nickname: post.nickname,
                        userId: DamnId.fromString(post.userId),
                        postId: DamnId.fromString(post.postId),
                    })));
                    events.postsAdded.publish({ appId, room, posts });
                },
                async removePosts(room, postIds) {
                    if (postIds.length) {
                        await chatTables.posts.delete(findAll(postIds, postId => ({
                            room,
                            postId: DamnId.fromString(postId)
                        })));
                        events.postsRemoved.publish({ appId, room, postIds });
                    }
                },
                async fetchRecentPosts(room) {
                    const rawPosts = await chatTables.posts.read({
                        ...find({ room }),
                        limit: maximumNumberOfPostsShownAtOnce,
                        order: { time: "descend" },
                    });
                    const recentPosts = rawPosts.map(post => ({
                        room: post.room,
                        time: post.time,
                        content: post.content,
                        nickname: post.nickname,
                        postId: post.postId.toString(),
                        userId: post.userId.toString(),
                    }));
                    const postsSortedByTime = recentPosts.sort((a, b) => a.time - b.time);
                    return postsSortedByTime;
                },
                async fetchMutes() {
                    const rows = await chatTables.mutes.read({ conditions: false });
                    return rows.map(row => ({ userId: row.userId.toString() }));
                },
                async clearRoom(room) {
                    await chatTables.posts.delete(find({ room }));
                    events.roomCleared.publish({ appId, room });
                },
                async addMute(userIds) {
                    if (userIds.length) {
                        const existingMutes = await chatTables.mutes.read(findAll(userIds, userId => ({
                            userId: DamnId.fromString(userId),
                        })));
                        const userIdsAlreadyMuted = existingMutes.map(row => row.userId.toString());
                        const userIdsToBeMuted = userIds.filter(userId => !userIdsAlreadyMuted.includes(userId));
                        const newMutes = userIdsToBeMuted.map(userId => ({
                            userId: DamnId.fromString(userId)
                        }));
                        await chatTables.mutes.create(...newMutes);
                        events.mutes.publish({ appId, userIds: userIdsToBeMuted });
                    }
                },
                async removeMute(userIds) {
                    if (userIds.length) {
                        await chatTables.mutes.delete(findAll(userIds, userId => ({ userId: DamnId.fromString(userId) })));
                        events.unmutes.publish({ appId, userIds });
                    }
                },
                async unmuteAll() {
                    await chatTables.mutes.delete({ conditions: false });
                    events.unmuteAll.publish({ appId });
                },
                async setRoomStatus(room, status) {
                    await chatTables.roomStatuses.update({
                        ...find({ room }),
                        upsert: { room, status },
                    });
                    events.roomStatusChanged.publish({ appId, room, status });
                },
                async getRoomStatus(room) {
                    const row = await chatTables.roomStatuses.one(find({ room }));
                    return row
                        ? row.status
                        : ChatStatus.Offline;
                },
            };
        }
        return {
            events: eventSubscribers,
            namespaceForApp,
        };
    }

    async function chatMockClientEntirely(storage) {
        const serverCore = makeChatServerCore({
            rando: await getRando(),
            persistence: await mockChatPersistence(storage),
            policy: mockChatPolicy,
        });
        return chatMockClient(serverCore);
    }

    async function mockBrowser({ api, appOrigin, mockStripeOperations }) {
        async function mockAppWindow({ appId }) {
            const storage = memoryFlexStorage();
            const { remote, authMediator } = mockRemote({
                api,
                appId,
                storage,
                logging: false,
                headers: { origin: appOrigin },
            });
            const { nextModalResults } = mockModalSystem();
            const models = await assembleModels({
                appId,
                remote,
                storage,
                authMediator,
                popups: mockPopups({ mockStripeOperations }),
                chatConnect: await chatMockClientEntirely(storage),
            });
            return { models, remote, nextModalResults };
        }
        return { mockAppWindow };
    }

    function isPlatform(appId, config) {
        return config.platform.appDetails.appId === appId;
    }

    const validateAppOrigin = validator$1(string(), maxLength(1000), origin(), branch(https(), localhost()));
    const appDraftValidators = Object.freeze({
        home: validator$1(string(), minLength(1), maxLength(2000), branch(validator$1(url(), https()), localhost())),
        label: validator$1(string(), minLength(1), maxLength(50), notWhitespace()),
        origins: validator$1(minLength(1), maxLength(100), each(validateAppOrigin)),
        additionalOrigins: validator$1(array(), minLength(0), maxLength(99), each(validateAppOrigin)),
    });

    const validator = schema({
        home: appDraftValidators.home,
        label: appDraftValidators.label,
        origins: appDraftValidators.origins,
    });
    function validateAppDraft(appDraft) {
        return validator(appDraft);
    }

    function originsToDatabase(origins) {
        return origins.join(";");
    }

    function originsFromDatabase(origins) {
        return origins.split(";");
    }

    function throwProblems(problems) {
        if (problems.length > 0)
            throw new ApiError(400, problems.join("; "));
    }

    const makeAppService = ({ rando, config, authPolicies, }) => service()
        .policy(authPolicies.platformUserPolicy)
        .expose(({ appTables, statsHub }) => ({
        async listApps({ ownerUserId: ownerUserIdString }) {
            const ownerUserId = DamnId.fromString(ownerUserIdString);
            const ownerships = await appTables.owners.read(find({ userId: ownerUserId }));
            const appRows = ownerships.length
                ? await appTables.registrations.read({
                    conditions: and(or(...ownerships.map(own => ({ equal: { appId: own.appId } }))), { equal: { archived: false } })
                })
                : [];
            return Promise.all(appRows.map(async (row) => ({
                appId: row.appId.toString(),
                label: row.label,
                home: row.home,
                origins: originsFromDatabase(row.origins),
                platform: isPlatform(row.appId.toString(), config),
                stats: await concurrent({
                    users: statsHub.countUsers(row.appId),
                    usersActiveDaily: statsHub.countUsersActiveDaily(row.appId),
                    usersActiveMonthly: statsHub.countUsersActiveMonthly(row.appId),
                }),
            })));
        },
        async registerApp({ appDraft, ownerUserId: ownerUserIdString }) {
            throwProblems(validateAppDraft(appDraft));
            const ownerUserId = DamnId.fromString(ownerUserIdString);
            const appId = rando.randomId();
            await Promise.all([
                appTables.registrations.create({
                    appId,
                    label: appDraft.label,
                    home: appDraft.home,
                    origins: originsToDatabase(appDraft.origins),
                    archived: false,
                }),
                appTables.owners.create({
                    appId,
                    userId: ownerUserId,
                }),
            ]);
            return {
                ...appDraft,
                appId: appId.toString(),
                stats: {
                    users: 1,
                    usersActiveDaily: 0,
                    usersActiveMonthly: 0,
                },
            };
        },
    }));

    const profileFromRow = ({ avatar, tagline, nickname, }) => ({
        tagline,
        nickname,
        avatar: JSON.parse(avatar),
    });

    async function fetchUsers({ userIds, authTables, permissionsEngine }) {
        if (!userIds.length)
            throw new Error("invalid: userIds cannot be empty");
        const conditions = or(...userIds.map(userId => ({ equal: { userId } })));
        const accounts = await authTables.users.accounts.read({ conditions });
        const profiles = await authTables.users.profiles.read({ conditions });
        const publicRolesForUsers = await permissionsEngine
            .getPublicRolesForUsers(userIds.map(id => id.toString()));
        function assembleDetailsForEachUser(userId) {
            const account = accounts.find(a => a.userId.toString() === userId.toString());
            const profile = profiles.find(p => p.userId.toString() === userId.toString());
            if (!account)
                throw new ApiError(404, `account not found for user id ${userId}`);
            if (!profile)
                throw new ApiError(404, `profile not found for user id ${userId}`);
            const roles = publicRolesForUsers
                .find(r => r.userId.toString() === userId.toString())
                .publicUserRoles;
            const stats = {
                joined: account.created,
            };
            return {
                userId: userId.toString(),
                profile: profileFromRow(profile),
                roles,
                stats,
            };
        }
        return userIds.map(assembleDetailsForEachUser);
    }

    async function fetchUser({ userId, ...options }) {
        const results = await fetchUsers({ ...options, userIds: [userId] });
        return results.find(r => r.userId);
    }

    function permissionsMergingFacility({ isPlatform }) {
        const hardPermissions = isPlatform
            ? platformPermissions
            : appPermissions;
        function getHardPrivilegeDetails(...roleIds) {
            const results = [];
            for (const roleId of roleIds) {
                const found = Object.entries(hardPermissions.roles)
                    .find(([, role2]) => role2.roleId === roleId);
                if (found) {
                    const [, role] = found;
                    for (const [label, has] of Object.entries(role.hasPrivileges)) {
                        const privilegeId = hardPermissions.privileges[label];
                        const already = results.find(detail => detail.roleId === roleId &&
                            detail.privilegeId === privilegeId);
                        if (!already) {
                            results.push({
                                privilegeId,
                                roleId,
                                active: has.active,
                                immutable: has.immutable,
                            });
                        }
                    }
                }
            }
            return results;
        }
        function mergeRoleHasPrivileges({ hard, soft }) {
            const results = [];
            function rowMatch(hardy, softy) {
                return hardy.roleId === softy.roleId.toString()
                    && hardy.privilegeId === softy.privilegeId.toString();
            }
            function toSofty(hardy) {
                return {
                    roleId: DamnId.fromString(hardy.roleId),
                    privilegeId: DamnId.fromString(hardy.privilegeId),
                    active: hardy.active,
                    immutable: hardy.immutable,
                    time: 0,
                };
            }
            for (const softy of soft) {
                const hardy = hard.find(h => rowMatch(h, softy));
                results.push(hardy && hardy.immutable
                    ? toSofty(hardy)
                    : softy);
            }
            for (const hardy of hard) {
                const alreadyIncluded = !!results.find(softy => rowMatch(hardy, softy));
                if (!alreadyIncluded)
                    results.push(toSofty(hardy));
            }
            return results;
        }
        function getActivePrivilegeIds(roleHasPrivileges) {
            return roleHasPrivileges
                .filter(row => row.active)
                .map(row => row.privilegeId);
        }
        return {
            hardPermissions,
            mergeRoleHasPrivileges,
            getActivePrivilegeIds,
            getHardPrivilegeDetails,
        };
    }

    function isDefined(x) {
        return x !== undefined && x !== null;
    }

    function isCurrentlyWithinTimeframe({ timeframeStart, timeframeEnd }) {
        const time = Date.now();
        const tooEarly = isDefined(timeframeStart)
            ? time > timeframeStart
            : false;
        const tooLate = isDefined(timeframeEnd)
            ? time < timeframeEnd
            : false;
        return !tooEarly && !tooLate;
    }

    function makePermissionsEngine({ isPlatform, permissionsTables }) {
        const { hardPermissions, mergeRoleHasPrivileges, getActivePrivilegeIds, getHardPrivilegeDetails, } = permissionsMergingFacility({ isPlatform });
        async function getAnonymousPrivileges() {
            const roleId = hardPermissions.roles.everybody.roleId;
            const hard = getHardPrivilegeDetails(roleId);
            const soft = await permissionsTables.roleHasPrivilege
                .read(find({ roleId: DamnId.fromString(roleId) }));
            return getActivePrivilegeIds(mergeRoleHasPrivileges({ hard, soft }))
                .map(id => id.toString());
        }
        async function getUsersHaveRoles({ userIds, onlyGetPublicRoles }) {
            const isPublic = (row) => row.public;
            const all = (x) => x;
            const usersHaveRoles = await (async () => {
                if (userIds.length === 0)
                    throw new Error("invalid: user ids cannot be empty");
                const usersHaveRolesRaw = await permissionsTables.userHasRole.read({
                    conditions: or(...userIds.map(userId => ({
                        equal: { userId: DamnId.fromString(userId) }
                    }))),
                });
                const roleIds = usersHaveRolesRaw.map(u => u.roleId);
                const roles = roleIds.length
                    ? await permissionsTables.role.read({
                        conditions: or(...roleIds.map(roleId => ({ equal: { roleId } })))
                    })
                    : [];
                const roleIdsThatActuallyExist = [
                    ...roles.map(r => r.roleId.toString()),
                    ...Object.entries(hardPermissions.roles)
                        .map(([, role]) => role.roleId),
                ];
                return usersHaveRolesRaw
                    .filter(u => roleIdsThatActuallyExist.includes(u.roleId.toString()));
            })();
            return userIds.map(userId => {
                const raw = usersHaveRoles.filter(r => r.userId.toString() === userId);
                const userHasRoles = raw
                    .filter(isCurrentlyWithinTimeframe)
                    .filter(onlyGetPublicRoles ? isPublic : all);
                return { userId, userHasRoles };
            });
        }
        async function getPrivilegesForUsers(userIds) {
            const rolesForUsers = await getUsersHaveRoles({
                userIds,
                onlyGetPublicRoles: false,
            });
            const allRoleIds = rolesForUsers
                .flatMap(r => r.userHasRoles.map(r2 => r2.roleId));
            const allRolesHavePrivileges = allRoleIds.length
                ? await permissionsTables.roleHasPrivilege.read({
                    conditions: or(...allRoleIds.map(roleId => ({ equal: ({ roleId }) })))
                })
                : [];
            function resolvePrivilegesForEachUser(userId) {
                const roleIds = rolesForUsers
                    .find(r => r.userId === userId)
                    .userHasRoles
                    .map(r => r.roleId.toString());
                // roleIds.push(universalPermissions.roles.authenticated.roleId)
                const hard = getHardPrivilegeDetails(...roleIds);
                const soft = roleIds
                    .flatMap(roleId => allRolesHavePrivileges.filter(p => p.roleId.toString() === roleId));
                const privileges = getActivePrivilegeIds(mergeRoleHasPrivileges({ hard, soft }))
                    .map(id => id.toString());
                return { userId, privileges };
            }
            return userIds.map(resolvePrivilegesForEachUser);
        }
        async function getPublicRolesForUsers(userIds) {
            const rolesForUsers = await getUsersHaveRoles({
                userIds,
                onlyGetPublicRoles: true,
            });
            const allRoleIds = rolesForUsers
                .flatMap(r => r.userHasRoles
                .filter(r2 => r2.public)
                .map(r2 => r2.roleId.toString()));
            const allHardRoles = allRoleIds.map(roleId => {
                const found = Object.entries(hardPermissions.roles)
                    .find(([, role]) => role.roleId === roleId);
                if (found) {
                    const [label, role] = found;
                    return {
                        roleId: DamnId.fromString(roleId),
                        label,
                        hard: true,
                        public: role.public,
                        assignable: role.assignable,
                        time: 0,
                    };
                }
                else {
                    return undefined;
                }
            }).filter(r => !!r);
            const allSoftRoles = allRoleIds.length
                ? await permissionsTables.role.read({
                    conditions: or(...allRoleIds.map(roleId => ({ equal: { roleId: DamnId.fromString(roleId) } })))
                })
                : [];
            const mergedRoles = [...allHardRoles];
            for (const role of allSoftRoles) {
                const found = mergedRoles.find(r => r.roleId === role.roleId);
                if (!found)
                    mergedRoles.push(role);
            }
            function assemblePublicRolesForEachUser(userId) {
                const userHasRoles = rolesForUsers
                    .find(r => r.userId === userId)
                    .userHasRoles;
                const publicUserRoles = userHasRoles
                    .map(userHasRole => {
                    const role = mergedRoles.find(r => r.roleId.toString() === userHasRole.roleId.toString());
                    if (!role)
                        console.warn(`missing role "${userHasRole.roleId.toString()}"`);
                    return role
                        ? { ...userHasRole, ...role }
                        : undefined;
                })
                    .filter(r => !!r)
                    .filter(isCurrentlyWithinTimeframe)
                    .map(r => ({
                    label: r.label,
                    roleId: r.roleId.toString(),
                    timeframeEnd: r.timeframeEnd,
                    timeframeStart: r.timeframeStart,
                }));
                return { userId, publicUserRoles };
            }
            return userIds.map(assemblePublicRolesForEachUser);
        }
        const { getPrivileges, getAllPrivileges } = (() => {
            function getAllHardPrivileges() {
                return Object.entries(hardPermissions.privileges)
                    .map(([label, privilegeId]) => ({
                    privilegeId: DamnId.fromString(privilegeId),
                    label,
                    hard: true,
                    time: 0,
                }));
            }
            function mergePrivileges(soft, hard) {
                return merge(soft, hard, (a, b) => a.privilegeId === b.privilegeId)
                    .map(({ hard, label, time, privilegeId }) => ({
                    hard,
                    label,
                    time: time ?? 0,
                    privilegeId: privilegeId.toString(),
                }));
            }
            return {
                async getPrivileges(privilegeIds) {
                    const soft = privilegeIds.length
                        ? await permissionsTables.privilege
                            .read(findAll(privilegeIds, id => ({
                            privilegeId: DamnId.fromString(id)
                        })))
                        : [];
                    const hard = getAllHardPrivileges()
                        .filter(p => privilegeIds.includes(p.privilegeId.toString()));
                    return mergePrivileges(soft, hard);
                },
                async getAllPrivileges() {
                    const soft = await permissionsTables.privilege.read({ conditions: false });
                    const hard = getAllHardPrivileges();
                    return mergePrivileges(soft, hard);
                },
            };
        })();
        async function getPermissionsDisplay() {
            const all = { conditions: false };
            return concurrent({
                roles: (async () => {
                    const soft = await permissionsTables.role.read(all);
                    const hard = Object.entries(hardPermissions.roles)
                        .map(([label, r]) => ({
                        label,
                        hard: true,
                        roleId: DamnId.fromString(r.roleId),
                        public: r.public,
                        assignable: r.assignable,
                        time: 0,
                    }));
                    return merge(soft, hard, (a, b) => a.roleId === b.roleId)
                        .map(result => ({
                        roleId: result.roleId.toString(),
                        assignable: result.assignable,
                        label: result.label,
                        hard: result.hard,
                        public: result.public,
                        time: result.time ?? 0,
                    }));
                })(),
                privileges: getAllPrivileges(),
                rolesHavePrivileges: (async () => {
                    const roleIds = Object.values(hardPermissions.roles)
                        .map(role => role.roleId);
                    const hard = getHardPrivilegeDetails(...roleIds);
                    const soft = await permissionsTables.roleHasPrivilege.read(all);
                    return mergeRoleHasPrivileges({ hard, soft })
                        .map(({ active, privilegeId, immutable, roleId, time }) => ({
                        active,
                        immutable,
                        time: time ?? 0,
                        roleId: roleId.toString(),
                        privilegeId: privilegeId.toString(),
                    }));
                })(),
            });
        }
        async function getUserPrivileges(userId) {
            const result = await getPrivilegesForUsers([userId]);
            return result
                .find(r => r.userId === userId)
                .privileges;
        }
        // async function getUserPublicRoles(userId: string) {
        // 	const result = await getPublicRolesForUsers([userId])
        // 	return result
        // 		.find(r => r.userId === userId)
        // 		.publicUserRoles
        // }
        return {
            getUsersHaveRoles,
            getAnonymousPrivileges,
            getPrivilegesForUsers,
            getPublicRolesForUsers,
            getPermissionsDisplay,
            getPrivileges,
            getAllPrivileges,
            getUserPrivileges,
        };
    }

    const makeUserService = (options) => service()
        .policy(options.authPolicies.anonPolicy)
        .expose(({ authTables, access }) => ({
        async getUser({ userId }) {
            const permissionsEngine = makePermissionsEngine({
                permissionsTables: authTables.permissions,
                isPlatform: access.appId === options.config.platform.appDetails.appId,
            });
            return await fetchUser({
                authTables,
                permissionsEngine,
                userId: DamnId.fromString(userId),
            });
        },
    }));

    const makeGreenService = (options) => service()
        .policy(options.authPolicies.greenPolicy)
        .expose(({ appTables, authTables: unconstrainedAuthTables }) => ({
        async authorize({ scope, refreshToken, appId: appIdString, }) {
            const appId = DamnId.fromString(appIdString);
            const authTables = unconstrainedAuthTables.namespaceForApp(appId);
            const permissionsEngine = makePermissionsEngine({
                permissionsTables: authTables.permissions,
                isPlatform: appId.toString() === options.config.platform.appDetails.appId,
            });
            const appRow = await appTables.registrations.one(find({ appId }));
            if (!appRow)
                throw new ApiError(400, "incorrect app id");
            if (appRow.archived)
                throw new ApiError(403, "app has been archived");
            if (refreshToken) {
                const { userId: userIdString } = await options.verifyToken(refreshToken);
                const userId = DamnId.fromString(userIdString);
                const user = await fetchUser({
                    userId,
                    authTables,
                    permissionsEngine,
                });
                await authTables.users.latestLogins.update({
                    ...find({ userId }),
                    upsert: { userId, time: Date.now() },
                });
                const privileges = await permissionsEngine
                    .getUserPrivileges(userId.toString());
                return options.signToken({
                    lifespan: options.config.crypto.tokenLifespans.access,
                    payload: {
                        user,
                        scope,
                        permit: { privileges },
                        appId: appId.toString(),
                        origins: originsFromDatabase(appRow.origins),
                    },
                });
            }
            else {
                const privileges = await permissionsEngine.getAnonymousPrivileges();
                return options.signToken({
                    lifespan: options.config.crypto.tokenLifespans.access,
                    payload: {
                        user: undefined,
                        appId: appId.toString(),
                        scope,
                        origins: originsFromDatabase(appRow.origins),
                        permit: { privileges },
                    },
                });
            }
        }
    }));

    async function signAuthTokens({ scope, appId, userId, origins, lifespans, authTables, permissionsEngine, signToken, }) {
        const { user, permit } = await concurrent({
            user: fetchUser({ userId, authTables, permissionsEngine }),
            permit: (async () => ({
                privileges: await permissionsEngine.getUserPrivileges(userId.toString()),
            }))(),
        });
        return concurrent({
            accessToken: signToken({
                payload: { appId, origins, user, permit, scope },
                lifespan: lifespans.access,
            }),
            refreshToken: signToken({
                payload: { userId: user.userId },
                lifespan: lifespans.refresh,
            }),
        });
    }

    function generateAccountRow({ rando }) {
        return {
            userId: rando.randomId(),
            created: Date.now(),
        };
    }

    const generateProfileRow = ({ userId, avatar, generateNickname }) => ({
        userId,
        avatar,
        tagline: "",
        nickname: generateNickname(),
    });

    function randomXioAvatarSimpleSpec() {
        return {
            type: "simple",
            value: Math.random(),
        };
    }

    async function initializeUserProfile({ userId, authTables, email, generateNickname }) {
        const avatar = JSON.stringify(randomXioAvatarSimpleSpec());
        await authTables.users.profiles.create(generateProfileRow({
            userId,
            avatar,
            generateNickname,
        }));
    }

    const standardRoleIds = {
        everybody: universalPermissions.roles.everybody.roleId,
        authenticated: universalPermissions.roles.authenticated.roleId,
        technician: universalPermissions.roles.technician.roleId,
    };
    async function assertEmailAccount({ rando, email, authTables, config, generateNickname, }) {
        email = email.toLowerCase();
        const accountViaEmail = await authTables.users.emails.assert({
            ...find({ email }),
            make: async function makeNewAccountViaEmail() {
                const isTechnician = email === config.platform.technician.email;
                const account = generateAccountRow({ rando });
                const { userId } = account;
                const createAccount = authTables.users.accounts.create(account);
                const createProfile = initializeUserProfile({
                    userId,
                    email,
                    authTables,
                    generateNickname,
                });
                const assignEverybody = authTables.permissions.userHasRole.create({
                    userId,
                    hard: true,
                    public: false,
                    roleId: DamnId.fromString(standardRoleIds.everybody),
                    timeframeEnd: undefined,
                    timeframeStart: undefined,
                    time: Date.now(),
                });
                const assignAuthenticated = authTables.permissions.userHasRole.create({
                    userId,
                    hard: true,
                    public: false,
                    roleId: DamnId.fromString(standardRoleIds.authenticated),
                    timeframeEnd: undefined,
                    timeframeStart: undefined,
                    time: Date.now(),
                });
                const assignTechnician = isTechnician
                    ? authTables.permissions.userHasRole.create({
                        userId,
                        hard: true,
                        public: true,
                        timeframeEnd: undefined,
                        roleId: DamnId.fromString(standardRoleIds.technician),
                        timeframeStart: undefined,
                        time: Date.now(),
                    })
                    : Promise.resolve();
                await Promise.all([
                    createAccount,
                    createProfile,
                    assignEverybody,
                    assignAuthenticated,
                    assignTechnician,
                ]);
                return { email, userId };
            },
        });
        return { userId: accountViaEmail.userId };
    }

    function runValidation(value, validator) {
        const problems = validator(value);
        if (problems.length > 0)
            throw new ApiError(400, problems.join("; "));
        else
            return value;
    }

    const makeLoginService = ({ rando, config, authPolicies, signToken, verifyToken, sendLoginEmail, generateNickname, }) => service()
        .policy(authPolicies.anonPolicy)
        .expose(({ access, authTables, appTables }) => ({
        async sendLoginLink(inputs) {
            const { email: rawEmail } = runValidation(inputs, schema({ email: email() }));
            const email$1 = rawEmail.toLowerCase();
            const appId = DamnId.fromString(access.appId);
            const appRow = await appTables.registrations.one(find({ appId }));
            const { userId } = await assertEmailAccount({
                rando, email: email$1, config, authTables, generateNickname,
            });
            const loginTokenPayload = { userId: userId.toString() };
            await sendLoginEmail({
                appHome: appRow.home,
                appLabel: appRow.label,
                to: email$1,
                legalLink: config.platform.legalLink,
                platformLink: config.platform.appDetails.home,
                lifespan: config.crypto.tokenLifespans.login,
                loginToken: await signToken({
                    payload: loginTokenPayload,
                    lifespan: config.crypto.tokenLifespans.login,
                }),
            });
        },
        async authenticateViaLoginToken({ loginToken }) {
            const verified = await verifyToken(loginToken);
            const userId = DamnId.fromString(verified.userId);
            const authTokens = await signAuthTokens({
                userId,
                authTables,
                scope: { core: true },
                appId: access.appId,
                origins: access.origins,
                lifespans: config.crypto.tokenLifespans,
                permissionsEngine: makePermissionsEngine({
                    isPlatform: access.appId === config.platform.appDetails.appId,
                    permissionsTables: authTables.permissions,
                }),
                signToken,
            });
            await authTables.users.latestLogins.update({
                ...find({ userId }),
                upsert: { userId, time: Date.now() },
            });
            return authTokens;
        },
    }));

    const adminRoleId$1 = DamnId.fromString(appPermissions.roles.admin.roleId);
    async function appointAdmin({ email, authTables, rando, config, generateNickname, }) {
        const { userId: adminUserId } = await assertEmailAccount({
            rando,
            email,
            config,
            authTables,
            generateNickname,
        });
        await authTables.permissions.userHasRole.assert({
            ...find({ userId: adminUserId, roleId: adminRoleId$1 }),
            make: async () => ({
                userId: adminUserId,
                roleId: adminRoleId$1,
                hard: false,
                public: true,
                timeframeEnd: undefined,
                timeframeStart: undefined,
                time: Date.now()
            })
        });
    }

    const emailValidator = validator$1(string(), maxLength(256), email());

    const adminRoleId = DamnId.fromString(appPermissions.roles.admin.roleId);
    const makeAppEditService = ({ rando, config, authPolicies, generateNickname, }) => service()
        .policy(authPolicies.appOwnerPolicy)
        .expose(({ appTables, authTablesForPlatform, authorizeAppOwner }) => ({
        async updateApp({ appId: appIdString, appDraft }) {
            throwProblems(validateAppDraft(appDraft));
            const appId = DamnId.fromString(appIdString);
            await authorizeAppOwner(appId);
            await appTables.registrations.update({
                ...find({ appId }),
                whole: {
                    appId,
                    home: appDraft.home,
                    label: appDraft.label,
                    origins: originsToDatabase(appDraft.origins),
                    archived: false,
                },
            });
        },
        async deleteApp({ appId: appIdString }) {
            const appId = DamnId.fromString(appIdString);
            await authorizeAppOwner(appId);
            await appTables.registrations.update({
                ...find({ appId }),
                write: { archived: true },
            });
        },
        async listAdmins({ appId: appIdString }) {
            const appId = DamnId.fromString(appIdString);
            const { authTables } = await authorizeAppOwner(appId);
            const usersWithAdminRole = await authTables.permissions.userHasRole
                .read(find({ roleId: adminRoleId }));
            const adminsViaEmail = await authTables.users.emails
                .read(find(...usersWithAdminRole.map(({ userId }) => ({ userId }))));
            return adminsViaEmail.map(({ userId, email }) => ({
                userId: userId.toString(),
                email,
            }));
        },
        async assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }) {
            const appId = DamnId.fromString(appIdString);
            const { authTables } = await authorizeAppOwner(appId);
            const platformUserId = DamnId.fromString(platformUserIdString);
            const platformAccount = await authTablesForPlatform.users.emails
                .one(find({ userId: platformUserId }));
            if (!platformAccount)
                throw new ApiError(404, "platform email account not found");
            const { email } = platformAccount;
            await appointAdmin({
                rando,
                config,
                email,
                authTables,
                generateNickname,
            });
        },
        async assignAdmin({ appId: appIdString, email }) {
            const appId = DamnId.fromString(appIdString);
            const { authTables } = await authorizeAppOwner(appId);
            const problems = emailValidator(email);
            if (problems.length)
                throw new ApiError(400, "email failed validation: " + problems.join(";"));
            await appointAdmin({
                rando,
                config,
                email: email.toLowerCase(),
                authTables,
                generateNickname,
            });
        },
        async revokeAdmin({ appId: appIdString, userId: userIdString }) {
            const appId = DamnId.fromString(appIdString);
            const userId = DamnId.fromString(userIdString);
            const { authTables } = await authorizeAppOwner(appId);
            await authTables.permissions.userHasRole.delete(find({
                userId,
                roleId: adminRoleId,
            }));
        },
    }));

    const profileValidators = {
        nickname: validator$1(string(), minLength(1), maxLength(24), notWhitespace()),
        tagline: validator$1(string(), minLength(0), maxLength(32), notWhitespace()),
    };
    const validateProfileDraft = schema({
        ...profileValidators,
    });

    const makePersonalService = (options) => service()
        .policy(options.authPolicies.userPolicy)
        .expose(({ access, authTables, checker }) => ({
        async setProfile({ userId: userIdString, profileDraft }) {
            const userId = DamnId.fromString(userIdString);
            const isProfileOwner = access.user.userId === userIdString;
            const canEditAnyProfile = checker.hasPrivilege("edit any profile");
            const allowed = isProfileOwner || canEditAnyProfile;
            if (!allowed)
                throw new ApiError(403, "forbidden: you are not allowed to edit this profile");
            throwProblems(validateProfileDraft(profileDraft));
            await authTables.users.profiles.update({
                ...find({ userId }),
                write: {
                    nickname: profileDraft.nickname,
                    tagline: profileDraft.tagline,
                },
            });
        },
    }));

    const roleLabelValidator = validator$1(string(), minLength(1), maxLength(16), notWhitespace());

    const makePermissionsService = ({ rando, config, authPolicies, }) => service()
        .policy(async (meta, headers) => {
        const auth = await authPolicies.userPolicy(meta, headers);
        auth.checker.requirePrivilege("customize permissions");
        const engine = makePermissionsEngine({
            permissionsTables: auth.authTables.permissions,
            isPlatform: auth.access.appId === config.platform.appDetails.appId,
        });
        return { ...auth, engine };
    })
        .expose(({ authTables, engine }) => ({
        async fetchPermissions() {
            return engine.getPermissionsDisplay();
        },
        async createRole({ label }) {
            const problems = roleLabelValidator(label);
            if (problems.length)
                throw new ApiError(400, `validation error on label: ${problems.join("; ")}`);
            await authTables.permissions.role.create({
                label,
                hard: false,
                public: true,
                assignable: true,
                roleId: rando.randomId(),
                time: Date.now(),
            });
        },
        async deleteRole({ roleId: roleIdString }) {
            const roleId = DamnId.fromString(roleIdString);
            const role = await authTables.permissions.role.one(find({ roleId }));
            if (!role)
                throw new ApiError(404, "role not found");
            if (role.hard)
                throw new ApiError(400, "cannot delete hard role");
            await Promise.all([
                authTables.permissions.userHasRole.delete(find({ roleId })),
                authTables.permissions.role.delete(find({ roleId })),
            ]);
        },
        async assignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }) {
            const roleId = DamnId.fromString(roleIdString);
            const privilegeId = DamnId.fromString(privilegeIdString);
            await authTables.permissions.roleHasPrivilege.update({
                ...find({ roleId, privilegeId }),
                upsert: {
                    roleId,
                    privilegeId,
                    active: true,
                    immutable: false,
                    time: Date.now(),
                },
            });
        },
        async unassignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }) {
            const roleId = DamnId.fromString(roleIdString);
            const privilegeId = DamnId.fromString(privilegeIdString);
            await authTables.permissions.roleHasPrivilege.update({
                ...find({ roleId, privilegeId }),
                upsert: {
                    roleId,
                    privilegeId,
                    active: false,
                    immutable: false,
                    time: Date.now(),
                },
            });
        },
        async createPrivilege({ label }) {
            const privilege = {
                label,
                hard: false,
                privilegeId: rando.randomId(),
                time: Date.now(),
            };
            await authTables.permissions.privilege.create(privilege);
            return {
                hard: privilege.hard,
                label: privilege.label,
                privilegeId: privilege.privilegeId.toString(),
                time: Date.now(),
            };
        },
        async deletePrivilege({ privilegeId: privilegeIdString }) {
            const privilegeId = DamnId.fromString(privilegeIdString);
            const [privilege] = await engine.getPrivileges([privilegeId.toString()]);
            if (!privilege)
                throw new ApiError(400, `cannot delete missing privilege "${privilege.privilegeId.toString()}"`);
            if (privilege.hard)
                throw new ApiError(400, `cannot delete hard privilege "${privilege.privilegeId.toString()}"`);
            await Promise.all([
                authTables.permissions
                    .roleHasPrivilege.delete(find({ privilegeId })),
                authTables.permissions
                    .privilege.delete(find({ privilegeId })),
            ]);
        },
    }));

    function authApi(options) {
        return api({
            apps: {
                appService: makeAppService(options),
                appEditService: makeAppEditService(options),
            },
            users: {
                greenService: makeGreenService(options),
                loginService: makeLoginService(options),
                userService: makeUserService(options),
                personalService: makePersonalService(options),
            },
            permissions: {
                permissionsService: makePermissionsService(options),
            },
        });
    }

    const maxNotesPerPage = 100;
    const validatePagination = schema({
        offset: validator$1(number(), min(0)),
        limit: validator$1(number(), min(0), max(maxNotesPerPage))
    });

    const makeNotesService = ({ config, basePolicy, notesTables: rawNotesTables, }) => service()
        .policy(async (meta, headers) => {
        const auth = await basePolicy(meta, headers);
        const appId = DamnId.fromString(auth.access.appId);
        return {
            ...auth,
            notesTables: rawNotesTables.namespaceForApp(appId),
        };
    })
        .expose(({ notesTables, access }) => ({
        async getNotesStats() {
            const { userId } = access.user;
            const newCount = await notesTables.notes.count(find({
                to: DamnId.fromString(userId),
                old: false
            }));
            const oldCount = await notesTables.notes.count(find({
                to: DamnId.fromString(userId),
                old: true
            }));
            return { newCount, oldCount };
        },
        async getNewNotes(pagination) {
            const { offset, limit } = runValidation(pagination, validatePagination);
            const { userId } = access.user;
            const newNotes = await notesTables.notes.read({
                ...find({
                    to: DamnId.fromString(userId),
                    old: false
                }),
                offset,
                limit,
                order: { time: "descend" }
            });
            return newNotes.map(note => ({
                type: "message",
                noteId: note.noteId.toString(),
                time: note.time,
                old: note.old,
                from: undefined,
                to: note.to.toString(),
                text: note.text,
                title: note.title,
                details: {},
            }));
        },
        async getOldNotes(pagination) {
            const { offset, limit } = runValidation(pagination, validatePagination);
            const { userId } = access.user;
            const oldNotes = await notesTables.notes.read({
                ...find({
                    to: DamnId.fromString(userId),
                    old: true
                }),
                offset,
                limit,
                order: { time: "descend" }
            });
            return oldNotes.map(note => ({
                type: "message",
                noteId: note.noteId.toString(),
                time: note.time,
                old: note.old,
                from: undefined,
                to: note.to.toString(),
                text: note.text,
                title: note.title,
                details: {},
            }));
        },
        async markAllNotesOld() {
            const { userId } = access.user;
            await notesTables.notes.update({
                ...find({
                    to: DamnId.fromString(userId),
                    old: false,
                }),
                write: { old: true },
            });
        },
        async markNotesNewOrOld(input) {
            const { userId } = access.user;
            const { old, noteIds: noteIdStrings } = runValidation(input, schema({
                old: boolean(),
                noteIds: validator$1(array(), maxLength(1000), each(validateId)),
            }));
            const noteIds = noteIdStrings.map(id => DamnId.fromString(id));
            const notes = await notesTables.notes.read(findAll(noteIds, noteId => ({ noteId })));
            for (const note of notes) {
                if (userId !== note.to.toString())
                    throw new ApiError(403, `user is not privileged for note ${note.to.toString()}`);
            }
            await notesTables.notes.update({
                ...findAll(noteIds, noteId => ({ noteId })),
                write: { old }
            });
        }
    }));

    function notesApi({ config, notesTables, authPolicies }) {
        return api({
            notesService: makeNotesService({
                config,
                notesTables,
                basePolicy: authPolicies.userPolicy,
            })
        });
    }

    const goodApiKey = "good";

    const validateDacastApiKey = validator$1(validator$1(string(), minLength(16), maxLength(64), zeroWhitespace()));
    const validateDacastApiKeyAllowingMock = value => value === goodApiKey
        ? []
        : validateDacastApiKey(value);

    function makePrivilegeChecker(permit, privileges) {
        function hasPrivilege(key) {
            return permit.privileges.includes(privileges[key]);
        }
        function requirePrivilege(key) {
            if (!hasPrivilege(key))
                throw new ApiError(403, `forbidden; privilege required "${key}"`);
        }
        function requireNotHavePrivilege(key) {
            if (hasPrivilege(key))
                throw new ApiError(403, `forbidden: must not have privilege "${key}"`);
        }
        return {
            hasPrivilege,
            requirePrivilege,
            requireNotHavePrivilege,
        };
    }

    function toLinkDisplay(secret) {
        return secret
            ? { time: secret.time }
            : undefined;
    }
    const makeDacastService = ({ config, dacastSdk, videoTables: rawVideoTables, basePolicy, }) => service()
        .policy(async (meta, request) => {
        const auth = await basePolicy(meta, request);
        const appId = DamnId.fromString(auth.access.appId);
        const checker = makePrivilegeChecker(auth.access.permit, videoPrivileges);
        checker.requirePrivilege("moderate videos");
        const engine = makePermissionsEngine({
            isPlatform: auth.access.appId === config.platform.appDetails.appId,
            permissionsTables: auth.authTables.permissions,
        });
        return {
            ...auth,
            checker,
            engine,
            videoTables: rawVideoTables.namespaceForApp(appId),
        };
    })
        .expose(({ videoTables }) => ({
        async getLink() {
            const secret = await videoTables.dacastAccountLinks.one({
                conditions: false,
            });
            return toLinkDisplay(secret);
        },
        async setLink(inputs) {
            const { apiKey } = runValidation(inputs, schema({
                apiKey: validateDacastApiKeyAllowingMock,
            }));
            const good = await dacastSdk.verifyApiKey(apiKey);
            let secret;
            if (good) {
                secret = { apiKey, time: Date.now() };
                await videoTables.dacastAccountLinks.update({
                    conditions: false,
                    upsert: secret,
                });
            }
            return toLinkDisplay(secret);
        },
        async clearLink() {
            await videoTables.dacastAccountLinks.delete({
                conditions: false,
            });
            return undefined;
        },
    }));

    function ingestDacastContent({ type, data, }) {
        const pictures = (data.pictures ?? []);
        const picture = pictures[0];
        const thumb = picture
            ? (picture.thumbnail ?? [])[0]
            : undefined;
        return {
            type,
            thumb,
            id: data.id,
            title: data.title,
            provider: "dacast",
        };
    }

    async function getCatalog({ dacast }) {
        const results = await concurrent({
            vods: dacast.vods.get(),
            channels: dacast.channels.get(),
            playlists: dacast.playlists.get(),
        });
        function convert2(type, paginated) {
            return (paginated?.data ?? []).map(data => ingestDacastContent({
                type,
                data,
            }));
        }
        return [
            ...convert2("vod", results.vods),
            ...convert2("channel", results.channels),
            ...convert2("playlist", results.playlists),
        ];
    }

    async function getAllViews({ videoTables }) {
        const viewDacastRows = await videoTables.viewDacast.read({
            conditions: false,
        });
        const viewPrivilegeRows = await videoTables.viewPrivileges.read({
            conditions: false,
        });
        return viewDacastRows.map(dacastRow => {
            const privileges = viewPrivilegeRows
                .filter(privilegeRow => privilegeRow.label === dacastRow.label)
                .map(r => r.privilegeId.toString());
            return {
                id: dacastRow.dacastId,
                label: dacastRow.label,
                privileges,
                provider: "dacast",
                type: dacastRow.type,
            };
        });
    }

    function isPermittedToView({ viewPrivileges, userPrivileges }) {
        for (const requiredPrivilege of viewPrivileges) {
            const userHasPrivilege = userPrivileges
                .find(p => p === requiredPrivilege);
            if (userHasPrivilege)
                return true;
        }
        return false;
    }

    async function getVideoViews({ labels, videoTables, checker, userPrivileges, }) {
        if (labels.length === 0)
            return [];
        const dacastRows = await videoTables.viewDacast.read(findAll(labels, label => ({ label })));
        const privilegeRows = await videoTables.viewPrivileges.read(findAll(labels, label => ({ label })));
        return dacastRows.map(({ label, type, dacastId }) => {
            const privileges = privilegeRows
                .filter(p => p.label === label)
                .map(p => p.privilegeId.toString());
            const hasExplicitPrivilege = isPermittedToView({
                viewPrivileges: privileges,
                userPrivileges,
            });
            const isPermitted = hasExplicitPrivilege
                || checker.hasPrivilege("view all videos")
                || checker.hasPrivilege("moderate videos");
            return isPermitted
                ? {
                    type,
                    label,
                    privileges,
                    id: dacastId,
                    provider: "dacast",
                }
                : undefined;
        });
    }

    const embedType = "iframe";
    async function getDacastEmbed({ dacast, reference: { id, type }, }) {
        switch (type) {
            case "vod": return dacast.vods.id(id).embed(embedType).get();
            case "channel": return dacast.channels.id(id).embed(embedType).get();
            case "playlist": return dacast.playlists.id(id).embed(embedType).get();
            default: throw new Error(`unknown dacast type "${type}"`);
        }
    }

    async function getDacastApiKey(videoTables) {
        const link = await videoTables.dacastAccountLinks
            .one({ conditions: false });
        return link
            ? link.apiKey
            : undefined;
    }

    async function getAllPrivileges({ access, platformAppId, permissionsTables, }) {
        const permissionsEngine = makePermissionsEngine({
            permissionsTables,
            isPlatform: access.appId === platformAppId
        });
        const permissionsDisplay = await permissionsEngine
            .getPermissionsDisplay();
        return permissionsDisplay.privileges;
    }

    async function getDacastContent({ dacast, reference: { provider, type, id }, }) {
        if (provider !== "dacast")
            throw new ApiError(500, `video content provider mismatch (expected "dacast", got "${provider}")`);
        switch (type) {
            case "vod": return dacast.vods.id(id).get();
            case "channel": return dacast.channels.id(id).get();
            case "playlist": return dacast.playlists.id(id).get();
            default: throw new ApiError(500, `unknown dacast type "${type}"`);
        }
    }

    async function setViewPermissions({ label, engine, videoTables, privileges: privilegesInput, }) {
        // delete all privileges associated with this view
        await videoTables.viewPrivileges.delete(find({ label }));
        // select only privileges that actually exist
        const privileges = await engine.getPrivileges(privilegesInput)
            .then(displays => displays
            .filter(d => !!d)
            .map(d => d.privilegeId.toString()));
        // add new privileges for this view
        await videoTables.viewPrivileges.create(...privileges.map(privilege => ({
            label,
            privilegeId: DamnId.fromString(privilege),
        })));
    }

    const makeContentService = ({ config, dacastSdk, videoTables: rawVideoTables, basePolicy, }) => service()
        .policy(async (meta, headers) => {
        const auth = await basePolicy(meta, headers);
        const appId = DamnId.fromString(auth.access.appId);
        const checker = makePrivilegeChecker(auth.access.permit, videoPrivileges);
        const engine = makePermissionsEngine({
            isPlatform: auth.access.appId === config.platform.appDetails.appId,
            permissionsTables: auth.authTables.permissions,
        });
        return {
            ...auth,
            engine,
            checker,
            videoTables: rawVideoTables.namespaceForApp(appId),
        };
    })
        .expose(({ access, authTables, videoTables, checker, engine }) => ({
        async fetchModerationData() {
            checker.requirePrivilege("moderate videos");
            return concurrent({
                views: getAllViews({ videoTables }),
                privileges: getAllPrivileges({
                    access,
                    permissionsTables: authTables.permissions,
                    platformAppId: config.platform.appDetails.appId,
                }),
                catalog: getDacastApiKey(videoTables)
                    .then(async (apiKey) => apiKey
                    ? getCatalog({ dacast: dacastSdk.getClient(apiKey) })
                    : []),
            });
        },
        async writeView({ label, privileges, reference, }) {
            checker.requirePrivilege("moderate videos");
            await videoTables.viewDacast.update({
                ...find({ label }),
                whole: {
                    label,
                    type: reference.type,
                    dacastId: reference.id,
                },
            });
            await setViewPermissions({
                label,
                engine,
                privileges,
                videoTables,
            });
        },
        async deleteView({ label }) {
            checker.requirePrivilege("moderate videos");
            await videoTables.viewDacast.delete(find({ label }));
            await videoTables.viewPrivileges.delete(find({ label }));
        },
        async getShows({ labels }) {
            const apiKey = await getDacastApiKey(videoTables);
            if (!apiKey)
                return [];
            const views = await getVideoViews({
                labels,
                checker,
                videoTables,
                userPrivileges: access.permit.privileges,
            });
            const dacast = dacastSdk.getClient(apiKey);
            return Promise.all(views.map(async (view, index) => {
                const label = labels[index];
                if (!view)
                    return { label, details: undefined };
                const [data, embed] = await Promise.all([
                    getDacastContent({ dacast, reference: view }),
                    getDacastEmbed({ dacast, reference: view }),
                ]);
                const show = {
                    label,
                    details: data
                        ? {
                            ...ingestDacastContent({
                                type: view.type,
                                data,
                            }),
                            embed: embed?.code,
                        }
                        : null,
                };
                return show;
            }));
        },
    }));

    function videosApi({ config, videoTables, authPolicies, dacastSdk, }) {
        const options = {
            config,
            videoTables,
            basePolicy: authPolicies.anonPolicy,
        };
        return api({
            dacastService: makeDacastService({
                ...options,
                dacastSdk,
            }),
            contentService: makeContentService({
                ...options,
                dacastSdk,
            }),
        });
    }

    const makeExampleService = ({ rando, config, authPolicies, exampleTables, }) => service()
        .policy(async (meta, headers) => {
        const auth = await authPolicies.userPolicy(meta, headers);
        const appId = DamnId.fromString(auth.access.appId);
        return {
            ...auth,
            exampleTables: exampleTables.namespaceForApp(appId),
        };
    })
        .expose(({ access, exampleTables }) => ({
        async exampleFunction({ something }) {
            await exampleTables.examplePosts.create({
                exampleId: rando.randomId(),
                something,
            });
        },
    }));

    function exampleApi(options) {
        return api({
            exampleService: makeExampleService(options),
        });
    }

    async function makeVotingBooth({ userId, itemIds, likesTable, reportsTable }) {
        const likes = await makeVoteCounter({ itemIds, voteTable: likesTable });
        const reports = await makeVoteCounter({ itemIds, voteTable: reportsTable });
        return {
            getVotingDetails(itemId) {
                return {
                    likes: likes.countVotes(itemId),
                    reports: reports.countVotes(itemId),
                    liked: userId
                        ? likes.voteStatus({ userId, itemId })
                        : false,
                    reported: userId
                        ? reports.voteStatus({ userId, itemId })
                        : false,
                };
            }
        };
    }
    async function makeVoteCounter({ itemIds, voteTable }) {
        const votes = itemIds.length
            ? await voteTable.read(findAll(itemIds, itemId => ({ itemId })))
            : [];
        return {
            countVotes(itemId) {
                return votes
                    .filter(vote => vote.itemId.toString() === itemId.toString())
                    .length;
            },
            voteStatus({ userId, itemId }) {
                const votesByUser = votes
                    .filter(vote => vote.userId.toString() === userId.toString());
                const userVotedForItem = !!votesByUser
                    .find(vote => vote.itemId.toString() === itemId.toString());
                return userVotedForItem;
            },
        };
    }

    async function resolveQuestions({ userId, questionPosts, questionsTables }) {
        const questionIds = questionPosts.map(post => post.questionId);
        const answerPosts = questionIds.length
            ? await questionsTables.answerPosts
                .read(findAll(questionIds, questionId => ({ questionId, archive: false })))
            : [];
        const answerIds = answerPosts.map(post => post.answerId);
        const boothDetails = {
            userId,
            likesTable: questionsTables.likes,
            reportsTable: questionsTables.reports,
        };
        const questionsVotingBooth = await makeVotingBooth({
            ...boothDetails,
            itemIds: questionIds,
        });
        const answersVotingBooth = await makeVotingBooth({
            ...boothDetails,
            itemIds: answerIds,
        });
        return questionIds.map(questionId => {
            const questionPost = questionPosts.find(post => post.questionId === questionId);
            const question = {
                archive: questionPost.archive,
                authorUserId: questionPost.authorUserId.toString(),
                questionId: questionPost.questionId.toString(),
                board: questionPost.board,
                content: questionPost.content,
                timePosted: questionPost.timePosted,
                ...questionsVotingBooth.getVotingDetails(questionId),
                answers: answerPosts
                    .filter(answer => answer.questionId.toString() === questionId.toString())
                    .map(answerPost => ({
                    answerId: answerPost.answerId.toString(),
                    questionId: answerPost.questionId.toString(),
                    authorUserId: answerPost.authorUserId.toString(),
                    content: answerPost.content,
                    archive: answerPost.archive,
                    timePosted: answerPost.timePosted,
                    ...answersVotingBooth.getVotingDetails(answerPost.answerId),
                })),
            };
            return question;
        });
    }

    async function spikeQuestionsAuth(meta, headers, questionsTables, basePolicy) {
        const auth = await basePolicy(meta, headers);
        const appId = DamnId.fromString(auth.access.appId);
        return {
            ...auth,
            questionsTables: questionsTables.namespaceForApp(appId),
        };
    }

    function anonQuestionsPolicy({ authPolicies, questionsTables, }) {
        return async function (meta, headers) {
            return spikeQuestionsAuth(meta, headers, questionsTables, authPolicies.anonPolicy);
        };
    }

    const makeQuestionsReadingService = (options) => service()
        .policy(async (meta, request) => {
        const auth = await anonQuestionsPolicy(options)(meta, request);
        auth.checker.requirePrivilege("read questions");
        return auth;
    })
        .expose(({ access, authTables, questionsTables }) => ({
        async fetchQuestions({ board }) {
            const posts = await questionsTables.questionPosts.read({
                ...find({ board, archive: false }),
                limit: 100,
                offset: 0,
                order: { timePosted: "descend" },
            });
            if (!posts.length)
                return { users: [], questions: [] };
            const resolvedQuestions = await resolveQuestions({
                questionsTables,
                questionPosts: posts,
                userId: access?.user?.userId
                    ? DamnId.fromString(access.user.userId)
                    : undefined,
            });
            const userIds = (() => {
                const ids = [];
                const rememberUserId = (userId) => {
                    if (!ids.includes(userId))
                        ids.push(userId);
                };
                for (const question of resolvedQuestions) {
                    rememberUserId(question.authorUserId);
                    for (const answer of question.answers)
                        rememberUserId(answer.authorUserId);
                }
                return ids;
            })();
            const permissionsEngine = makePermissionsEngine({
                permissionsTables: authTables.permissions,
                isPlatform: access.appId === options.config.platform.appDetails.appId,
            });
            const bannedUserIds = (await permissionsEngine.getPrivilegesForUsers(userIds))
                .filter(p => p.privileges.includes(appPermissions.privileges["banned"]))
                .map(p => p.userId);
            const users = (await fetchUsers({
                authTables,
                permissionsEngine,
                userIds: userIds.map(id => DamnId.fromString(id)),
            }))
                .filter(u => !bannedUserIds.includes(u.userId));
            const questions = resolvedQuestions
                .filter(q => !bannedUserIds.includes(q.authorUserId.toString()))
                .map(q => ({
                ...q,
                answers: q.answers.filter(a => !bannedUserIds.includes(a.authorUserId))
            }));
            return { users, questions };
        },
    }));

    async function vote({ status, userId, itemId, voteTable }) {
        const previousVote = await voteTable.count(find({ userId, itemId }))
            > 0;
        const addVote = () => voteTable.create({ userId, itemId });
        const removeVote = () => voteTable.delete(find({ userId, itemId }));
        if (!previousVote && status)
            await addVote();
        else if (previousVote && !status)
            await removeVote();
    }

    const timeframe = 1 * day;
    const allowedNumberOfPostsInTimeframe = 10;
    async function rateLimitQuestions({ userId, questionsTables }) {
        const count = await questionsTables.questionPosts.count({
            conditions: and({ equal: { authorUserId: userId, archive: false } }, { greater: { timePosted: Date.now() - timeframe } })
        });
        if (count > allowedNumberOfPostsInTimeframe)
            throw new ApiError(429, "too many posts");
    }
    async function rateLimitAnswers({ userId, questionId, questionsTables }) {
        const count = await questionsTables.answerPosts.count({
            conditions: and({ equal: { authorUserId: userId, questionId, archive: false } }, { greater: { timePosted: Date.now() - timeframe } })
        });
        if (count > allowedNumberOfPostsInTimeframe)
            throw new ApiError(429, "too many posts");
    }

    const validatePostContent = validator$1(string(), minLength(10), maxLength(280), notWhitespace());
    const validateQuestionDraft = schema({
        board: validator$1(string(), minLength(1), maxLength(32), notWhitespace()),
        content: validatePostContent,
    });
    const validateAnswerDraft = schema({
        content: validatePostContent,
    });

    function requireUserCanEditQuestion({ userId, questionPost, checker }) {
        const userIsModerator = checker.hasPrivilege("moderate questions");
        const userIsOwner = questionPost.authorUserId.toString() === userId;
        const isAllowed = userIsModerator || userIsOwner;
        if (!isAllowed)
            throw new Error(`user is not authorized to edit question`);
    }

    function authenticatedQuestionsPolicy({ authPolicies, questionsTables, }) {
        return async function (meta, headers) {
            return spikeQuestionsAuth(meta, headers, questionsTables, authPolicies.userPolicy);
        };
    }

    const makeQuestionsPostingService = (options) => service()
        .policy(async (meta, headers) => {
        const auth = await authenticatedQuestionsPolicy(options)(meta, headers);
        auth.checker.requireNotHavePrivilege("banned");
        const canPostQuestions = auth.checker.hasPrivilege("post questions");
        const isModerator = auth.checker.hasPrivilege("moderate questions");
        const allowed = canPostQuestions || isModerator;
        if (!allowed)
            throw new ApiError(403, "not allowed to post questions");
        return auth;
    })
        .expose(({ access, questionsTables, checker }) => ({
        async postQuestion(inputs) {
            const { questionDraft } = runValidation(inputs, schema({
                questionDraft: validateQuestionDraft,
            }));
            await rateLimitQuestions({
                questionsTables,
                userId: DamnId.fromString(access.user.userId),
            });
            const row = {
                questionId: options.rando.randomId(),
                authorUserId: DamnId.fromString(access.user.userId),
                archive: false,
                timePosted: Date.now(),
                ...questionDraft,
            };
            await questionsTables.questionPosts.create(row);
            return {
                archive: row.archive,
                authorUserId: row.authorUserId.toString(),
                questionId: row.questionId.toString(),
                content: row.content,
                timePosted: row.timePosted,
                board: row.board,
                likes: 0,
                reports: 0,
                liked: false,
                reported: false,
                answers: [],
            };
        },
        async archiveQuestion(inputs) {
            const { archive, questionId: questionIdString } = runValidation(inputs, schema({
                archive: boolean(),
                questionId: validateId,
            }));
            const questionId = DamnId.fromString(questionIdString);
            const questionPost = await questionsTables.questionPosts
                .one(find({ questionId }));
            requireUserCanEditQuestion({ userId: access.user.userId, checker, questionPost });
            await questionsTables.questionPosts.update({
                ...find({ questionId }),
                write: { archive: !!archive },
            });
        },
        async likeQuestion(inputs) {
            const { like, questionId: questionIdString } = runValidation(inputs, schema({
                like: boolean(),
                questionId: validateId,
            }));
            checker.requirePrivilege("like questions");
            await vote({
                status: like,
                voteTable: questionsTables.likes,
                userId: DamnId.fromString(access.user.userId),
                itemId: DamnId.fromString(questionIdString),
            });
        },
        async reportQuestion(inputs) {
            const { report, questionId: questionIdString } = runValidation(inputs, schema({
                report: boolean(),
                questionId: validateId,
            }));
            checker.requirePrivilege("report questions");
            await vote({
                status: report,
                voteTable: questionsTables.reports,
                userId: DamnId.fromString(access.user.userId),
                itemId: DamnId.fromString(questionIdString),
            });
        },
    }));

    function requireUserCanEditAnswer({ userId, answerPost, checker }) {
        const userIsModerator = checker.hasPrivilege("moderate questions");
        const userIsOwner = answerPost.authorUserId.toString() === userId;
        const isAllowed = userIsModerator || userIsOwner;
        if (!isAllowed)
            throw new Error(`user is not authorized to edit answer`);
    }

    const makeQuestionsAnsweringService = (options) => service()
        .policy(async (meta, request) => {
        const auth = await authenticatedQuestionsPolicy(options)(meta, request);
        auth.checker.requireNotHavePrivilege("banned");
        const canPostQuestions = auth.checker.hasPrivilege("answer questions");
        const isModerator = auth.checker.hasPrivilege("moderate questions");
        const allowed = canPostQuestions || isModerator;
        if (!allowed)
            throw new ApiError(403, "not allowed to post questions");
        return auth;
    })
        .expose(({ access, questionsTables, checker }) => ({
        async postAnswer(inputs) {
            const { questionId: questionIdString, answerDraft } = runValidation(inputs, schema({
                questionId: validateId,
                answerDraft: validateAnswerDraft,
            }));
            const questionId = DamnId.fromString(questionIdString);
            const questionPost = await questionsTables.questionPosts
                .one(find({ questionId }));
            if (!questionPost)
                throw new ApiError(400, "unknown questionId");
            const userId = DamnId.fromString(access.user.userId);
            await rateLimitAnswers({
                userId,
                questionId,
                questionsTables,
            });
            const row = {
                questionId,
                answerId: options.rando.randomId(),
                authorUserId: userId,
                archive: false,
                timePosted: Date.now(),
                board: questionPost.board,
                ...answerDraft,
            };
            await questionsTables.answerPosts.create(row);
            const answer = {
                answerId: row.answerId.toString(),
                questionId: row.questionId.toString(),
                authorUserId: row.authorUserId.toString(),
                content: row.content,
                timePosted: row.timePosted,
                liked: false,
                likes: 0,
                archive: false,
                reported: false,
                reports: 0,
            };
            return answer;
        },
        async archiveAnswer(inputs) {
            const { archive, answerId: answerIdString } = runValidation(inputs, schema({
                archive: boolean(),
                answerId: validateId,
            }));
            const answerId = DamnId.fromString(answerIdString);
            const answerPost = await questionsTables.answerPosts.one(find({ answerId }));
            requireUserCanEditAnswer({ userId: access.user.userId, checker, answerPost });
            await questionsTables.answerPosts.update({
                ...find({ answerId }),
                write: { archive },
            });
        },
        async likeAnswer(inputs) {
            const { like, answerId: answerIdString } = runValidation(inputs, schema({
                like: boolean(),
                answerId: validateId,
            }));
            checker.requirePrivilege("like questions");
            await vote({
                status: like,
                voteTable: questionsTables.likes,
                userId: DamnId.fromString(access.user.userId),
                itemId: DamnId.fromString(answerIdString),
            });
        },
        async reportAnswer(inputs) {
            const { report, answerId: answerIdString } = runValidation(inputs, schema({
                report: boolean(),
                answerId: validateId,
            }));
            checker.requirePrivilege("report questions");
            await vote({
                status: report,
                voteTable: questionsTables.reports,
                userId: DamnId.fromString(access.user.userId),
                itemId: DamnId.fromString(answerIdString),
            });
        },
    }));

    const makeQuestionsModerationService = (options) => service()
        .policy(async (meta, headers) => {
        const auth = await authenticatedQuestionsPolicy(options)(meta, headers);
        auth.checker.requirePrivilege("moderate questions");
        auth.checker.requireNotHavePrivilege("banned");
        return auth;
    })
        .expose(({ questionsTables }) => ({
        async archiveBoard({ board }) {
            await questionsTables.questionPosts.update({
                ...find({ board }),
                write: { archive: true },
            });
        },
        // TODO implement
        async fetchReportedQuestions() { },
    }));

    function questionsApi(options) {
        return api({
            questionsReadingService: makeQuestionsReadingService(options),
            questionsPostingService: makeQuestionsPostingService(options),
            questionsAnsweringService: makeQuestionsAnsweringService(options),
            questionsModerationService: makeQuestionsModerationService(options),
        });
    }

    function prepareStatsHub({ appTables, authTables }) {
        return async function getStatsHub(userId) {
            async function throwForbiddenUser(appId) {
                const row = await appTables.owners.one(find({ appId }));
                if (row.userId.toString() !== userId.toString())
                    throw new ApiError(403, "forbidden");
            }
            return {
                countUsers: async (appId) => {
                    await throwForbiddenUser(appId);
                    return await authTables.namespaceForApp(appId).users.accounts.count({ conditions: false });
                },
                countUsersActiveDaily: async (appId) => {
                    await throwForbiddenUser(appId);
                    const timeToStartCounting = Date.now() - day;
                    return authTables.namespaceForApp(appId).users.latestLogins.count({
                        conditions: and({ greater: { time: timeToStartCounting } }),
                    });
                },
                countUsersActiveMonthly: async (appId) => {
                    await throwForbiddenUser(appId);
                    const timeToStartCounting = Date.now() - month;
                    return authTables.namespaceForApp(appId).users.latestLogins.count({
                        conditions: and({ greater: { time: timeToStartCounting } }),
                    });
                },
            };
        };
    }

    async function isUserOwnerOfApp({ appId, access, appTables }) {
        const { userId: userIdString } = access.user;
        const userId = DamnId.fromString(userIdString);
        const ownershipRow = await appTables.owners.one(find({ userId, appId }));
        return !!ownershipRow;
    }

    function prepareAuthPolicies({ config, appTables, authTables, verifyToken, }) {
        const getStatsHub = prepareStatsHub({ appTables, authTables });
        const greenPolicy = async (meta) => ({
            appTables,
            authTables,
        });
        const anonPolicy = async ({ accessToken }, headers) => {
            const access = await verifyToken(accessToken);
            if (access.origins.some(origin => origin === headers.origin))
                return {
                    access,
                    appTables,
                    authTables: authTables.namespaceForApp(DamnId.fromString(access.appId)),
                    checker: makePrivilegeChecker(access.permit, appPermissions.privileges),
                };
            else
                throw new ApiError(403, "request origin not allowed");
        };
        const userPolicy = async (meta, headers) => {
            const auth = await anonPolicy(meta, headers);
            if (auth.access.user)
                return auth;
            else
                throw new ApiError(403, "not logged in");
        };
        const platformUserPolicy = async (meta, headers) => {
            const auth = await userPolicy(meta, headers);
            if (auth.access.appId === config.platform.appDetails.appId) {
                return {
                    ...auth,
                    appTables,
                    authTables,
                    checker: makePrivilegeChecker(auth.access.permit, platformPermissions.privileges),
                    statsHub: await getStatsHub(DamnId.fromString(auth.access.user.userId)),
                };
            }
            else
                throw new ApiError(403, "not platform app");
        };
        const appOwnerPolicy = async (meta, headers) => {
            const auth = await platformUserPolicy(meta, headers);
            async function authorizeAppOwner(appId) {
                const allowedToEditAnyApp = auth.checker.hasPrivilege("edit any app");
                const isOwnerOfApp = isUserOwnerOfApp({ appId, appTables, access: auth.access });
                const allowed = isOwnerOfApp || allowedToEditAnyApp;
                if (allowed)
                    return { authTables: auth.authTables.namespaceForApp(appId) };
                else
                    throw new ApiError(403, "forbidden: lacking privileges to edit app");
            }
            return {
                access: auth.access,
                checker: auth.checker,
                statsHub: auth.statsHub,
                appTables: auth.appTables,
                authTablesForPlatform: auth.authTables.namespaceForApp(DamnId.fromString(config.platform.appDetails.appId)),
                authorizeAppOwner,
            };
        };
        return {
            greenPolicy,
            anonPolicy,
            userPolicy,
            platformUserPolicy,
            appOwnerPolicy,
        };
    }

    function escapeRegex(subject) {
        return subject.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }

    const validateTimeframe = branch(notDefined(), number());

    const validateUserSearchTerm = validator$1(string(), minLength(1), maxLength(64));

    const makeRoleAssignmentService = ({ config, authPolicies, }) => service()
        .policy(async (meta, headers) => {
        const auth = await authPolicies.userPolicy(meta, headers);
        auth.checker.requirePrivilege("administrate user roles");
        const engine = makePermissionsEngine({
            permissionsTables: auth.authTables.permissions,
            isPlatform: auth.access.appId === config.platform.appDetails.appId,
        });
        return { ...auth, engine };
    })
        .expose(({ engine, authTables, }) => ({
        async fetchPermissions() {
            return engine.getPermissionsDisplay();
        },
        async searchUsers(options) {
            const { term } = runValidation(options, schema({
                term: validateUserSearchTerm,
            }));
            const regex = new RegExp(escapeRegex(term), "i");
            const profiles = await authTables.users.profiles.read({
                limit: 100,
                conditions: DamnId.isId(term)
                    ? or({ equal: { userId: DamnId.fromString(term) } })
                    : or({ search: { nickname: regex } }, { search: { tagline: regex } })
            });
            const userIds = profiles.map(profile => profile.userId);
            if (!userIds.length)
                return [];
            const users = await fetchUsers({
                userIds,
                authTables,
                permissionsEngine: engine,
            });
            const usersAndRoles = await engine.getUsersHaveRoles({
                userIds: users.map(user => user.userId),
                onlyGetPublicRoles: false,
            });
            return users.map(user => ({
                user,
                roleIds: usersAndRoles
                    .find(u => u.userId === user.userId)
                    .userHasRoles
                    .map(role => role.roleId.toString())
            }));
        },
        async assignRoleToUser(options) {
            const { roleId: roleIdString, userId: userIdString, isPublic, timeframeEnd, timeframeStart } = (runValidation(options, schema({
                roleId: validateId,
                userId: validateId,
                isPublic: boolean(),
                timeframeEnd: validateTimeframe,
                timeframeStart: validateTimeframe,
            })));
            const roleId = DamnId.fromString(roleIdString);
            const userId = DamnId.fromString(userIdString);
            const existing = await authTables.permissions.userHasRole.one(find({
                userId,
                roleId,
            }));
            if (existing?.hard)
                throw new ApiError(400, "hard role assignment cannot be overwritten");
            else
                await authTables.permissions.userHasRole.assert({
                    conditions: or({ equal: { roleId, userId } }),
                    make: async () => ({
                        hard: false,
                        public: isPublic,
                        roleId,
                        userId,
                        timeframeEnd,
                        timeframeStart,
                        time: Date.now(),
                    }),
                });
        },
        async revokeRoleFromUser(options) {
            const { roleId: roleIdString, userId: userIdString } = runValidation(options, schema({
                roleId: validateId,
                userId: validateId,
            }));
            const roleId = DamnId.fromString(roleIdString);
            const userId = DamnId.fromString(userIdString);
            const existing = await authTables.permissions.userHasRole.one(find({
                userId,
                roleId,
            }));
            if (existing?.hard)
                throw new ApiError(400, "hard role assignment cannot be overwritten");
            else
                await authTables.permissions.userHasRole.delete({
                    conditions: or({ equal: { roleId, userId } }),
                });
        },
    }));

    function makeAdministrativeApi(options) {
        return api({
            roleAssignmentService: makeRoleAssignmentService(options),
        });
    }

    const colors = [
        "Red",
        "Yellow",
        "Green",
        "Cyan",
        "Blue",
        "Magenta",
        "Dark",
        "Grey",
        "Silver",
        "Bright",
        "Light",
        "Gold",
        "Golden",
        "Aqua",
        "Minty",
    ];

    const animals = [
        "Aardvark",
        "Mongoose",
        "Alligator",
        "Robin",
        "Monkey",
        "Seahorse",
        "Shark",
        "Leopard",
        "Eagle",
        "Raven",
        "Owl",
        "Hawk",
        "Duck",
        "Wolf",
        "Coyote",
        "Dingo",
        "Ostrich",
        "Llama",
        "Alpaca",
        "Zebra",
        "Bear",
        "Kiwi",
        "Penguin",
        "Otter",
        "Dolphin",
        "Starfish",
        "Sunfish",
        "Salmon",
        "Swordfish",
        "Sparrow",
        "Turtle",
        "Puppy",
        "Kitten",
    ];

    const adjectives = [
        "Funny",
        "Charming",
        "Wonderful",
        "Fancy",
        "Whimsical",
        "Gregarious",
        "Curious",
        "Fabulous",
        "Saavy",
        "Groovy",
        "Happy",
        "Snappy",
        "Quick",
        "Super",
        "Fast",
        "Fuzzy",
        "Clever",
        "Genius",
        "Marvelous",
        "Eccentric",
        "Fantastic",
        "Quaint",
        "Young",
        "Wise",
        "Creative",
        "Helpful",
        "Nice",
        "Sincere",
        "Loyal",
        "Honest",
        "Truthful",
        "Thoughtful",
        "Clean",
        "Friendly",
        "Gentle",
        "Pleasant",
        "Brilliant",
        "Polite",
        "Original",
        "Ambitious",
        "Lively",
        "Wholesome",
        "Cordial",
        "Eager",
        "Relaxed",
        "Skilled",
        "Tidy",
        "Calm",
        "Hopeful",
        "Positive",
        "Social",
        "Quick",
        "Fearless",
        "Daring",
        "Bold",
        "Quiet",
    ];

    const standardDictionary = {
        colors,
        animals,
        adjectives,
    };

    function makeNicknameGenerator({ rando, delimiter, dictionary, nicknameStructure, }) {
        const nicknameData = nicknameStructure.map(dictionarySet => dictionarySet.reduce((previous, wordGroupName) => [
            ...previous,
            ...dictionary[wordGroupName],
        ], []));
        return () => nicknameData
            .map(names => rando.randomSample(names))
            .join(delimiter);
    }

    function standardNicknameGenerator({ rando }) {
        return makeNicknameGenerator({
            rando,
            delimiter: " ",
            dictionary: standardDictionary,
            nicknameStructure: [["adjectives", "colors"], ["animals"]],
        });
    }

    async function assimilateApi({ config, rando, database, dacastSdk, sendLoginEmail, signToken, verifyToken, }) {
        const generateNickname = standardNicknameGenerator({ rando });
        const authPolicies = prepareAuthPolicies({
            config,
            verifyToken,
            appTables: database.apps,
            authTables: database.auth,
        });
        return api({
            auth: authApi({
                rando,
                config,
                authPolicies,
                signToken,
                verifyToken,
                sendLoginEmail,
                generateNickname,
            }),
            administrative: makeAdministrativeApi({
                config,
                authPolicies,
            }),
            questions: questionsApi({
                rando,
                config,
                authPolicies,
                questionsTables: database.questions,
            }),
            example: exampleApi({
                rando,
                config,
                authPolicies,
                exampleTables: database.example,
            }),
            videos: videosApi({
                config,
                dacastSdk,
                authPolicies,
                videoTables: database.videos,
            }),
            notes: notesApi({
                config,
                authPolicies,
                notesTables: database.notes,
            })
        });
    }

    function loginEmailRecaller(sendLoginEmail) {
        let latestLoginEmail;
        return {
            sendLoginEmail: async (details) => {
                latestLoginEmail = details;
                await sendLoginEmail(details);
            },
            recallLatestLoginEmail: () => latestLoginEmail,
        };
    }

    const mockSendEmail = async (email) => console.log(`

====== EMAIL ======
from: ${email.fromLabel}
to: ${email.to}
subject: ${email.subject}
time: ${new Date().toLocaleString()}

${email.text}

===================

`);

    function makeEmailEnabler(actuallySendEmail) {
        let enabled = true;
        const sendEmail = async (details) => {
            if (enabled)
                return actuallySendEmail(details);
        };
        return {
            sendEmail,
            enableEmails() { enabled = true; },
            disableEmails() { enabled = false; },
        };
    }

    function makeLoginLink({ home, loginToken }) {
        const url = new URL(home);
        url.hash = `#login=${loginToken}`;
        return url;
    }

    function escapeHtml(text) {
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    function noop(strings, ...keys) {
        const lastIndex = strings.length - 1;
        return strings
            .slice(0, lastIndex)
            .reduce((a, b, c) => a + b + keys[c], "")
            + strings[lastIndex];
    }

    function prepareSendLoginEmail({ sendEmail }) {
        return async function sendLoginEmail({ to, appHome, appLabel, lifespan, legalLink, loginToken, platformLink, }) {
            const loginLink = makeLoginLink({ loginToken, home: appHome });
            const minutesLeft = Math.round((lifespan / minute)).toFixed(0);
            const safeLabel = escapeHtml(appLabel);
            const platformHost = new URL(platformLink).host;
            return sendEmail({
                to,
                fromLabel: appLabel,
                subject: `Login link`,
                html: (noop `
<h1>Login link for ${safeLabel}</h1>
<p style="font-size: 1.2em; padding-left: 0.5rem;">
	<a href="${loginLink.toString()}"> Login to ${safeLabel} </a>
</p>
<div style="opacity: 0.7; font-size: 0.8em; margin-top: 2rem;">
	<p>Expires in ${minutesLeft} minutes.</p>
	<p>If you didn't request this login link, just ignore it.</p>
	<p>You can contact support by replying to this email.</p>
	<ul style="padding-left: 0.5rem;">
		<li>Logins powered by <a href="${platformLink}">${platformHost}</a></li>
		<li><a href="${legalLink}">Policies and terms of service</a></li>
	</ul>
	<p style="opacity: 0.3; font-size: 0.4em;">
		${Date.now()}
	</p>
</div>
`),
                text: (`
Login link for ${appLabel}

   ${loginLink.toString()}


Expires in ${minutesLeft} minutes

If you didn't request this login link, just ignore it.

You can contact support by replying to this email.

  * Logins powered by ${platformLink}

  * Policies and terms of service ${legalLink}

${Date.now()}
`),
            });
        };
    }

    function assimilateEmails({ config, configureMailgun, }) {
        let sendEmail;
        if (config.email === "mock-console") {
            sendEmail = mockSendEmail;
        }
        else {
            sendEmail = configureMailgun(config.email).sendEmail;
        }
        const enabler = makeEmailEnabler(sendEmail);
        sendEmail = enabler.sendEmail;
        const { disableEmails, enableEmails } = enabler;
        const { sendLoginEmail, recallLatestLoginEmail } = loginEmailRecaller(prepareSendLoginEmail({ sendEmail }));
        return {
            sendEmail,
            enableEmails,
            disableEmails,
            sendLoginEmail,
            recallLatestLoginEmail,
        };
    }

    function assimilateCrypto({ config, configureTokenFunctions, }) {
        return config.crypto.keys === "mock-mode"
            ? {
                signToken: mockSignToken(),
                verifyToken: mockVerifyToken(),
            }
            : configureTokenFunctions(config.crypto.keys);
    }

    function stripeWebhooks({ logger }) {
        return {
            async "checkout.session.completed"(event) {
                logger.info("stripe-webhook checkout.session.completed:", event.data.object);
            },
            async "invoice.paid"(event) {
                logger.info("stripe-webhook invoice.paid:", event.data.object);
            },
            async "invoice.payment_failed"(event) {
                logger.info("stripe-webhook invoice.payment_failed:", event.data.object);
            },
            async "customer.subscription.updated"(event) {
                logger.info("stripe-webhook customer.subscription.updated:", event.data.object);
            },
        };
    }

    function mockStripeLiaison({ rando, tables, webhooks, }) {
        const generateId = () => rando.randomId();
        function respond(resource) {
            return {
                headers: {},
                lastResponse: undefined,
                ...resource,
            };
        }
        const rawTables = tables;
        return {
            accounts: {
                async create(params) {
                    const account = {
                        id: generateId().toString(),
                        type: params.type,
                        email: params.email,
                    };
                    await tables.accounts.create(account);
                    return respond(account);
                },
                async retrieve(id) {
                    const account = await tables.accounts.one(find({ id }));
                    return respond(account);
                },
                async createLoginLink(id) {
                    const loginLink = {
                        created: Date.now(),
                        url: `https://fake.xiome.io/stripe-account-login-link`,
                    };
                    return respond(loginLink);
                },
            },
            accountLinks: {
                async create(params) {
                    const accountLink = {
                        url: `https://fake.xiome.io/stripe-account-setup`,
                    };
                    return respond(accountLink);
                },
            },
            account(stripeAccount) {
                async function webhookEvent(type, object) {
                    return webhooks[type]({
                        type,
                        data: { object },
                    });
                }
                const tables = dbbyConstrainTables({
                    tables: rawTables,
                    namespace: { "_connectedAccount": stripeAccount },
                });
                function ignoreUndefined(input) {
                    const output = {};
                    for (const [key, value] of Object.entries(input)) {
                        if (value !== undefined)
                            output[key] = value;
                    }
                    return output;
                }
                function prepMockResource(table) {
                    return {
                        create({ makeData, hook = async () => { } }) {
                            return async function (params) {
                                const resource = {
                                    id: generateId(),
                                    ...makeData(params),
                                };
                                await table.create(resource);
                                await hook(resource);
                                return respond(resource);
                            };
                        },
                        retrieve() {
                            return async function (id) {
                                const resource = await table.one(find({ id }));
                                return respond(resource);
                            };
                        },
                        update({ makeData, hook = async () => { } }) {
                            return async function (id, params) {
                                await table.update({
                                    ...find({ id }),
                                    write: ignoreUndefined(makeData(params)),
                                });
                                const resource = await table.one(find({ id }));
                                await hook(resource);
                                return respond(resource);
                            };
                        },
                        delete() {
                            return async function (id) {
                                await table.delete(find({ id }));
                            };
                        },
                    };
                }
                function mockResource({ table, createData, updateData, createHook, updateHook, }) {
                    const context = prepMockResource(table);
                    return {
                        create: context.create({
                            makeData: createData,
                            hook: createHook,
                        }),
                        retrieve: context.retrieve(),
                        update: context.update({
                            makeData: updateData,
                            hook: updateHook,
                        }),
                        delete: context.delete(),
                    };
                }
                return {
                    customers: mockResource({
                        table: tables.customers,
                        createData: params => ({
                            email: params.email,
                            invoice_settings: params.invoice_settings
                                ?? { default_payment_method: undefined },
                        }),
                        updateData: params => ({
                            email: params.email,
                            invoice_settings: params.invoice_settings,
                        }),
                    }),
                    products: mockResource({
                        table: tables.products,
                        createData: params => ({
                            name: params.name,
                            description: params.description,
                        }),
                        updateData: params => ({
                            name: params.name,
                            description: params.description,
                        }),
                    }),
                    prices: mockResource({
                        table: tables.prices,
                        createData: params => ({
                            product: params.product,
                            currency: params.currency,
                            unit_amount: params.unit_amount,
                            recurring: params.recurring,
                        }),
                        updateData: params => ({
                            active: params.active,
                        }),
                    }),
                    checkout: {
                        sessions: mockResource({
                            table: tables.checkoutSessions,
                            createData: params => ({
                                customer: params.customer,
                            }),
                            updateData: params => ({}),
                            createHook: async (session) => {
                                await webhookEvent("checkout.session.completed", session);
                            },
                            updateHook: async (session) => {
                                await webhookEvent("checkout.session.completed", session);
                            },
                        }),
                    },
                    paymentMethods: mockResource({
                        table: tables.paymentMethods,
                        createData: params => ({
                            type: params.type,
                            customer: params.customer,
                        }),
                        updateData: params => ({}),
                    }),
                    setupIntents: mockResource({
                        table: tables.setupIntents,
                        createData: params => ({
                            customer: params.customer,
                            payment_method: params.payment_method,
                            usage: params.usage,
                        }),
                        updateData: params => ({
                            payment_method: params.payment_method,
                        }),
                    }),
                    subscriptions: mockResource({
                        table: tables.subscriptions,
                        createData: params => ({
                            customer: params.customer,
                            default_payment_method: params.default_payment_method,
                            cancel_at_period_end: params.cancel_at_period_end,
                            items: {
                                url: "",
                                object: "list",
                                has_more: false,
                                data: params.items.map(itemParams => ({
                                    id: generateId(),
                                    billing_thresholds: itemParams.billing_thresholds,
                                    price: itemParams.price,
                                    price_data: itemParams.price_data,
                                    quantity: itemParams.quantity,
                                    tax_rates: itemParams.tax_rates,
                                })),
                            },
                        }),
                        updateData: params => ({
                            cancel_at_period_end: params.cancel_at_period_end,
                            default_payment_method: params.default_payment_method,
                        }),
                        updateHook: async (subscription) => {
                            await webhookEvent("customer.subscription.updated", subscription);
                        },
                    }),
                };
            }
        };
    }

    async function mockStripeTables({ tableStorage }) {
        const spec = {
            prices: undefined,
            accounts: undefined,
            products: undefined,
            customers: undefined,
            setupIntents: undefined,
            subscriptions: undefined,
            paymentMethods: undefined,
            checkoutSessions: undefined,
        };
        const tables = await concurrent(objectMap2(spec, (value, key) => dbbyX(tableStorage, `mock-stripe-${key}`)));
        return tables;
    }

    async function mockStripeCircuit({ rando, tableStorage, authTables, storeTables, }) {
        const { publishers: webhookPublishers, subscribers: webhookSubscribers, } = pubsubs({
            "checkout.session.completed": pubsub(),
            "invoice.paid": pubsub(),
            "invoice.payment_failed": pubsub(),
            "customer.subscription.updated": pubsub(),
        });
        const stripeTables = await mockStripeTables({ tableStorage });
        const stripeLiaison = mockStripeLiaison({
            rando,
            tables: stripeTables,
            webhooks: webhookPublishers,
        });
        const webhooks = stripeWebhooks({
            authTables,
            storeTables,
            stripeLiaison,
            logger: console,
        });
        for (const [key, subscribe] of Object.entries(webhookSubscribers))
            subscribe(webhooks[key].bind(webhooks));
        return {
            stripeLiaison,
            mockStripeOperations: {
                async linkStripeAccount(stripeAccountId) {
                    await stripeTables.accounts.update({
                        ...find({ id: stripeAccountId }),
                        write: {
                            email: "fake-stripe-account-email@xiome.io",
                            charges_enabled: true,
                            payouts_enabled: true,
                            details_submitted: true,
                        },
                    });
                },
                async linkStripeAccountThatIsIncomplete(stripeAccountId) {
                    await stripeTables.accounts.update({
                        ...find({ id: stripeAccountId }),
                        write: {
                            charges_enabled: false,
                            payouts_enabled: false,
                            details_submitted: false,
                        },
                    });
                },
                // async purchaseSubscription(stripeAccountId: string) {},
            },
        };
    }

    async function assimilateStripe({ database, mockStorage, config, rando, }) {
        if (config.stripe === "mock-mode") {
            return mockStripeCircuit({
                rando,
                tableStorage: mockStorage,
                authTables: database.auth,
                storeTables: database.store,
            });
        }
        else {
            throw new Error("real stripe not implemented");
        }
    }

    function mockDacastClient({ goodApiKey }) {
        let count = 1;
        function fakeContent(type) {
            const id = count++;
            return {
                online: true,
                id: `${type}-${id.toString()}`,
                title: `content ${id}`,
                creation_date: "1999-12-25",
            };
        }
        function fakeEmbedCode(type) {
            return type === "iframe"
                ? `<iframe src="https://iframe.dacast.com/vod/0ffd60be-91b7-22b0-1353-7dba7af43261/e9cc39f7-83ea-19db-2c0e-672beeec1547" width="100%" height="100%" frameborder="0" scrolling="no" allow="autoplay" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>`
                : `<script id="0ffd60be-91b7-22b0-1353-7dba7af43261-vod-e9cc39f7-83ea-19db-2c0e-672beeec1547" width="100%" height="100%" src="https://player.dacast.com/js/player.js?contentId=0ffd60be-91b7-22b0-1353-7dba7af43261-vod-e9cc39f7-83ea-19db-2c0e-672beeec1547"  class="dacast-video"></script>`;
        }
        const data = {
            vods: [0, 0].map(() => fakeContent("vod")),
            channels: [0, 0].map(() => fakeContent("channel")),
            playlists: [0, 0].map(() => fakeContent("playlist")),
        };
        return ({ apiKey }) => {
            function resource(content) {
                function fun(f) {
                    return ((...args) => {
                        if (apiKey !== goodApiKey)
                            throw new Error("mock dacast invalid api key");
                        return f(...args);
                    });
                }
                function paginate(content) {
                    return {
                        totalCount: content.length.toString(),
                        data: content,
                        paging: {
                            last: "",
                            next: "",
                            previous: "",
                            self: "",
                        },
                    };
                }
                return {
                    get: fun(async () => paginate(content)),
                    id: (contentId) => ({
                        get: fun(async () => content.find(c => c.id === contentId)),
                        embed: (embedType) => ({
                            get: fun(async () => ({ code: fakeEmbedCode(embedType) })),
                        }),
                    }),
                };
            }
            return {
                vods: resource(data.vods),
                channels: resource(data.channels),
                playlists: resource(data.playlists),
            };
        };
    }

    function mockVerifyDacastApiKey({ goodApiKey }) {
        return async (apiKey) => apiKey === goodApiKey;
    }

    function mockDacastSdk({ goodApiKey }) {
        const getClient = apiKey => mockDacastClient({ goodApiKey })({ apiKey });
        return {
            getClient,
            verifyApiKey: mockVerifyDacastApiKey({ goodApiKey }),
        };
    }

    function assimilateDacast({ config, configureDacast, }) {
        if (config.dacast === "mock-mode") {
            return mockDacastSdk({ goodApiKey });
        }
        else if (config.dacast === true) {
            return configureDacast();
        }
        else {
            throw new Error("unknown dacast config");
        }
    }

    function isPlainObject(x) {
        return (typeof x === "object"
            && x !== null
            && !Array.isArray(x)
            && !(x instanceof Promise));
    }
    function unzipRecursive(object, path = []) {
        let spec = [];
        for (const [key, value] of Object.entries(object)) {
            if (isPlainObject(value))
                spec = [
                    ...spec,
                    ...unzipRecursive(value, [...path, key])
                ];
            else
                spec.push([[...path, key], value]);
        }
        return spec;
    }
    function unzip(object) {
        return unzipRecursive(object);
    }
    async function waitSpec(spec) {
        const paths = [];
        const awaitables = [];
        for (const [path, value] of spec) {
            paths.push(path);
            awaitables.push(value);
        }
        const values = await Promise.all(awaitables);
        return paths.map((path, index) => [path, values[index]]);
    }
    function applyProperty(object, path, value) {
        let level = object;
        for (let i = 0; i < path.length; i++) {
            const final = i === (path.length - 1);
            const key = path[i];
            const existing = level[key];
            if (final)
                level[key] = value;
            else {
                const existingIsObject = isPlainObject(existing);
                if (existingIsObject)
                    level = existing;
                else {
                    const next = {};
                    level[key] = next;
                    level = next;
                }
            }
        }
    }
    function zip(spec) {
        const result = {};
        for (const [path, value] of spec)
            applyProperty(result, path, value);
        return result;
    }
    async function waitForProperties(input) {
        const specWithPromises = unzip(input);
        const specWithValues = await waitSpec(specWithPromises);
        return zip(specWithValues);
    }

    function processBlueprintRecursive({ blueprint, path = [], process, }) {
        return objectMap2(blueprint, (value, key) => (value === true
            ? process([...path, key])
            : processBlueprintRecursive({
                blueprint: value,
                path: [...path, key],
                process,
            })));
    }
    function processBlueprint({ blueprint, process }) {
        return processBlueprintRecursive({ blueprint, process });
    }

    async function dbbyMemory(rows) {
        const table = await dbbyX(memoryFlexStorage(), "");
        if (rows)
            await table.create(...rows);
        return table;
    }

    function dbbyHardback({ frontTable, backTable }) {
        async function one(options) {
            return await backTable.one(options) ?? await frontTable.one(options);
        }
        return {
            [_dbbyTableSymbol]: true,
            one,
            create: frontTable.create,
            update: frontTable.update,
            delete: frontTable.delete,
            async read(options) {
                const [hardRows, actualRows] = await Promise.all([
                    backTable.read(options),
                    await frontTable.read(options),
                ]);
                return [...hardRows, ...actualRows];
            },
            async assert(options) {
                const row = await one(options);
                return row || await (async () => {
                    const newRow = await options.make();
                    await frontTable.create(newRow);
                    return newRow;
                })();
            },
            async count(options) {
                const [hardCount, actualCount] = await Promise.all([
                    backTable.count(options),
                    frontTable.count(options),
                ]);
                return hardCount + actualCount;
            },
        };
    }

    async function assimilateDatabase({ config, configureMongo, configureMockStorage, }) {
        const blueprintForRawDatabase = {
            apps: {
                registrations: true,
                owners: true,
            },
        };
        const blueprintForNamespacedDatabase = {
            auth: {
                users: {
                    accounts: true,
                    emails: true,
                    latestLogins: true,
                    profiles: true,
                },
                permissions: {
                    privilege: true,
                    role: true,
                    roleHasPrivilege: true,
                    userHasRole: true,
                },
            },
            example: {
                examplePosts: true,
            },
            questions: {
                likes: true,
                reports: true,
                answerPosts: true,
                questionPosts: true,
            },
            store: {
                // TODO store
                // billing: {
                // 	customers: true,
                // 	storeInfo: true,
                // 	subscriptionPlans: true,
                // 	subscriptions: true,
                // },
                merchant: {
                    stripeAccounts: true,
                },
                subscription: {
                    plans: true,
                    tiers: true,
                },
            },
            videos: {
                dacastAccountLinks: true,
                viewDacast: true,
                viewPrivileges: true,
            },
            notes: {
                notes: true,
                questionDetails: true,
            },
        };
        async function mockWithStorage(mockStorage) {
            const databaseRaw = await waitForProperties(processBlueprint({
                blueprint: blueprintForRawDatabase,
                process: path => dbbyX(mockStorage, path.join("-")),
            }));
            const databaseUnconstrained = await (async () => {
                const databaseNamespaced = await waitForProperties(processBlueprint({
                    blueprint: blueprintForNamespacedDatabase,
                    process: path => dbbyX(mockStorage, path.join("-")),
                }));
                return objectMap(databaseNamespaced, value => new UnconstrainedTables(value));
            })();
            return {
                mockStorage,
                database: {
                    ...databaseRaw,
                    ...databaseUnconstrained,
                }
            };
        }
        const results = config.database === "mock-storage"
            ? await mockWithStorage(configureMockStorage())
            : await configureMongo({
                blueprintForRawDatabase,
                blueprintForNamespacedDatabase,
                config: { ...config, database: config.database },
            });
        const bakedAppTables = await (async () => {
            const platformApp = config.platform.appDetails;
            const { apps: appTables } = results.database;
            return {
                ...appTables,
                registrations: dbbyHardback({
                    frontTable: appTables.registrations,
                    backTable: await dbbyMemory([
                        {
                            appId: DamnId.fromString(platformApp.appId),
                            home: platformApp.home,
                            label: platformApp.label,
                            origins: originsToDatabase(platformApp.origins),
                            archived: false,
                        }
                    ])
                }),
            };
        })();
        return {
            database: {
                ...results.database,
                apps: bakedAppTables,
            },
            mockStorage: results.mockStorage,
        };
    }

    function makeNotesDepositBox({ rando, notesTables }) {
        async function sendNotes(drafts) {
            const notes = drafts.map(draft => {
                const noteId = rando.randomId();
                return {
                    noteBase: {
                        ...draft,
                        noteId,
                        to: DamnId.fromString(draft.to),
                        from: draft.from === undefined
                            ? undefined
                            : DamnId.fromString(draft.from),
                        old: false,
                        time: Date.now(),
                    },
                    noteDetails: draft.details,
                };
            });
            await notesTables.notes.create(...notes.map(n => n.noteBase));
            return notes.map(({ noteBase: { noteId } }) => ({
                noteId: noteId.toString()
            }));
        }
        async function sendNote(draft) {
            const [sent] = await sendNotes([draft]);
            return sent;
        }
        return {
            sendNotes,
            sendNote,
        };
    }

    function prepareBackend(configurators) {
        return async function configureApi(config) {
            const rando = await getRando();
            const options = { ...configurators, config, rando };
            const emails = assimilateEmails(options);
            const { database, mockStorage } = await assimilateDatabase(options);
            const { signToken, verifyToken } = assimilateCrypto(options);
            const { stripeLiaison, mockStripeOperations } = await assimilateStripe({
                ...options,
                database,
                mockStorage,
            });
            const dacastSdk = assimilateDacast(options);
            const api = await assimilateApi({
                ...options,
                database,
                dacastSdk,
                signToken,
                verifyToken,
                sendLoginEmail: emails.sendLoginEmail,
            });
            return {
                rando,
                api,
                config,
                emails,
                database,
                stripeLiaison,
                mockStripeOperations,
                platformAppId: config.platform.appDetails.appId,
                prepareNotesDepositBox: (appId) => makeNotesDepositBox({
                    rando,
                    notesTables: database.notes.namespaceForApp(appId),
                }),
                mockBrowser: async () => mockBrowser({
                    api,
                    mockStripeOperations,
                    appOrigin: "http://localhost:5000",
                }),
            };
        };
    }

    class ConfigNotSupportedInBrowserError extends Error {
        constructor(message) {
            super(message);
        }
    }
    function nope(message) {
        return function () {
            throw new ConfigNotSupportedInBrowserError(message);
        };
    }
    const backendForBrowser = (storage) => prepareBackend({
        configureMongo: nope("config.database.mongo not supported in browser"),
        configureMailgun: nope("config.email.mailgun not supported in browser"),
        configureTokenFunctions: nope("config.crypto.keys must be 'mock-mode' in browser"),
        configureMockStorage: () => storage,
        configureDacast: nope("config.dacast must be in 'mock-mode' in browser"),
    });

    async function mockConnectApp({ appOrigin, origins, storage, appWindowLink, }) {
        const backend = await backendForBrowser(storage)(mockConfig({
            platformHome: appWindowLink,
            platformOrigins: origins,
        }));
        backend.emails.disableEmails();
        const ownerEmail = "creative@xiome.io";
        const adminEmail = "admin@xiome.io";
        let appId = await storage.read("mock-app");
        if (!appId) {
            appId = await mockRegisterApp({
                backend,
                ownerEmail,
                adminEmail,
                appOrigins: origins,
            });
            await storage.write("mock-app", appId);
        }
        console.log(`mock: app owner email "${ownerEmail}"`);
        backend.emails.enableEmails();
        const { remote, authMediator, setMockLatency } = await mockWiredRemote({
            appId,
            backend,
            storage,
            appOrigin,
        });
        const popups = mockPopups({
            mockStripeOperations: backend.mockStripeOperations,
        });
        const chatConnect = await chatMockClientEntirely(storage);
        // const chatConnect = chatSocketClient("ws://localhost:8001/")
        return { appId, remote, storage, authMediator, backend, popups, setMockLatency, chatConnect };
    }

    async function mockConnectPlatform({ platformHome, storage, }) {
        const appOrigin = new URL(platformHome).origin;
        const backend = await backendForBrowser(storage)(mockConfig({
            platformHome,
            platformOrigins: [appOrigin],
        }));
        const appId = backend.platformAppId;
        const { remote, authMediator, setMockLatency } = await mockWiredRemote({
            appId,
            backend,
            storage,
            appOrigin,
        });
        const popups = mockPopups({
            mockStripeOperations: backend.mockStripeOperations,
        });
        const chatConnect = await chatMockClientEntirely(storage);
        // const chatConnect = chatSocketClient("ws://localhost:8001/")
        return { appId, remote, storage, authMediator, backend, popups, setMockLatency, chatConnect };
    }

    function jsonStorage(storage) {
        return {
            read(key) {
                let data = undefined;
                const raw = storage.getItem(key);
                if (raw) {
                    try {
                        data = JSON.parse(raw);
                    }
                    catch (error) {
                        storage.removeItem(key);
                    }
                }
                return data;
            },
            write(key, data) {
                const json = JSON.stringify(data);
                storage.setItem(key, json);
            },
            delete(key) {
                storage.removeItem(key);
            },
        };
    }

    function simpleFlexStorage(storage) {
        const json = jsonStorage(storage);
        return {
            async read(key) {
                return json.read(key);
            },
            async write(key, data) {
                return json.write(key, data);
            },
            async delete(key) {
                return json.delete(key);
            },
        };
    }

    async function mockConnect(config) {
        const options = {
            origins: [window.location.origin],
            appOrigin: window.location.origin,
            storage: simpleFlexStorage(window.localStorage),
            platformHome: window.location.href,
            appWindowLink: window.location.href,
        };
        return config.mode === "platform"
            ? await mockConnectPlatform(options)
            : await mockConnectApp(options);
    }

    const nap = (milliseconds = 0) => new Promise(resolve => setTimeout(resolve, milliseconds));

    function hitchie(func, process) {
        return ((...args) => process(func, ...args));
    }

    function applyMockHacks({ connection, frontend }) {
        const { loginService } = connection.remote.auth.users;
        loginService.sendLoginLink = hitchie(loginService.sendLoginLink, async (func, ...args) => {
            await func(...args);
            const details = connection.backend.emails.recallLatestLoginEmail();
            console.log("mock: logging in...");
            await nap(1000);
            await frontend.models.accessModel.login(details.loginToken);
            console.log(`mock: logged in as ${details.to}`);
        });
        connection.popups.triggerStripeConnectPopup = hitchie(connection.popups.triggerStripeConnectPopup, async (...args) => {
            console.log("mock: bank popup", args);
        });
        const notesDepositBox = connection.backend.prepareNotesDepositBox(DamnId.fromString(frontend.appId));
        window["fakeNote"] = async (draft) => {
            const userId = frontend.models.accessModel.getAccess()?.user?.userId;
            const augmentedDraft = {
                from: undefined,
                details: {},
                text: "this is a message note "
                    + connection.backend.rando.randomId().toString().slice(0, 8),
                title: "this is a message title "
                    + connection.backend.rando.randomId().toString().slice(0, 8),
                type: "message",
                to: userId,
                ...draft,
            };
            if (!augmentedDraft.to)
                console.warn("who do you want to send this note to?\n('to' user id was not provided)");
            else {
                const { noteId } = await notesDepositBox.sendNote(augmentedDraft);
                console.log(`note sent! ${noteId}`);
            }
        };
    }

    /**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$1=window.ShadowRoot&&(void 0===window.ShadyCSS||window.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,e$3=Symbol(),n$3=new Map;class s$3{constructor(t,n){if(this._$cssResult$=!0,n!==e$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t;}get styleSheet(){let e=n$3.get(this.cssText);return t$1&&void 0===e&&(n$3.set(this.cssText,e=new CSSStyleSheet),e.replaceSync(this.cssText)),e}toString(){return this.cssText}}const o$4=t=>new s$3("string"==typeof t?t:t+"",e$3),r$2=(t,...n)=>{const o=1===t.length?t[0]:n.reduce(((e,n,s)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(n)+t[s+1]),t[0]);return new s$3(o,e$3)},i$3=(e,n)=>{t$1?e.adoptedStyleSheets=n.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):n.forEach((t=>{const n=document.createElement("style"),s=window.litNonce;void 0!==s&&n.setAttribute("nonce",s),n.textContent=t.cssText,e.appendChild(n);}));},S$1=t$1?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const n of t.cssRules)e+=n.cssText;return o$4(e)})(t):t;

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var s$2;const e$2=window.trustedTypes,r$1=e$2?e$2.emptyScript:"",h$1=window.reactiveElementPolyfillSupport,o$3={toAttribute(t,i){switch(i){case Boolean:t=t?r$1:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,i){let s=t;switch(i){case Boolean:s=null!==t;break;case Number:s=null===t?null:Number(t);break;case Object:case Array:try{s=JSON.parse(t);}catch(t){s=null;}}return s}},n$2=(t,i)=>i!==t&&(i==i||t==t),l$2={attribute:!0,type:String,converter:o$3,reflect:!1,hasChanged:n$2};class a$1 extends HTMLElement{constructor(){super(),this._$Et=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Ei=null,this.o();}static addInitializer(t){var i;null!==(i=this.l)&&void 0!==i||(this.l=[]),this.l.push(t);}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((i,s)=>{const e=this._$Eh(s,i);void 0!==e&&(this._$Eu.set(e,s),t.push(e));})),t}static createProperty(t,i=l$2){if(i.state&&(i.attribute=!1),this.finalize(),this.elementProperties.set(t,i),!i.noAccessor&&!this.prototype.hasOwnProperty(t)){const s="symbol"==typeof t?Symbol():"__"+t,e=this.getPropertyDescriptor(t,s,i);void 0!==e&&Object.defineProperty(this.prototype,t,e);}}static getPropertyDescriptor(t,i,s){return {get(){return this[i]},set(e){const r=this[t];this[i]=e,this.requestUpdate(t,r,s);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||l$2}static finalize(){if(this.hasOwnProperty("finalized"))return !1;this.finalized=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),this.elementProperties=new Map(t.elementProperties),this._$Eu=new Map,this.hasOwnProperty("properties")){const t=this.properties,i=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const s of i)this.createProperty(s,t[s]);}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(i){const s=[];if(Array.isArray(i)){const e=new Set(i.flat(1/0).reverse());for(const i of e)s.unshift(S$1(i));}else void 0!==i&&s.push(S$1(i));return s}static _$Eh(t,i){const s=i.attribute;return !1===s?void 0:"string"==typeof s?s:"string"==typeof t?t.toLowerCase():void 0}o(){var t;this._$Ep=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$Em(),this.requestUpdate(),null===(t=this.constructor.l)||void 0===t||t.forEach((t=>t(this)));}addController(t){var i,s;(null!==(i=this._$Eg)&&void 0!==i?i:this._$Eg=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(s=t.hostConnected)||void 0===s||s.call(t));}removeController(t){var i;null===(i=this._$Eg)||void 0===i||i.splice(this._$Eg.indexOf(t)>>>0,1);}_$Em(){this.constructor.elementProperties.forEach(((t,i)=>{this.hasOwnProperty(i)&&(this._$Et.set(i,this[i]),delete this[i]);}));}createRenderRoot(){var t;const s=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return i$3(s,this.constructor.elementStyles),s}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostConnected)||void 0===i?void 0:i.call(t)}));}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostDisconnected)||void 0===i?void 0:i.call(t)}));}attributeChangedCallback(t,i,s){this._$AK(t,s);}_$ES(t,i,s=l$2){var e,r;const h=this.constructor._$Eh(t,s);if(void 0!==h&&!0===s.reflect){const n=(null!==(r=null===(e=s.converter)||void 0===e?void 0:e.toAttribute)&&void 0!==r?r:o$3.toAttribute)(i,s.type);this._$Ei=t,null==n?this.removeAttribute(h):this.setAttribute(h,n),this._$Ei=null;}}_$AK(t,i){var s,e,r;const h=this.constructor,n=h._$Eu.get(t);if(void 0!==n&&this._$Ei!==n){const t=h.getPropertyOptions(n),l=t.converter,a=null!==(r=null!==(e=null===(s=l)||void 0===s?void 0:s.fromAttribute)&&void 0!==e?e:"function"==typeof l?l:null)&&void 0!==r?r:o$3.fromAttribute;this._$Ei=n,this[n]=a(i,t.type),this._$Ei=null;}}requestUpdate(t,i,s){let e=!0;void 0!==t&&(((s=s||this.constructor.getPropertyOptions(t)).hasChanged||n$2)(this[t],i)?(this._$AL.has(t)||this._$AL.set(t,i),!0===s.reflect&&this._$Ei!==t&&(void 0===this._$E_&&(this._$E_=new Map),this._$E_.set(t,s))):e=!1),!this.isUpdatePending&&e&&(this._$Ep=this._$EC());}async _$EC(){this.isUpdatePending=!0;try{await this._$Ep;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this._$Et&&(this._$Et.forEach(((t,i)=>this[i]=t)),this._$Et=void 0);let i=!1;const s=this._$AL;try{i=this.shouldUpdate(s),i?(this.willUpdate(s),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostUpdate)||void 0===i?void 0:i.call(t)})),this.update(s)):this._$EU();}catch(t){throw i=!1,this._$EU(),t}i&&this._$AE(s);}willUpdate(t){}_$AE(t){var i;null===(i=this._$Eg)||void 0===i||i.forEach((t=>{var i;return null===(i=t.hostUpdated)||void 0===i?void 0:i.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$EU(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$Ep}shouldUpdate(t){return !0}update(t){void 0!==this._$E_&&(this._$E_.forEach(((t,i)=>this._$ES(i,this[i],t))),this._$E_=void 0),this._$EU();}updated(t){}firstUpdated(t){}}a$1.finalized=!0,a$1.elementProperties=new Map,a$1.elementStyles=[],a$1.shadowRootOptions={mode:"open"},null==h$1||h$1({ReactiveElement:a$1}),(null!==(s$2=globalThis.reactiveElementVersions)&&void 0!==s$2?s$2:globalThis.reactiveElementVersions=[]).push("1.1.1");

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var t;const i$2=globalThis.trustedTypes,s$1=i$2?i$2.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$1=`lit$${(Math.random()+"").slice(9)}$`,o$2="?"+e$1,n$1=`<${o$2}>`,l$1=document,h=(t="")=>l$1.createComment(t),r=t=>null===t||"object"!=typeof t&&"function"!=typeof t,d=Array.isArray,u=t=>{var i;return d(t)||"function"==typeof(null===(i=t)||void 0===i?void 0:i[Symbol.iterator])},c=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,a=/>/g,f=/>|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g,_=/'/g,m=/"/g,g=/^(?:script|style|textarea)$/i,p=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),$=p(1),y=p(2),b=Symbol.for("lit-noChange"),w=Symbol.for("lit-nothing"),T=new WeakMap,x=(t,i,s)=>{var e,o;const n=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new N(i.insertBefore(h(),t),t,void 0,null!=s?s:{});}return l._$AI(t),l},A=l$1.createTreeWalker(l$1,129,null,!1),C=(t,i)=>{const o=t.length-1,l=[];let h,r=2===i?"<svg>":"",d=c;for(let i=0;i<o;i++){const s=t[i];let o,u,p=-1,$=0;for(;$<s.length&&(d.lastIndex=$,u=d.exec(s),null!==u);)$=d.lastIndex,d===c?"!--"===u[1]?d=v:void 0!==u[1]?d=a:void 0!==u[2]?(g.test(u[2])&&(h=RegExp("</"+u[2],"g")),d=f):void 0!==u[3]&&(d=f):d===f?">"===u[0]?(d=null!=h?h:c,p=-1):void 0===u[1]?p=-2:(p=d.lastIndex-u[2].length,o=u[1],d=void 0===u[3]?f:'"'===u[3]?m:_):d===m||d===_?d=f:d===v||d===a?d=c:(d=f,h=void 0);const y=d===f&&t[i+1].startsWith("/>")?" ":"";r+=d===c?s+n$1:p>=0?(l.push(o),s.slice(0,p)+"$lit$"+s.slice(p)+e$1+y):s+e$1+(-2===p?(l.push(void 0),i):y);}const u=r+(t[o]||"<?>")+(2===i?"</svg>":"");if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return [void 0!==s$1?s$1.createHTML(u):u,l]};class E{constructor({strings:t,_$litType$:s},n){let l;this.parts=[];let r=0,d=0;const u=t.length-1,c=this.parts,[v,a]=C(t,s);if(this.el=E.createElement(v,n),A.currentNode=this.el.content,2===s){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes);}for(;null!==(l=A.nextNode())&&c.length<u;){if(1===l.nodeType){if(l.hasAttributes()){const t=[];for(const i of l.getAttributeNames())if(i.endsWith("$lit$")||i.startsWith(e$1)){const s=a[d++];if(t.push(i),void 0!==s){const t=l.getAttribute(s.toLowerCase()+"$lit$").split(e$1),i=/([.?@])?(.*)/.exec(s);c.push({type:1,index:r,name:i[2],strings:t,ctor:"."===i[1]?M:"?"===i[1]?H:"@"===i[1]?I:S});}else c.push({type:6,index:r});}for(const i of t)l.removeAttribute(i);}if(g.test(l.tagName)){const t=l.textContent.split(e$1),s=t.length-1;if(s>0){l.textContent=i$2?i$2.emptyScript:"";for(let i=0;i<s;i++)l.append(t[i],h()),A.nextNode(),c.push({type:2,index:++r});l.append(t[s],h());}}}else if(8===l.nodeType)if(l.data===o$2)c.push({type:2,index:r});else {let t=-1;for(;-1!==(t=l.data.indexOf(e$1,t+1));)c.push({type:7,index:r}),t+=e$1.length-1;}r++;}}static createElement(t,i){const s=l$1.createElement("template");return s.innerHTML=t,s}}function P(t,i,s=t,e){var o,n,l,h;if(i===b)return i;let d=void 0!==e?null===(o=s._$Cl)||void 0===o?void 0:o[e]:s._$Cu;const u=r(i)?void 0:i._$litDirective$;return (null==d?void 0:d.constructor)!==u&&(null===(n=null==d?void 0:d._$AO)||void 0===n||n.call(d,!1),void 0===u?d=void 0:(d=new u(t),d._$AT(t,s,e)),void 0!==e?(null!==(l=(h=s)._$Cl)&&void 0!==l?l:h._$Cl=[])[e]=d:s._$Cu=d),void 0!==d&&(i=P(t,d._$AS(t,i.values),d,e)),i}class V{constructor(t,i){this.v=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}p(t){var i;const{el:{content:s},parts:e}=this._$AD,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:l$1).importNode(s,!0);A.currentNode=o;let n=A.nextNode(),h=0,r=0,d=e[0];for(;void 0!==d;){if(h===d.index){let i;2===d.type?i=new N(n,n.nextSibling,this,t):1===d.type?i=new d.ctor(n,d.name,d.strings,this,t):6===d.type&&(i=new L(n,this,t)),this.v.push(i),d=e[++r];}h!==(null==d?void 0:d.index)&&(n=A.nextNode(),h++);}return o}m(t){let i=0;for(const s of this.v)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class N{constructor(t,i,s,e){var o;this.type=2,this._$AH=w,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cg=null===(o=null==e?void 0:e.isConnected)||void 0===o||o;}get _$AU(){var t,i;return null!==(i=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==i?i:this._$Cg}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=P(this,t,i),r(t)?t===w||null==t||""===t?(this._$AH!==w&&this._$AR(),this._$AH=w):t!==this._$AH&&t!==b&&this.$(t):void 0!==t._$litType$?this.T(t):void 0!==t.nodeType?this.S(t):u(t)?this.A(t):this.$(t);}M(t,i=this._$AB){return this._$AA.parentNode.insertBefore(t,i)}S(t){this._$AH!==t&&(this._$AR(),this._$AH=this.M(t));}$(t){this._$AH!==w&&r(this._$AH)?this._$AA.nextSibling.data=t:this.S(l$1.createTextNode(t)),this._$AH=t;}T(t){var i;const{values:s,_$litType$:e}=t,o="number"==typeof e?this._$AC(t):(void 0===e.el&&(e.el=E.createElement(e.h,this.options)),e);if((null===(i=this._$AH)||void 0===i?void 0:i._$AD)===o)this._$AH.m(s);else {const t=new V(o,this),i=t.p(this.options);t.m(s),this.S(i),this._$AH=t;}}_$AC(t){let i=T.get(t.strings);return void 0===i&&T.set(t.strings,i=new E(t)),i}A(t){d(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const o of t)e===i.length?i.push(s=new N(this.M(h()),this.M(h()),this,this.options)):s=i[e],s._$AI(o),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){var i;void 0===this._$AM&&(this._$Cg=t,null===(i=this._$AP)||void 0===i||i.call(this,t));}}class S{constructor(t,i,s,e,o){this.type=1,this._$AH=w,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=o,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=w;}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,i=this,s,e){const o=this.strings;let n=!1;if(void 0===o)t=P(this,t,i,0),n=!r(t)||t!==this._$AH&&t!==b,n&&(this._$AH=t);else {const e=t;let l,h;for(t=o[0],l=0;l<o.length-1;l++)h=P(this,e[s+l],i,l),h===b&&(h=this._$AH[l]),n||(n=!r(h)||h!==this._$AH[l]),h===w?t=w:t!==w&&(t+=(null!=h?h:"")+o[l+1]),this._$AH[l]=h;}n&&!e&&this.k(t);}k(t){t===w?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"");}}class M extends S{constructor(){super(...arguments),this.type=3;}k(t){this.element[this.name]=t===w?void 0:t;}}const k=i$2?i$2.emptyScript:"";class H extends S{constructor(){super(...arguments),this.type=4;}k(t){t&&t!==w?this.element.setAttribute(this.name,k):this.element.removeAttribute(this.name);}}class I extends S{constructor(t,i,s,e,o){super(t,i,s,e,o),this.type=5;}_$AI(t,i=this){var s;if((t=null!==(s=P(this,t,i,0))&&void 0!==s?s:w)===b)return;const e=this._$AH,o=t===w&&e!==w||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,n=t!==w&&(e===w||o);o&&this.element.removeEventListener(this.name,this,e),n&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){var i,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t);}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){P(this,t);}}const z=window.litHtmlPolyfillSupport;null==z||z(E,N),(null!==(t=globalThis.litHtmlVersions)&&void 0!==t?t:globalThis.litHtmlVersions=[]).push("2.1.1");

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var l,o$1;class s extends a$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Dt=void 0;}createRenderRoot(){var t,e;const i=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=i.firstChild),i}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Dt=x(i,this.renderRoot,this.renderOptions);}connectedCallback(){var t;super.connectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!0);}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!1);}render(){return b}}s.finalized=!0,s._$litElement$=!0,null===(l=globalThis.litElementHydrateSupport)||void 0===l||l.call(globalThis,{LitElement:s});const n=globalThis.litElementPolyfillSupport;null==n||n({LitElement:s});(null!==(o$1=globalThis.litElementVersions)&&void 0!==o$1?o$1:globalThis.litElementVersions=[]).push("3.1.1");

    class AutowatcherCircularError extends Error {
        constructor(scheduled) {
            super(`an effect changes an observable, named "${scheduled.key}", that triggers that same effect, causing an infinite circle`);
        }
    }
    class AutowatcherLeakError extends Error {
        constructor(key) {
            super(`cannot set observable, named "${key}", outside a formalized action`);
        }
    }

    function autowatcherCore() {
        const context = {
            observableRecords: new Map(),
            newObservablesSchedule: [],
            activeAction: undefined,
            activeStakeout: undefined,
        };
        function obtainRecord(object) {
            if (context.observableRecords.has(object)) {
                return context.observableRecords.get(object);
            }
            else {
                const record = {};
                context.observableRecords.set(object, record);
                return record;
            }
        }
        function forbidCircularProblems(object, key) {
            const scheduled = context.newObservablesSchedule.find(s => s.object === object &&
                s.key === key);
            if (scheduled)
                throw new AutowatcherCircularError(scheduled);
        }
        function subscribe(subscription) {
            const { object, key, stakeout } = subscription;
            const record = obtainRecord(object);
            const stakeouts = record[key] ?? [];
            record[key] = [...stakeouts, stakeout];
            return { subscription, record };
        }
        function triggerObservation(object, key) {
            forbidCircularProblems(object, key);
            const record = obtainRecord(object);
            const stakeouts = record[key] ?? [];
            for (const { watcher, effect } of stakeouts) {
                if (effect)
                    effect(watcher());
                else
                    watcher();
            }
        }
        return {
            context,
            subscribe,
            triggerObservation,
        };
    }

    //
    // deprecated
    // now we prefer to use happystate
    //
    function autowatcher() {
        const { context, subscribe, triggerObservation } = autowatcherCore();
        function observable(object) {
            return new Proxy(object, {
                get(t, key) {
                    if (context.activeStakeout)
                        context.newObservablesSchedule.push({
                            object,
                            key,
                            stakeout: context.activeStakeout,
                        });
                    return object[key];
                },
                set(t, key, value) {
                    const oldValue = object[key];
                    object[key] = value;
                    const isChanged = value !== oldValue;
                    if (!context.activeAction)
                        throw new AutowatcherLeakError(key);
                    if (isChanged)
                        triggerObservation(object, key);
                    return true;
                },
            });
        }
        function track(stakeout) {
            let unsubscribe = () => { };
            let done = () => { };
            context.activeStakeout = stakeout;
            context.newObservablesSchedule = [];
            try {
                const initialObservation = stakeout.watcher();
                done = stakeout.effect
                    ? () => stakeout.effect(initialObservation)
                    : done;
                const recent = context.newObservablesSchedule
                    .map(scheduled => subscribe(scheduled));
                unsubscribe = () => {
                    for (const { subscription: { key }, record } of recent) {
                        const existingStakeouts = record[key] ?? [];
                        record[key] = existingStakeouts.filter(s => s !== stakeout);
                    }
                };
            }
            finally {
                context.activeStakeout = undefined;
                context.newObservablesSchedule = [];
                done();
            }
            return unsubscribe;
        }
        function watch(watcher, effect) {
            return track({ watcher, effect });
        }
        function runInAction(act) {
            context.activeAction = act;
            act();
            context.activeAction = undefined;
        }
        function action(act) {
            return ((...args) => {
                context.activeAction = act;
                const result = act(...args);
                context.activeAction = undefined;
                return result;
            });
        }
        function state(object) {
            for (const [key, value] of Object.entries(object)) {
                if (value !== null && typeof value === "object" && !Array.isArray(value))
                    object[key] = state(value);
            }
            return observable(object);
        }
        function actions(object) {
            return objectMap(object, value => {
                if (value !== null && typeof value === "object")
                    return actions(value);
                else if (typeof value === "function")
                    return action(value);
                else
                    return value;
            });
        }
        function dispose() {
            context.observableRecords = new Map();
        }
        // function setup<xState extends {}, xActions extends Actions>({
        // 		state: stateObject,
        // 		actions: actionsObject,
        // 	}: {
        // 		state: xState
        // 		actions: xActions
        // 	}) {
        // 	return {
        // 		state: state(stateObject),
        // 		actions: actions(actionsObject),
        // 	}
        // }
        return {
            observable,
            state,
            track,
            watch,
            action,
            actions,
            dispose,
            runInAction,
            // setup,
        };
    }

    var __classPrivateFieldGet$d = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$9 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    function mixinAutowatcher(Base) {
        var _unsubscribers, _a;
        return _a = class extends Base {
                constructor() {
                    super(...arguments);
                    this.auto = autowatcher();
                    _unsubscribers.set(this, []);
                    this.subscribeAutotrack = (track) => {
                        __classPrivateFieldGet$d(this, _unsubscribers, "f").push(track({
                            watcher: () => this.render(),
                            effect: () => this.requestUpdate(),
                        }));
                    };
                }
                render() { }
                firstUpdated(changes) {
                    this.subscribeAutotrack(this.auto.track);
                }
                dispose() {
                    for (const unsubscribe of __classPrivateFieldGet$d(this, _unsubscribers, "f"))
                        unsubscribe();
                    __classPrivateFieldSet$9(this, _unsubscribers, [], "f");
                    this.auto.dispose();
                }
            },
            _unsubscribers = new WeakMap(),
            _a;
    }

    function mixinInitiallyHidden(Base) {
        return class extends Base {
            connectedCallback() {
                super.connectedCallback();
                if (this.hasAttribute("initially-hidden"))
                    this.removeAttribute("initially-hidden");
            }
        };
    }

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const i$1=(i,e)=>"method"===e.kind&&e.descriptor&&!("value"in e.descriptor)?{...e,finisher(n){n.createProperty(e.key,i);}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:e.key,initializer(){"function"==typeof e.initializer&&(this[e.key]=e.initializer.call(this));},finisher(n){n.createProperty(e.key,i);}};function e(e){return (n,t)=>void 0!==t?((i,e,n)=>{e.constructor.createProperty(n,i);})(e,n,t):i$1(e,n)}

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const o=({finisher:e,descriptor:t})=>(o,n)=>{var r;if(void 0===n){const n=null!==(r=o.originalKey)&&void 0!==r?r:o.key,i=null!=t?{kind:"method",placement:"prototype",key:n,descriptor:t(o.key)}:{...o,key:n};return null!=e&&(i.finisher=function(t){e(t,n);}),i}{const r=o.constructor;void 0!==t&&Object.defineProperty(o,n,t(n)),null==e||e(r,n);}};

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */function i(i,n){return o({descriptor:o=>{const t={get(){var o,n;return null!==(n=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==n?n:null},enumerable:!0,configurable:!0};if(n){const n="symbol"==typeof o?Symbol():"__"+o;t.get=function(){var o,t;return void 0===this[n]&&(this[n]=null!==(t=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==t?t:null),this[n]};}return t}})}

    function arrayize(item) {
        return [item].flat();
    }
    const notUndefined = (x) => x !== undefined;
    function combineStyles(parentStyles, newStyles) {
        const styles = [
            ...(arrayize(parentStyles) ?? []),
            ...arrayize(newStyles),
        ];
        return styles
            .flat()
            .filter(notUndefined);
    }
    function mixinStyles(...newStyles) {
        return function (Base) {
            var _a;
            return _a = class extends Base {
                },
                _a.styles = combineStyles(Base.styles, newStyles),
                _a;
        };
    }

    const themeComponents = (theme, components) => {
        return objectMap(components, Component => mixinStyles(theme)(Component));
    };

    /**
     * Convert a camel-case name into a dashed name
     * - for example
     *       dashify("BigManStyle")
     *       //> "big-man-style"
     */
    function dashify(camel) {
        return camel.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
    }

    function registerComponents(components) {
        for (const [name, component] of Object.entries(components))
            customElements.define(dashify(name), component);
    }

    var __classPrivateFieldSet$8 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$c = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    function mixinHappy(...onStateChanges) {
        return function (Base) {
            var _unsubscribes, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _unsubscribes.set(this, []);
                    }
                    connectedCallback() {
                        super.connectedCallback();
                        const update = () => {
                            this.requestUpdate();
                        };
                        __classPrivateFieldSet$8(this, _unsubscribes, onStateChanges
                            .map(onStateChange => onStateChange(update)), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        for (const unsubscribe of __classPrivateFieldGet$c(this, _unsubscribes, "f"))
                            unsubscribe();
                        __classPrivateFieldSet$8(this, _unsubscribes, [], "f");
                    }
                },
                _unsubscribes = new WeakMap(),
                _a;
        };
    }

    function mixinFocusable(Base) {
        return class extends Base {
            connectedCallback() {
                super.connectedCallback();
                this.setAttribute("focusable", "");
            }
        };
    }

    var __classPrivateFieldGet$b = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$7 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    function mixinSnapstateSubscriptions(...subscriptions) {
        return function (Base) {
            var _unsubscribes_1, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _unsubscribes_1.set(this, []);
                    }
                    connectedCallback() {
                        super.connectedCallback();
                        const update = () => { this.requestUpdate(); };
                        __classPrivateFieldSet$7(this, _unsubscribes_1, subscriptions.map(subscription => subscription(update)), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        for (const unsubscribe of __classPrivateFieldGet$b(this, _unsubscribes_1, "f"))
                            unsubscribe();
                        __classPrivateFieldSet$7(this, _unsubscribes_1, [], "f");
                    }
                },
                _unsubscribes_1 = new WeakMap(),
                _a;
        };
    }

    function mixinShare(s) {
        return function (Base) {
            return class extends Base {
                get share() {
                    return s;
                }
            };
        };
    }

    var __classPrivateFieldSet$6 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$a = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    function mixinTicker(period) {
        return function (Base) {
            var _interval, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _interval.set(this, void 0);
                    }
                    tick() { }
                    connectedCallback() {
                        super.connectedCallback();
                        __classPrivateFieldSet$6(this, _interval, setInterval(() => {
                            this.tick();
                            this.requestUpdate();
                        }, period), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        clearInterval(__classPrivateFieldGet$a(this, _interval, "f"));
                    }
                },
                _interval = new WeakMap(),
                _a;
        };
    }

    var __classPrivateFieldGet$9 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$5 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _Component_subscriptions, _Component_unsubscribe;
    class Component extends mixinInitiallyHidden(s) {
        constructor() {
            super(...arguments);
            _Component_subscriptions.set(this, []);
            _Component_unsubscribe.set(this, () => { });
        }
        init() { }
        firstUpdated(changes) {
            super.firstUpdated(changes);
            this.init();
        }
        addSubscription(subscribe) {
            __classPrivateFieldGet$9(this, _Component_subscriptions, "f").push(subscribe);
        }
        subscribe() {
            const unsubscribes = __classPrivateFieldGet$9(this, _Component_subscriptions, "f").map(s => s());
            return () => unsubscribes.forEach(u => u());
        }
        connectedCallback() {
            super.connectedCallback();
            __classPrivateFieldSet$5(this, _Component_unsubscribe, this.subscribe(), "f");
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            __classPrivateFieldGet$9(this, _Component_unsubscribe, "f").call(this);
            __classPrivateFieldSet$5(this, _Component_unsubscribe, () => { }, "f");
        }
        render() {
            throw new Error("component render method not implemented");
        }
    }
    _Component_subscriptions = new WeakMap(), _Component_unsubscribe = new WeakMap();
    class ComponentWithShare extends Component {
        constructor() {
            super();
            if (this.share === undefined)
                throw new Error("component requires share");
        }
    }
    class AutowatcherComponent extends mixinAutowatcher(mixinInitiallyHidden(s)) {
        init() { }
        firstUpdated(changes) {
            this.init();
            super.firstUpdated(changes);
        }
    }
    class AutowatcherComponentWithShare extends AutowatcherComponent {
        constructor() {
            super();
            if (this.share === undefined)
                throw new Error("component requires share");
        }
    }

    var theme = r$2 `

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

*:focus {
	outline: var(--focus-outline, 3px solid cyan);
}

`;

    var styles$m = r$2 `

:host {
	display: inline-block;
	position: relative;
	width: 6em;
}

:host::before {
	opacity: 0;
	content: "copied!";
	display: block;
	position: absolute;
	top: -0.5em;
	right: -0.5em;
	background: #0a0c;
	padding: 0 0.5em;
	border-radius: 1em;
	pointer-events: none;
	z-index: 1;
}

:host(:not([copied]))::before {
	transition: opacity 500ms ease;
}

:host([copied])::before {
	opacity: 1;
}

button {
	font: inherit;
	color: inherit;
	background: transparent;
	width: 100%;
}

.container {
	position: relative;
	display: flex;
	flex-direction: row;
	user-select: none;
	cursor: pointer;
	border: none;
}

.content {
	display: flex;
	justify-content: row;
}

.label::after {
	content: ":";
	margin-right: 0.2em;
}

.id {
	opacity: 0.75;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
}

.copy svg {
	width: 1em;
	height: 1em;
}

.copy {
	opacity: 0.4;
	transition: opacity 100ms linear;
}

.container:hover .copy {
	opacity: 0.9;
}

.container:active .copy {
	opacity: 1;
}

`;

    var clipboardIcon = y `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clipboard"><path d="M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg>`;

    var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioId = class XioId extends AutowatcherComponent {
        constructor() {
            super(...arguments);
            this.copied = false;
        }
        async copy() {
            try {
                await navigator.clipboard.writeText(this.id);
                const activeElement = document.activeElement;
                if (activeElement)
                    activeElement.blur();
                if (this.copyTimeout) {
                    clearTimeout(this.copyTimeout);
                }
                this.copied = true;
                this.copyTimeout = setTimeout(() => {
                    this.copied = false;
                    this.copyTimeout = undefined;
                }, 1000);
            }
            catch (error) {
                console.error("failed to copy");
            }
        }
        render() {
            return $ `
			<button class=container @click=${this.copy}>
				<div class=id>${this.id}</div>
				<div class=copy>
					${clipboardIcon}
				</div>
			</button>
		`;
        }
    };
    __decorate$n([
        e()
    ], XioId.prototype, "id", void 0);
    __decorate$n([
        e({ type: Boolean, reflect: true })
    ], XioId.prototype, "copied", void 0);
    XioId = __decorate$n([
        mixinFocusable,
        mixinStyles(styles$m)
    ], XioId);

    var styles$l = r$2 `

svg, span {
	vertical-align: middle;
}

svg {
	width: 1.2em;
	height: 1.2em;
}

slot[name=loading] svg {
	animation:
		spin 10s linear infinite,
		fade 500ms ease infinite alternate;
}

slot[name=error] * {
	color: var(--loading-error-color, red);
}

@keyframes spin {
	from { transform: rotate(0deg); }
	to { transform: rotate(360deg); }
}

@keyframes fade {
	from { opacity: 1.0; }
	to { opacity: 0.5; }
}

`;

    var warningSvg = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 20 20"><g fill="none"><path d="M10 7a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0v-4A.5.5 0 0 1 10 7z" fill="#626262"/><path d="M10 14.5a.75.75 0 1 0 0-1.5a.75.75 0 0 0 0 1.5z" fill="#626262"/><path d="M8.686 2.852a1.5 1.5 0 0 1 2.628 0l6.56 11.925A1.5 1.5 0 0 1 16.558 17H3.44a1.5 1.5 0 0 1-1.314-2.223L8.686 2.852zm1.752.482a.5.5 0 0 0-.876 0L3.003 15.26a.5.5 0 0 0 .438.741H16.56a.5.5 0 0 0 .438-.74L10.438 3.333z" fill="currentColor"/></g></svg>`;

    var spinnerIcon = y `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-loader"><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg>`;

    var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioOp = class XioOp extends AutowatcherComponent {
        constructor() {
            super(...arguments);
            this.mode = "none";
            // @property({type: Object})
            // op: Op<xPayload> = ops.none()
            this._op = ops.none();
            this.errorIcon = warningSvg;
            this.loadingIcon = spinnerIcon;
            this["loading-message"] = "loading...";
            this["error-message"] = "error";
        }
        get op() {
            return this._op;
        }
        set op(op) {
            const old = this._op;
            this._op = op;
            this.mode = ops.mode(op);
            this.requestUpdate("op", old);
        }
        render() {
            return ops.select(this.op, {
                none: () => $ `
				<slot name=none></slot>
			`,
                loading: () => $ `
				<slot name=loading>
					${this.loadingIcon}
					<span>${this["loading-message"]}</span>
				</slot>
			`,
                error: reason => $ `
				<slot name=error>
					${this.errorIcon}
					<span>${reason ?? this["fallbackErrorMessage"]}</span>
				</slot>
			`,
                ready: () => $ `
				<slot></slot>
			`,
            });
        }
    };
    __decorate$m([
        e({ type: String, reflect: true })
    ], XioOp.prototype, "mode", void 0);
    __decorate$m([
        e({ type: Object })
    ], XioOp.prototype, "op", null);
    __decorate$m([
        e()
    ], XioOp.prototype, "errorIcon", void 0);
    __decorate$m([
        e()
    ], XioOp.prototype, "loadingIcon", void 0);
    __decorate$m([
        e({ type: String })
    ], XioOp.prototype, "loading-message", void 0);
    __decorate$m([
        e({ type: String })
    ], XioOp.prototype, "error-message", void 0);
    XioOp = __decorate$m([
        mixinStyles(styles$l)
    ], XioOp);

    var styles$k = r$2 `

:host {
	display: inline-block;
	width: var(--avatar-size, 3em);
	height: var(--avatar-size, 3em);
	border-radius: var(--avatar-border-radius, 0.3em);
	overflow: hidden;
	user-select: none;
}

.avatar {
	display: block;
	width: 100%;
	height: 100%;
	color: var(--xio-avatar-color, #444);
	background: var(--xio-avatar-background, #888);
}

.avatar[data-logged-in] {
	color: #fff;
}

svg, img {
	pointer-events: none;
	display: block;
	width: 100%;
	height: 100%;
	object-fit: cover;
}

`;

    var svgSilhouette = y `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill="currentColor" fill-rule="evenodd" d="M12 14.002a.998.998 0 0 1-.998.998H1.001A1 1 0 0 1 0 13.999V13c0-2.633 4-4 4-4s.229-.409 0-1c-.841-.62-.944-1.59-1-4 .173-2.413 1.867-3 3-3s2.827.586 3 3c-.056 2.41-.159 3.38-1 4-.229.59 0 1 0 1s4 1.367 4 4v1.002z"/></svg>`;

    function cap(x, min, max) {
        return x < min
            ? min
            : x > max
                ? max
                : x;
    }
    function hsl(xHue, xSaturation, xLightness) {
        const hue = xHue % 360;
        const saturation = cap(xSaturation, 0, 100);
        const lightness = cap(xLightness, 0, 100);
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }
    function getNiceColors(value) {
        const base = Math.ceil(value * 360);
        const split_a = (base - 30) % 360;
        const split_b = (base + 30) % 360;
        return {
            color1: hsl(base, 100, 90),
            color2: hsl(split_a, 50, 60),
            color3: hsl(split_b, 50, 40),
        };
    }

    var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioAvatar = class XioAvatar extends Component {
        renderBlankAvatar(spec) {
            return $ `
			<div class=avatar>
				${svgSilhouette}
			</div>
		`;
        }
        renderSimpleAvatar({ value }) {
            const { color1, color2, color3 } = getNiceColors(value);
            const style = `color: ${color1}; background: linear-gradient(to bottom right, ${color2}, ${color3});`;
            return $ `
			<div class=avatar style=${style}>
				${svgSilhouette}
			</div>
		`;
        }
        renderImageAvatar({ link }) {
            return $ `
			<div class=avatar>
				<img src="${link}" alt=""/>
			</div>
		`;
        }
        render() {
            const { spec = { type: "blank" } } = this;
            switch (spec.type) {
                case "blank":
                    return this.renderBlankAvatar(spec);
                case "simple":
                    return this.renderSimpleAvatar(spec);
                case "image":
                    return this.renderImageAvatar(spec);
                default:
                    return $ `avatar missing`;
            }
        }
    };
    __decorate$l([
        e({ type: Object })
    ], XioAvatar.prototype, "spec", void 0);
    XioAvatar = __decorate$l([
        mixinStyles(styles$k)
    ], XioAvatar);

    var styles$j = r$2 `

:host {
	display: inline-block;
	--_padding: var(--xio-button-padding, 0.2em 0.5em);
	--_background: var(--xio-button-background, transparent);
	--_border: var(--xio-button-border, 1px solid);
	--_border-radius: var(--xio-button-border-radius, 0);
	--_opacity: var(--xio-button-opacity, 0.7);
	--_hover-opacity: var(--xio-button-hover-opacity, 1);
	--_hover-color: var(--xio-button-hover-color, inherit);
	--_hover-background: var(--xio-button-hover-background, var(--_background));
	--_disabled-opacity: var(--xio-button-disabled-opacity, 0.2);
	--_disabled-border-style: var(--xio-button-disabled-border-style, dashed);
}

button {
	height: 100%;
	cursor: pointer;
	font: inherit;
	color: inherit;
	padding: var(--_padding);
	font-weight: bold;
	background: var(--_background);
	border: var(--_border);
	border-radius: var(--_border-radius);
	opacity: var(--_opacity);
}

button:not([disabled]):hover,
button:not([disabled]):focus {
	opacity: var(--_hover-opacity);
	color: var(--_hover-color);
	background: var(--_hover-background);
}

button[disabled] {
	cursor: default;
	opacity: var(--_disabled-opacity);
	border-style: var(--_disabled-border-style);
}

`;

    class PressEvent extends CustomEvent {
        constructor(button) {
            super("press", { detail: button });
        }
    }

    var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioButton = class XioButton extends AutowatcherComponent {
        constructor() {
            super(...arguments);
            this["disabled"] = false;
            this.handleClick = () => {
                const event = new PressEvent(this);
                if (this.onpress)
                    this.onpress(event);
                if (!this.disabled)
                    this.dispatchEvent(event);
                event.stopPropagation();
            };
        }
        focus() {
            this.shadowRoot.querySelector("button").focus();
        }
        render() {
            return $ `
			<button
				part=button
				@click=${this.handleClick}
				?disabled=${this.disabled}>
					<slot part=button-slot></slot>
			</button>
		`;
        }
    };
    __decorate$k([
        e({ type: Boolean, reflect: true })
    ], XioButton.prototype, "disabled", void 0);
    __decorate$k([
        e({ type: Function })
    ], XioButton.prototype, "onpress", void 0);
    XioButton = __decorate$k([
        mixinFocusable,
        mixinStyles(styles$j)
    ], XioButton);

    var styles$i = r$2 `

.example {
	color: #f90;
}

`;

    var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioExample = class XioExample extends AutowatcherComponent {
        render() {
            return $ `
			<div class=example>
				<p>xio-example</p>
				<slot></slot>
			</div>
		`;
        }
    };
    XioExample = __decorate$j([
        mixinStyles(styles$i)
    ], XioExample);

    var styles$h = r$2 `

* {box-sizing: border-box;}

:host {
	display: inline-block;
	vertical-align: middle;
	color: white;
}

:host([disabled]) {
	opacity: 0.25;
}

button {
	display: inline-block;
	border: unset;
	color: unset;
	background: unset;
}

button {
	position: relative;
	width: 1.5em;
	height: 1.5em;
	background: #3338;
	box-shadow: inset 1px 2px 3px #000a;
	border-radius: 0.5em;
	border: 1px solid #fff4;
}

button[data-mode="ready"] {
	cursor: pointer;
}

button[data-mode="ready"]:hover,
button[data-mode="ready"]:focus {
	background: #5558;
	border: 1px solid #fff8;
}

button > span {
	display: inline-block;
}

button svg {
	width: 100%;
	height: 100%;
}

button .error {
	display: inline-block;
	position: absolute;
	top: 80%;
	left: 0;
	width: max-content;
	max-width: 16em;
	color: red;
	background: #200a;
	text-shadow: 1px 2px 3px #0008;
	text-align: left;
	padding: 0.2em 0.5em;
	border-radius: 0.5em;
	pointer-events: none;
}

button[data-mode="loading"] svg,
button[data-mode="error"] svg {
	padding: 10%;
}

button[data-mode="error"] svg {
	color: red;
	animation: fade 1s ease infinite alternate;
}

button[data-mode="loading"] svg {
	animation:
		spin 10s linear infinite,
		fade 500ms ease infinite alternate;
}

@keyframes spin {
	from { transform: rotate(0deg); }
	to { transform: rotate(360deg); }
}

@keyframes fade {
	from { opacity: 1.0; }
	to { opacity: 0.5; }
}

`;

    class CheckEvent extends CustomEvent {
        constructor(checkbox) {
            super("press", { detail: checkbox });
        }
    }

    var checkIcon = y `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check"><polyline points="20 6 9 17 4 12"></polyline></svg>`;

    var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioCheckbox = class XioCheckbox extends AutowatcherComponent {
        constructor() {
            super(...arguments);
            this.loading = ops.none();
            this["initially-checked"] = false;
            this["error-message"] = "error";
            this.disabled = false;
            this.handleClick = () => {
                if (!this.disabled) {
                    this.toggle();
                    const activeElement = document.activeElement;
                    if (activeElement)
                        activeElement.blur();
                }
            };
        }
        init() {
            this.loading = ops.ready(this["initially-checked"]);
        }
        get checked() {
            return ops.value(this.loading);
        }
        set checked(value) {
            this.loading = ops.ready(value);
        }
        async toggle(previousChecked = ops.value(this.loading), dispatchEvent = true) {
            const checked = !previousChecked;
            const isNotDisabled = !this.disabled;
            const isLoadingDone = ops.isReady(this.loading);
            return (isNotDisabled && isLoadingDone)
                ? ops.operation({
                    setOp: op => this.loading = op,
                    errorReason: this["error-message"],
                    promise: (async () => {
                        await (this.save ?? (async () => { }))(checked);
                        if (dispatchEvent) {
                            const event = new CheckEvent(this);
                            if (this.oncheck)
                                this.oncheck(event);
                            this.dispatchEvent(event);
                            event.stopPropagation();
                        }
                        return checked;
                    })(),
                })
                : checked;
        }
        render() {
            return $ `
			<button
				data-mode="${ops.mode(this.loading)}"
				?data-checked=${ops.value(this.loading)}
				@click=${this.handleClick}>
					${ops.select(this.loading, {
            none: () => null,
            loading: () => spinnerIcon,
            error: reason => $ `${warningSvg}<div class=error>${reason}</div>`,
            ready: checked => checked
                ? checkIcon
                : null,
        })}
			</button>
		`;
        }
    };
    __decorate$i([
        e()
    ], XioCheckbox.prototype, "loading", void 0);
    __decorate$i([
        e({ type: Boolean })
    ], XioCheckbox.prototype, "initially-checked", void 0);
    __decorate$i([
        e({ type: String })
    ], XioCheckbox.prototype, "error-message", void 0);
    __decorate$i([
        e({ type: Boolean, reflect: true })
    ], XioCheckbox.prototype, "disabled", void 0);
    __decorate$i([
        e({ type: Function })
    ], XioCheckbox.prototype, "oncheck", void 0);
    __decorate$i([
        e({ type: Function })
    ], XioCheckbox.prototype, "save", void 0);
    XioCheckbox = __decorate$i([
        mixinFocusable,
        mixinStyles(styles$h)
    ], XioCheckbox);

    var styles$g = r$2 `

/* * { outline: 1px solid #f002; } */

:host {
	display: block;
	width: 100%;
	max-width: 48rem;
	--height: var(--xio-text-input-height, 5rem);
	--pad: var(--xio-text-input-pad, 0.2em);
	--font: var(--xio-text-input-font, inherit);
	--color: var(--xio-text-input-color, inherit);
	--label-font: var(--xio-text-input-label-font, inherit);
	--label-color: var(--xio-text-input-label-color, inherit);
	--problems-font: var(--xio-text-input-problems-font, inherit);
	--problems-color: var(--xio-text-input-problems-color);
	--background: var(--xio-text-input-background, transparent);
	--valid-color: var(--xio-text-input-valid-color, #00ff8c);
	--invalid-color: var(--xio-text-input-invalid-color, #ff6100);
	--border: var(--xio-text-input-border, 1px solid);
	--border-radius: var(--xio-text-input-border-radius, 0.3em);
}

:host([hidden]) {
	display: none;
}

label {
	font: var(--label-font);
	color: var(--label-color);
}

slot {
	display: block;
	padding: 0 var(--pad);
}

.flexy {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

.flexy > * {
	flex: 0 0 auto;
}

:host([textarea]) .flexy {
	flex-direction: column;
}

[part="inputbox"] {
	display: block;
	/* max-width: var(--width); */
	position: relative;
	flex: 1 1 auto;
}

:host([textarea]) [part="inputbox"] {
	flex: 1 1 auto;
	/* max-width: unset; */
}

[part="inputbox"] svg {
	position: absolute;
	display: block;
	top: var(--pad);
	right: var(--pad);
	width: 1.2em;
	height: 1.2em;
	pointer-events: none;
}

.container[data-valid] [part="inputbox"] svg {
	color: var(--valid-color);
}

.container:not([data-valid]) [part="inputbox"] svg {
	color: var(--invalid-color);
}

#textinput {
	min-width: 1em;
	width: 100%;
	font: var(--font);
	padding: var(--pad);
	padding-right: calc(1em + calc(2 * var(--pad)));
	margin: 0;
	color: var(--color);
	background: var(--background);
	border: var(--border);
	border-radius: var(--border-radius);
	text-overflow: ellipsis;
}

textarea {
	min-height: var(--height);
}

[part="problems"] {
	display: flex;
	font: var(--problems-font);
	padding: 0 calc(2 * var(--pad));
	flex-direction: column;
	justify-content: flex-start;
	flex: 1 1 auto;
	/* min-width: 12rem; */
	list-style: none;
	color: var(--problems-color, var(--invalid-color));
}

[part="problems"] > li {
	margin-top: 0.2em;
}

`;

    function noopParser(text) {
        return text;
    }

    class EnterPressEvent extends CustomEvent {
        constructor() {
            super("enterpress", {
                bubbles: true,
                composed: true,
                detail: undefined,
            });
        }
    }

    class ValueChangeEvent extends CustomEvent {
        constructor(value) {
            super("valuechange", {
                bubbles: true,
                composed: true,
                detail: { value },
            });
        }
    }

    var svgCircleCheck = y `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check-circle"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><path d="M22 4L12 14.01l-3-3"/></svg>`;

    var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioTextInput = class XioTextInput extends Component {
        constructor() {
            super(...arguments);
            this["initial"] = "";
            this["readonly"] = false;
            this["textarea"] = false;
            this["hide-validation"] = false;
            this["show-validation-when-empty"] = false;
            this["disabled"] = false;
            this["placeholder"] = "";
            this["hidden"] = false;
            this.parser = noopParser;
            this.problems = [];
            this.onvaluechange = () => { };
            this.onenterpress = () => { };
            this.draft = "";
            this.lastDraft = "";
            this.vettedLength = 0;
            this.dispatchValueChange = () => {
                const { draft, lastDraft } = this;
                if (draft !== lastDraft) {
                    this.vettedLength = draft.length;
                    this.dispatchEvent(new ValueChangeEvent(this.value));
                }
                this.lastDraft = draft;
            };
            this.dispatchValueChangeDebounced = debounce(250, this.dispatchValueChange);
            this.dispatchEnterPress = () => {
                this.dispatchEvent(new EnterPressEvent());
            };
            this.updateDraft = () => {
                this.draft = this.input.value;
            };
            this.handleInputKeyPress = (event) => {
                if (event.key === "Enter") {
                    const notTextArea = !this.textarea;
                    const notIgnoring = !event.shiftKey;
                    if (notTextArea || notIgnoring) {
                        this.updateDraft();
                        this.dispatchValueChange();
                        this.dispatchEnterPress();
                        event.preventDefault();
                    }
                }
            };
            this.handleInput = () => {
                this.updateDraft();
                this.dispatchValueChangeDebounced();
            };
            this.handleChange = () => {
                this.updateDraft();
                this.dispatchValueChange();
            };
        }
        get input() {
            return this.shadowRoot
                ? this.shadowRoot.querySelector("#textinput")
                : undefined;
        }
        focus() {
            if (this.input)
                this.input.focus();
        }
        get value() {
            const { draft } = this;
            const parsed = (this.parser ?? noopParser)(draft);
            this.problems = this.validator ? this.validator(parsed) : [];
            return this.problems.length === 0
                ? parsed
                : undefined;
        }
        get text() {
            return this.draft;
        }
        set text(value) {
            const { input } = this;
            if (input) {
                this.input.value = value;
                this.updateDraft();
                this.dispatchValueChange();
            }
            else {
                this.initial = value;
            }
        }
        init() {
            const { initial } = this;
            this.draft = initial;
            this.lastDraft = initial;
            this.text = initial;
            this.addEventListener("valuechange", this.onvaluechange);
            this.addEventListener("enterpress", this.onenterpress);
            this.dispatchValueChange();
        }
        render() {
            const { readonly, disabled, problems, vettedLength, placeholder, textarea, validator, handleInput, handleInputKeyPress, handleChange, } = this;
            const valid = problems.length === 0;
            const showValidation = !this["hide-validation"] && !readonly && validator && (this["show-validation-when-empty"]
                ? true
                : vettedLength !== 0);
            const showProblems = showValidation && !valid;
            const icon = showValidation
                ? valid
                    ? svgCircleCheck
                    : warningSvg
                : null;
            return $ `
			<div class=container ?data-valid=${valid}>
				<label for=textinput part=label><slot></slot></label>
				<div class=flexy>
					<div part=inputbox>
						${showValidation ? icon : null}
						${textarea ? $ `
							<textarea
								id=textinput
								part=textinput
								?disabled=${disabled}
								?readonly=${readonly}
								tabindex=${readonly ? "-1" : "0"}
								placeholder=${placeholder}
								@input=${handleInput}
								@keypress=${handleInputKeyPress}
								@change=${handleChange}
							></textarea>
						` : $ `
							<input
								id=textinput
								type=text
								part=textinput
								?disabled=${disabled}
								?readonly=${readonly}
								tabindex=${readonly ? "-1" : "0"}
								placeholder=${placeholder}
								@input=${handleInput}
								@keypress=${handleInputKeyPress}
								@change=${handleChange}
								/>
						`}
					</div>
					<ol part=problems>
						${showProblems
            ? problems.map(problem => $ `
								<li>${problem}</li>
							`)
            : null}
					</ol>
				</div>
			</div>
		`;
        }
    };
    __decorate$h([
        e({ type: String, reflect: true })
    ], XioTextInput.prototype, "initial", void 0);
    __decorate$h([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "readonly", void 0);
    __decorate$h([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "textarea", void 0);
    __decorate$h([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "hide-validation", void 0);
    __decorate$h([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "show-validation-when-empty", void 0);
    __decorate$h([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "disabled", void 0);
    __decorate$h([
        e({ type: String, reflect: true })
    ], XioTextInput.prototype, "placeholder", void 0);
    __decorate$h([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "hidden", void 0);
    __decorate$h([
        e({ type: Function })
    ], XioTextInput.prototype, "parser", void 0);
    __decorate$h([
        e({ type: Function })
    ], XioTextInput.prototype, "validator", void 0);
    __decorate$h([
        e({ type: Object })
    ], XioTextInput.prototype, "problems", void 0);
    __decorate$h([
        e({ type: String })
    ], XioTextInput.prototype, "text", null);
    __decorate$h([
        e({ type: String })
    ], XioTextInput.prototype, "draft", void 0);
    XioTextInput = __decorate$h([
        mixinFocusable,
        mixinStyles(styles$g)
    ], XioTextInput);

    var styles$f = r$2 `

:host {
	display: inline-block;
	--local-avatar-size: var(--avatar-size, 3em);
}

.container {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

xio-avatar {
	flex: 0 0 auto;
	margin-right: 0.4em;
	--avatar-size: var(--local-avatar-size);
}

.box {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	flex: 1;
	flex-basis: 8em;
}

[part="nameplate"] {
	flex: 1 1 auto;
	margin-right: 1em;
	margin-bottom: 0.5em;
}

[part="details"] {
	margin-bottom: 0.5em;
}

.buttonbar {
	margin-top: 0.5em;
}

.cardplate > * {
	display: block;
}

.tags {
	list-style: none;
	font-size: 0.6em;
	cursor: default;
}

.tags > li {
	display: inline-block;
	margin: 0 0.1em;
	padding: 0 0.25em;
	border: 1px solid;
	border-radius: 1em;
}

[data-tag=staff] {
	color: var(--cobalt-tagcolor-staff, lime);
}

[data-tag=banned] {
	color: var(--cobalt-tagcolor-banned, red);
}

p[data-field=tagline] {
	opacity: 0.7;
	font-size: 0.7em;
	font-style: italic;
}

xio-text-input > span {
	opacity: 0.4;
	font-size: 0.7rem;
}

xio-text-input + xio-text-input {
	margin-top: 0.1em;
}

[part="details"] {
	font-size: 0.7em;
	list-style: none;
}

[part="details"] > li {
	margin-top: 0.2em;
}

[part="details"] > li > :first-child {
	font-weight: bold;
}

[part="details"] code {
	font-size: 0.6em;
	padding: 0.2em;
	border-radius: 0.3em;
	word-break: break-all;
	background: #0002;
}

.roles {
	font-size: 0.6em;
	list-style: none;
	padding: 0;
	margin-top: 0.3rem;
}

.roles li {
	display: inline-block;
	border: 1px solid;
	border-radius: 1em;
	padding: 0.1em 0.3em;
	line-height: 0.8em;
}

`;

    function renderText({ field, initial, text, input }) {
        return input
            ? $ `
			<xio-text-input
				data-field="${field}"
				initial="${initial}"
				text="${text}"
				part="xiotextinput"
				exportparts="${`
					label: xiotextinput-label,
					textinput: xiotextinput-textinput,
					problems: xiotextinput-problems,
				`}"
				show-validation-when-empty
				?readonly=${input.readonly}
				?hide-validation=${!input.draftIsChanged}
				.validator=${input.validator}
				@valuechange=${input.onvaluechange}>
					<span>${input.label}</span>
			</xio-text-input>
		`
            : $ `
			<p part="textfield" data-field="${field}">${initial}</p>
		`;
    }

    function renderRoles(user) {
        return $ `
		<ul class=roles>
			${user.roles.map(role => $ `
				<li
					data-role-label="${role.label}"
					data-role-id="${role.roleId}">
						${role.label}
				</li>
			`)}
		</ul>
	`;
    }

    function select(selector, context = document) {
        return context.querySelector(selector);
    }

    function formatDate(milliseconds) {
        const d = new Date(milliseconds);
        const twoDigit = (n) => n.toString().padStart(2, "0");
        const year = twoDigit(d.getFullYear());
        const month = twoDigit(d.getMonth() + 1);
        const day = twoDigit(d.getDate());
        const hours24 = d.getHours();
        let hours = d.getHours();
        hours %= 12;
        hours = hours ? hours : 12;
        const minutes = twoDigit(d.getMinutes());
        const ampm = hours24 >= 12 ? "pm" : "am";
        const timezoneOffsetMinutes = -d.getTimezoneOffset();
        const timezoneOffset = (timezoneOffsetMinutes / 60).toFixed(timezoneOffsetMinutes % 60 === 0
            ? 0
            : 1);
        const timezoneUtc = timezoneOffsetMinutes === 0
            ? "UTC"
            : `UTC${timezoneOffsetMinutes < 0 ? "" : "+"}${timezoneOffset}`;
        const timezoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
        const timezone = `${timezoneName} ${timezoneUtc}`;
        const date = `${year}-${month}-${day}`;
        const time = `${hours}:${minutes} ${ampm}`;
        const zone = `${timezone}`;
        const full = `${date} ${time} (${zone})`;
        return {
            date,
            time,
            zone,
            full,
        };
    }

    function renderDetails(user) {
        return $ `
		<ul part=details>
			<li>
				<span>joined:</span>
				<span>${formatDate(user.stats.joined).date}</span>
			</li>
			<li>
				<span>user id:</span>
				<span><xio-id id="${user.userId}"></xio-id></span>
			</li>
		</ul>
	`;
    }

    function makeProfileDraft(profile) {
        return {
            tagline: profile.tagline,
            nickname: profile.nickname,
        };
    }

    function whenOpReady(op, render) {
        return ops.isReady(op)
            ? render(ops.value(op))
            : null;
    }

    function renderOp(op, render, more = null) {
        return $ `
		<xio-op .op=${op}>
			${whenOpReady(op, render)}
			${more}
		</xio-op>
	`;
    }

    var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$8 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XioProfileCard_state, _XioProfileCard_actions;
    let XioProfileCard = class XioProfileCard extends AutowatcherComponent {
        constructor() {
            super(...arguments);
            _XioProfileCard_state.set(this, this.auto.state({
                busy: ops.ready(undefined),
            }));
            _XioProfileCard_actions.set(this, this.auto.actions({
                setBusy: (op) => {
                    __classPrivateFieldGet$8(this, _XioProfileCard_state, "f").busy = op;
                },
            }));
            this.profileDraft = undefined;
            this.problems = [];
            this.handleChange = debounce(200, () => {
                if (!this.user)
                    return;
                const { profileDraft, isChanged } = this.generateNewProfileDraftFromInputs();
                this.profileDraft = isChanged ? profileDraft : undefined;
            });
            this.handleSave = async () => {
                const { profileDraft } = this;
                await ops.operation({
                    promise: this.saveProfile(profileDraft)
                        .finally(() => {
                        this.profileDraft = null;
                    }),
                    setOp: op => __classPrivateFieldGet$8(this, _XioProfileCard_actions, "f").setBusy(op),
                });
                const setToTextField = (field, text) => {
                    const input = this.shadowRoot.querySelector(`xio-text-input[data-field="${field}"]`);
                    input.text = text;
                };
                setToTextField("nickname", profileDraft.nickname);
                setToTextField("tagline", profileDraft.tagline);
            };
        }
        init() {
            __classPrivateFieldGet$8(this, _XioProfileCard_actions, "f").setBusy(ops.ready(undefined));
        }
        get draftIsChanged() {
            return !!this.profileDraft;
        }
        get readonly() {
            return !this.saveProfile;
        }
        getTextInputField(name) {
            return select(`xio-text-input[data-field="${name}"]`, this.shadowRoot);
        }
        generateNewProfileDraftFromInputs() {
            const { profile } = this.user;
            const profileDraft = makeProfileDraft(profile);
            const nicknameInput = this.getTextInputField("nickname");
            if (!nicknameInput)
                return { profileDraft, isChanged: false };
            const taglineInput = this.getTextInputField("tagline");
            profileDraft.nickname = nicknameInput.value;
            profileDraft.tagline = taglineInput.value;
            this.problems = [...nicknameInput.problems, ...taglineInput.problems];
            const isChanged = !deepEqual(makeProfileDraft(profile), profileDraft);
            return { profileDraft, isChanged };
        }
        render() {
            const { user, draftIsChanged } = this;
            if (!user)
                return null;
            const avatarSpec = user.profile.avatar;
            return renderOp(__classPrivateFieldGet$8(this, _XioProfileCard_state, "f").busy, () => $ `
			<div class=container ?data-readonly=${this.readonly}>
				<xio-avatar part=avatar .spec=${avatarSpec}></xio-avatar>
				<div class=box>
					<div part=nameplate>
						${renderText({
            field: "nickname",
            initial: this.profileDraft
                ? this.profileDraft.nickname
                : user.profile.nickname,
            text: user.profile.nickname,
            input: this.readonly
                ? undefined
                : {
                    label: "nickname",
                    readonly: false,
                    draftIsChanged,
                    validator: profileValidators.nickname,
                    onvaluechange: this.handleChange,
                }
        })}
						${renderText({
            field: "tagline",
            initial: this.profileDraft
                ? this.profileDraft.tagline
                : user.profile.tagline,
            text: user.profile.tagline,
            input: this.readonly
                ? undefined
                : {
                    label: "tagline",
                    readonly: false,
                    draftIsChanged,
                    validator: profileValidators.tagline,
                    onvaluechange: this.handleChange,
                }
        })}
						${renderRoles(user)}
						${this.readonly ? null : $ `
							<div class=buttonbar>
								<xio-button
									?disabled=${!this.profileDraft || this.problems.length > 0}
									@press=${this.handleSave}>
										<slot name=save-button>save profile</slot>
								</xio-button>
							</div>
						`}
					</div>
					${this["show-details"]
            ? renderDetails(user)
            : null}
				</div>
			</div>
		`);
        }
    };
    _XioProfileCard_state = new WeakMap(), _XioProfileCard_actions = new WeakMap();
    __decorate$g([
        e({ type: Boolean })
    ], XioProfileCard.prototype, "show-details", void 0);
    __decorate$g([
        e({ type: Object })
    ], XioProfileCard.prototype, "user", void 0);
    __decorate$g([
        e({ type: Object })
    ], XioProfileCard.prototype, "saveProfile", void 0);
    __decorate$g([
        e({ type: Object })
    ], XioProfileCard.prototype, "profileDraft", void 0);
    XioProfileCard = __decorate$g([
        mixinStyles(styles$f)
    ], XioProfileCard);

    function integrateXioComponents() {
        return {
            XioId,
            XioOp,
            XioAvatar,
            XioButton,
            XioExample,
            XioCheckbox,
            XioTextInput,
            XioProfileCard,
        };
    }

    var adminManagerCss = r$2 `

.adminmanager .adminassigner {
	display: flex;
	flex-direction: row;
	margin: 0.5em 0;
}

.adminmanager .adminassigner > * {
	display: block;
}

.adminmanager .adminassigner > xio-text-input {
	flex: 1 1 auto;
}

.adminmanager .adminassigner > xio-text-input {
	width: 100%;
	max-width: 100%;
}

.adminmanager .adminassigner > xio-text-input::part(problems) {
	min-width: unset;
}

.adminmanager .adminassigner > xio-button {
	margin-top: 1.1em;
	margin-left: 0.3em;
}

.adminmanager .adminlist ul {
	list-style: none;
	padding: 0 1em;
	border: 1px solid #fff1;
}

.adminmanager .adminlist li {
	display: flex;
	flex-direction: row;
	align-content: center;
	padding: 0.3em 0;
	font-size: 0.8em;
}

.adminmanager .adminlist li + li {
	border-top: 1px solid #fff1;
}

.adminmanager .adminlist li > * {
	display: block;
}

.adminmanager .adminlist li > span {
	flex: 1 1 auto;
	display: flex;
	align-items: center;
	word-break: break-all;
}

.adminmanager .adminlist li > xio-button {
	color: #fff3;
}

`;

    var styles$e = r$2 `

:host {
	display: block;
}

.app-list {
	margin-top: 2em;
	margin-bottom: 2em;
}

.app-list > xio-op {
	display: block;
	border: 1px solid #f00;
	margin-top: 0.5em;
	border: 1px solid #fff1;
	border-radius: 0.2em;
}

.app-list > xio-op[mode="loading"] {
	padding: 4em 2em;
}

.app > * + * {
	margin-top: 0.3em;
}

.app + .app {
	margin-top: 1.5em;
}

.app > * {
	padding: 0.4em 1rem;
}

.app-header {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	justify-content: flex-end;
	padding: 0;
	background: #0001;
}

.app-header .title {
	max-width: 100%;
	flex: 1 0 auto;
	padding: 0.3em 1em;
}

.app-header .title h3 {
	font-size: 1.5em;
	font-weight: bold;
}

.app-header .title h3::before {
	content: "";
	color: white;
}

.app-header .stats {
	display: flex;
	flex-direction: row;
	justify-content: center;
	flex-wrap: wrap;
	padding: 0.2em;
}

.app-header .stats [data-stat] {
	display: flex;
	flex-direction: column;
	justify-content: flex-end;
	max-width: 6em;
	text-align: center;
}

.app-header .stats [data-stat] > span {
	padding: 0.1em 0.6em;
}

.app-header .stats [data-stat] > span:nth-child(1) {
	justify-self: flex-start;
}

.app-header .stats [data-stat] > span:nth-child(2) {
	opacity: 0.3;
	font-size: 0.6em;
}

.twoside {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

.twoside > div {
	max-width: 100%;
	flex: 1 0 16em;
	padding-bottom: 1em;
}

.twoside > div:nth-child(1) {
	padding-right: 1rem;
}

.editside > .buttons {
	display: flex;
	justify-content: center;
	align-items: center;
}

.app-form > * + * {
	margin-top: 0.3em;
}

.app-form xio-button {
	margin-top: 0.6em;
}

.app-options {
	border: 1px solid #fff1;
	padding: 1em;
}

.app-options > * + * {
	margin-top: 3em;
}

code {
	display: inline-block;
	font-size: 0.8em;
	padding: 0.2em;
	border-radius: 0.3em;
	background: #0002;
	overflow-wrap: anywhere;
	word-break: break-all;
}

code.id {
	opacity: 0.7;
	font-size: 0.5em;
}

.codeblock {
	display: block;
}

.htmlcode { color: #fff6; }
.htmlcode [data-syntax=tag] { color: deepskyblue; }
.htmlcode [data-syntax=attr] { color: skyblue; }
.htmlcode [data-syntax=data] { color: #aaffa0; }
.htmlcode [data-syntax=indent] {
	display: block;
	margin-left: 1em;
}

.app-code > * {
	margin-top: 1em;
}

.app-code code {
	display: block;
	font-size: 0.6em;
	padding: 1em;
	margin: 0.5em 0;
}

.delete-app-button {
	display: block;
	text-align: right;
	--xio-button-hover-color: red;
}

${adminManagerCss}

.app-list {
	margin-bottom: 5rem;
}

.app-registration {
	max-width: 40em;
	margin-bottom: 5em;
}

`;

    function renderXiomeConfig(appId) {
        const h = (syntax, s) => $ `<span data-syntax=${syntax}>${s}</span>`;
        const tag = (s) => h("tag", s);
        const attr = (s) => h("attr", s);
        const data = (s) => h("data", s);
        const glue = (s) => h("glue", s);
        const quote = glue(`"`);
        const bundle_link = "https://xiome.io/xiome.bundle.min.js";
        return $ `
		${glue(`<`)}${tag(`script`)} ${attr(`async`)} ${attr(`defer`)} ${attr(`src`)}${glue(`=`)}${quote}${data(bundle_link)}${quote}${glue(`>`)}${glue(`</`)}${tag(`script`)}${glue(`>`)}
		<br/>
		${glue(`<`)}${tag(`xiome-config`)} ${attr(`app`)}${glue(`=`)}${quote}${data(appId)}${quote}${glue(`>`)}${glue(`</`)}${tag(`xiome-config`)}${glue(`>`)}
	`;
    }

    const parseOrigins = (text) => text
        .split("\n")
        .map(line => line.trim().toLowerCase())
        .filter(line => line.length > 0);

    function validateAppFormDraft(formDraft) {
        const problems = [
            ...appDraftValidators.label(formDraft.label),
            ...appDraftValidators.home(formDraft.home),
            ...appDraftValidators.additionalOrigins(formDraft.additionalOrigins),
        ];
        return problems;
    }

    function getEmptyAppFormDraft() {
        return {
            home: "",
            label: "",
            additionalOrigins: [],
        };
    }

    function makeAppForm({ clearOnSubmit, submitButtonText, showAdditionalOrigins, initialValues = getEmptyAppFormDraft(), query, submit, requestUpdate, }) {
        const state = {
            problems: [],
            formDisabled: false,
            draft: initialValues,
            get valid() {
                return !this.formDisabled
                    && this.draft
                    && this.problems.length === 0;
            },
        };
        function getFormElements() {
            return {
                home: query(`.app-form [data-form="home"]`),
                label: query(`.app-form [data-form="label"]`),
                additionalOrigins: query(`.app-form [data-form="additional-origins"]`),
            };
        }
        function setFormValues(draft) {
            const elements = getFormElements();
            elements.home.text = draft.home;
            elements.label.text = draft.label;
            elements.additionalOrigins.text = draft.additionalOrigins.join("\n");
        }
        const refreshAndValidateForm = () => {
            const { home, label, additionalOrigins } = getFormElements();
            state.draft = {
                home: home.value,
                label: label.value,
                additionalOrigins: additionalOrigins.value,
            };
            state.problems = validateAppFormDraft(state.draft);
            requestUpdate();
        };
        function handleFormChange() {
            state.problems = [];
            if (!state.formDisabled)
                refreshAndValidateForm();
        }
        async function handleSubmitClick() {
            refreshAndValidateForm();
            state.formDisabled = true;
            requestUpdate();
            try {
                await submit(state.draft);
                if (clearOnSubmit) {
                    initialValues = getEmptyAppFormDraft();
                    setFormValues(initialValues);
                }
                else {
                    initialValues = state.draft;
                }
            }
            finally {
                state.formDisabled = false;
                requestUpdate();
            }
        }
        function render({ partNamespace }) {
            const { formDisabled, draft, problems } = state;
            const changes = !deepEqual(initialValues, draft);
            const submitButtonDisabled = !changes
                || formDisabled
                || problems.length > 0;
            const exportPartsTextInput = `
			label: xiotextinput-label,
			textinput: xiotextinput-textinput,
			problems: xiotextinput-problems,

			label: ${partNamespace}-appform-xiotextinput-label,
			textinput: ${partNamespace}-appform-xiotextinput-textinput,
			problems: ${partNamespace}-appform-xiotextinput-problems,
		`;
            const renderTextInput = ({ hide, textarea, label, dataForm, initialText, showValidationWhenEmpty, parser, validator, }) => $ `
			<xio-text-input
				?textarea=${textarea}
				part="${partNamespace}-appform-xiotextinput"
				exportparts="${exportPartsTextInput}"
				data-form="${dataForm}"
				initial="${initialText}"
				?hidden=${hide}
				?disabled=${formDisabled}
				?hide-validation=${!changes}
				?show-validation-when-empty=${showValidationWhenEmpty}
				.parser=${parser}
				.validator=${validator}
				@valuechange=${handleFormChange}>
					<span part=xio-text-input-label>
						${label}
					</span>
			</xio-text-input>
		`;
            return $ `
			<div class=app-form>
				<slot name=create-app-heading></slot>

				${renderTextInput({
            hide: false,
            textarea: false,
            dataForm: "label",
            label: "community name",
            initialText: initialValues.label,
            showValidationWhenEmpty: false,
            parser: undefined,
            validator: appDraftValidators.label,
        })}

				${renderTextInput({
            hide: false,
            textarea: false,
            dataForm: "home",
            label: `website homepage, like "https://chasemoskal.com/"`,
            initialText: initialValues.home,
            showValidationWhenEmpty: false,
            parser: undefined,
            validator: appDraftValidators.home,
        })}

				${renderTextInput({
            hide: !showAdditionalOrigins,
            textarea: true,
            dataForm: "additional-origins",
            label: "(optional) additional domain names",
            initialText: initialValues.additionalOrigins.join("\n"),
            showValidationWhenEmpty: true,
            parser: parseOrigins,
            validator: appDraftValidators.additionalOrigins,
        })}

				<xio-button
					class="create-app-button"
					?disabled=${submitButtonDisabled}
					@press=${handleSubmitClick}>
						${submitButtonText}
				</xio-button>
			</div>
		`;
        }
        return { render };
    }

    function adminManagerControls({ app, state, actions, appEditService, }) {
        const { appId } = app;
        const load = (firstStep = Promise.resolve(undefined)) => (ops.operation({
            promise: firstStep
                .then(() => appEditService.listAdmins({ appId })),
            setOp: admins => actions.setAdmins(admins)
        }));
        async function listAdmins() {
            await load();
        }
        async function assignAdmin() {
            const { email } = state.assignerDraft;
            actions.setAssignerDraft({ email: undefined });
            await load(appEditService.assignAdmin({ appId, email }));
        }
        async function revokeAdmin(userId) {
            await load(appEditService.revokeAdmin({ appId, userId }));
        }
        return { listAdmins, assignAdmin, revokeAdmin };
    }

    function adminManagerStateAndActions() {
        const auto = autowatcher();
        const state = auto.state({
            admins: ops.none(),
            assignerDraft: {
                email: undefined,
            },
        });
        const actions = auto.actions({
            setAdmins(op) {
                state.admins = op;
            },
            setAssignerDraft(draft) {
                state.assignerDraft = draft;
            },
        });
        return {
            track: auto.track,
            state,
            actions,
        };
    }

    function makeAdminManager({ app, appEditService, query }) {
        const { state, actions, track } = adminManagerStateAndActions();
        const controls = adminManagerControls({
            app,
            state,
            actions,
            appEditService,
        });
        function handleEmailChange(event) {
            const email = event.detail.value ?? undefined;
            actions.setAssignerDraft({ email });
        }
        function handleAssignButtonPress() {
            const textInput = query(".adminassigner xio-text-input");
            controls.assignAdmin();
            textInput.text = "";
        }
        function renderAdminAssigner() {
            const exportPartsTextInput = `
			label: xiotextinput-label,
			textinput: xiotextinput-textinput,
			problems: xiotextinput-problems,

			label: adminmanager-xiotextinput-label,
			textinput: adminmanager-xiotextinput-textinput,
			problems: adminmanager-xiotextinput-problems,
		`;
            return $ `
			<div class=adminassigner>
				<xio-text-input
					part=adminmanager-xiotextinput
					exportparts="${exportPartsTextInput}"
					.validator=${emailValidator}
					@valuechange=${handleEmailChange}>
						email
				</xio-text-input>
				<xio-button
					?disabled=${!state.assignerDraft.email}
					@press=${handleAssignButtonPress}>
						grant
				</xio-button>
			</div>
		`;
        }
        function renderAdminList() {
            return $ `
			<div class=adminlist>
				${renderOp(state.admins, admins => $ `
					<ul>
						${admins.map(({ email, userId }) => $ `
							<li>
								<span>${email}</span>
								<xio-button @press=${() => controls.revokeAdmin(userId)}>
									revoke
								</xio-button>
							</li>
						`)}
					</ul>
				`)}
			</div>
		`;
        }
        function render() {
            return $ `
			${renderAdminAssigner()}
			${renderAdminList()}
		`;
        }
        return { render, controls, track };
    }

    function dedupe(arr) {
        return [...new Set(arr)];
    }

    function formDraftToAppDraft(formDraft) {
        return {
            home: formDraft.home,
            label: formDraft.label,
            origins: dedupe([
                new URL(formDraft.home).origin,
                ...formDraft.additionalOrigins,
            ])
        };
    }

    // TODO obsolete
    // usage of these functions should be replaced by the better assertive-map.ts
    function strongRecordKeeper() {
        return function (makeRecord) {
            const map = new Map();
            return function getRecord(key) {
                let record;
                if (map.has(key))
                    record = map.get(key);
                else {
                    record = makeRecord(key);
                    map.set(key, record);
                }
                return record;
            };
        };
    }

    function originsMinusHome(home, origins) {
        return origins
            .filter(o => o.toLowerCase() !== new URL(home.toLowerCase()).origin)
            .map(o => o.toLowerCase());
    }

    function appDisplayToFormDraft(display) {
        return {
            home: display.home,
            label: display.label,
            additionalOrigins: originsMinusHome(display.home, display.origins),
        };
    }

    var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeAppManager = class XiomeAppManager extends ComponentWithShare {
        constructor() {
            super(...arguments);
            this.appRegistrationForm = makeAppForm({
                clearOnSubmit: true,
                showAdditionalOrigins: false,
                submitButtonText: "create community",
                requestUpdate: () => this.requestUpdate(),
                query: selector => (this.shadowRoot
                    .querySelector(".app-registration")
                    .querySelector(selector)),
                submit: async (formDraft) => {
                    const appDraft = formDraftToAppDraft(formDraft);
                    await this.share.appsModel.registerApp(appDraft);
                },
            });
            this.getAppState = strongRecordKeeper()(appId => {
                const app = this.share.appsModel.getApp(appId);
                const { actions, getState, onStateChange } = happystate({
                    state: { editMode: false },
                    actions: state => ({
                        toggleEditMode() { state.editMode = !state.editMode; },
                    }),
                });
                onStateChange(() => { this.requestUpdate(); });
                return {
                    toggleEditMode: actions.toggleEditMode,
                    get editMode() { return getState().editMode; },
                    appForm: makeAppForm({
                        clearOnSubmit: false,
                        showAdditionalOrigins: true,
                        submitButtonText: "save changes",
                        initialValues: appDisplayToFormDraft(app),
                        requestUpdate: () => { this.requestUpdate(); },
                        query: selector => (this.shadowRoot
                            .querySelector(`.app[data-app-id="${app.appId}"] .app-options`)
                            .querySelector(selector)),
                        submit: async (formDraft) => {
                            const appDraft = formDraftToAppDraft(formDraft);
                            await this.share.appsModel.updateApp(app.appId, appDraft);
                        },
                    }),
                    adminManager: (() => {
                        const manager = makeAdminManager({
                            app,
                            appEditService: this.share.appsModel.appEditService,
                            query: selector => this.shadowRoot
                                .querySelector(`.app[data-app-id="${app.appId}"] .adminmanager`)
                                .querySelector(selector)
                        });
                        manager.track({
                            watcher: () => { manager.render(); },
                            effect: () => this.requestUpdate(),
                        });
                        manager.controls.listAdmins();
                        return manager;
                    })(),
                };
            });
            this.deleteApp = async (app) => {
                const userIsSure = await this.share.modals.confirm({
                    title: "are you certain?",
                    body: `you really want to delete your community "${app.label}"?`,
                    yes: { label: "delete whole community", vibe: "negative" },
                    no: { label: "nevermind", vibe: "neutral" },
                    focusNthElement: 2,
                });
                if (userIsSure)
                    await this.share.appsModel.deleteApp(app.appId);
            };
        }
        init() {
            this.share.appsModel.loadApps();
        }
        renderAppRegistration() {
            return $ `
			<div class=app-registration>
				<slot name="register-app-heading"></slot>
				${this.appRegistrationForm.render({ partNamespace: "appregistration" })}
			</div>
		`;
        }
        renderNoApps() {
            return $ `
			<slot name=no-apps></slot>
			${this.renderAppRegistration()}
		`;
        }
        renderAppList(records) {
            return $ `
			<slot></slot>
			<div class=app-list>
				${Object.entries(records)
            .map(([appId, record]) => renderOp(record, app => this.renderApp(app)))}
			</div>
			${this.renderAppRegistration()}
		`;
        }
        renderAppBankLinking(app) {
            return null;
            // return html`
            // 	<div>
            // 		<h4>bank link to receive payouts</h4>
            // 		<xiome-bank-connect .appId=${app.appId}></xiome-bank-connect>
            // 	</div>
            // `
        }
        renderAppCode(appId) {
            return $ `
			<div class=app-code>
				<h4>connect your website</h4>
				<p>copy-paste this html into your website's &lt;head&gt; section:</p>
				<code class=htmlcode>
					${renderXiomeConfig(appId)}
				</code>
				<p>then head over to the <a part=link href="./components">components page</a></p>
			</div>
		`;
        }
        renderApp(app) {
            const appState = this.getAppState(app.appId);
            return $ `
			<div class=app data-app-id=${app.appId}>

				<div class=app-header part=app-header>
					<div class=title>
						<h3>
							<a part=link target=_blank href="${app.home}">
								${app.label}
							</a>
						</h3>
					</div>
					<div class=stats>
						<div data-stat=users>
							<span>${app.stats.users.toLocaleString()}</span>
							<span>users</span>
						</div>
						<div data-stat=monthly-active>
							<span>${app.stats.usersActiveMonthly.toLocaleString()}</span>
							<span>monthly active</span>
						</div>
						<div data-stat=active-last-day>
							<span>${app.stats.usersActiveDaily.toLocaleString()}</span>
							<span>daily active</span>
						</div>
					</div>
				</div>

				<div class=twoside>
					${this.renderAppCode(app.appId)}
					<div class=editside>
						<div class=buttons>
							<xio-button @click=${appState.toggleEditMode}>edit community</xio-button>
						</div>
						<div class=app-options ?hidden=${!appState.editMode}>
							<div class=app-details>
								${appState.appForm.render({ partNamespace: "appeditor" })}
							</div>
							<div class=adminmanager>
								<h4>manage admins</h4>
								${appState.adminManager.render()}
							</div>
							${this.renderAppBankLinking(app)}
							<div class=finalbox>
								<xio-button
									class=delete-app-button
									@press=${() => this.deleteApp(app)}>
										delete community
								</xio-button>
							</div>
						</div>
					</div>
				</div>
			</div>
		`;
        }
        render() {
            const { appRecords } = this.share.appsModel.state;
            return $ `
			${renderOp(appRecords, records => Object.values(records).length
            ? this.renderAppList(records)
            : this.renderNoApps())}
		`;
        }
    };
    XiomeAppManager = __decorate$f([
        mixinStyles(styles$e)
    ], XiomeAppManager);

    var styles$d = r$2 `

.avatar {
	display: block;
	width: 3em;
	height: 3em;
	padding: 0.2em;
	border-radius: 0.3em;
}

:host([logged-in]) .avatar {
	color: #fff;
}

svg {
	display: block;
	width: 100%;
	height: 100%;
}

`;

    var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeMyAvatar = class XiomeMyAvatar extends AutowatcherComponentWithShare {
        render() {
            const accessOp = this.share.accessModel.getAccessOp();
            return renderOp(accessOp, access => $ `
			<xio-avatar
				.spec=${access?.user?.profile.avatar}
				part="xio-avatar"
			></xio-avatar>
		`);
        }
    };
    XiomeMyAvatar = __decorate$e([
        mixinStyles(styles$d)
    ], XiomeMyAvatar);

    var styles$c = r$2 `

xio-profile-card {
	--avatar-size: 7em;
}

`;

    var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeMyAccount = class XiomeMyAccount extends ComponentWithShare {
        constructor() {
            super(...arguments);
            this.saveProfile = async (profileDraft) => {
                await this.share.personalModel.saveProfile(profileDraft);
            };
        }
        render() {
            const { accessOp } = this.share.personalModel.readable;
            return renderOp(accessOp, ({ user }) => $ `
			<xio-profile-card
				show-details
				.user=${user}
				.saveProfile=${this.saveProfile}
			></xio-profile-card>
		`);
        }
    };
    XiomeMyAccount = __decorate$d([
        mixinStyles(styles$c)
    ], XiomeMyAccount);

    var styles$b = r$2 `

:host {
	display: block;
}

slot {
	display: block;
}

xio-text-input,
xio-button {
	margin-top: 0.2em;
}

xio-text-input > span {
	opacity: 0.4;
	font-size: 0.7em;
}

.buttonbar {
	margin-top: 0.5em;
	vertical-align: middle;
}

slot[name="legal"] {
	display: inline-block;
	margin: 0 1em;
}

small {
	display: block;
	opacity: 0.5;
	font-size: 0.7em;
}

`;

    var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeLoginPanel = class XiomeLoginPanel extends ComponentWithShare {
        constructor() {
            super(...arguments);
            this["show-logout"] = false;
            this["status"] = "loading";
            this.sentLoading = ops.none();
            this.emailIsValid = false;
        }
        async sendEmail() {
            const email = this.textInput.value;
            await ops.operation({
                promise: this.share.accessModel.sendLoginLink(email)
                    .then(() => ({ email })),
                setOp: op => this.sentLoading = op,
                errorReason: `failed sending email to "${email}"`,
            });
        }
        resetSentLoading() {
            this.sentLoading = ops.none();
            if (this.textInput)
                this.textInput.text = "";
        }
        logout() {
            this.share.accessModel.logout()
                .then(() => this.sentLoading = ops.none());
        }
        subscribe() {
            return this.share.accessModel.subscribe(() => {
                this.resetSentLoading();
            });
        }
        renderLoggedIn(access) {
            return $ `
			<slot>
				<p>Welcome ${access.user.profile.nickname}!</p>
			</slot>
			${this["show-logout"]
            ? $ `
					<div part=buttonbar>
						<xio-button class=logout-button @press=${this.logout}>
							Logout
						</xio-button>
					</div>
				`
            : null}
		`;
        }
        handleEmailChange() {
            this.emailIsValid = this.textInput.problems.length === 0;
        }
        renderLegalLink() {
            return $ `
			<small>
				<p>
					<a
						part=link
						target=_blank
						href="https://xiome.io/legal">
							policies and terms
					</a>
				</p>
			</small>
		`;
        }
        renderLoggedOut() {
            const { emailIsValid } = this;
            return $ `
			<xio-op .op=${this.sentLoading}>
				<div slot=none>
					<slot name=logged-out>
						<p>login with your email address</p>
					</slot>
					<xio-text-input
						.validator=${email()}
						@valuechange=${this.handleEmailChange}
						@enterpress=${this.sendEmail}>
							<span>your email</span>
					</xio-text-input>
					<div class=buttonbar>
						<slot name=legal>
							${this.renderLegalLink()}
						</slot>
						<xio-button
							?disabled=${!emailIsValid}
							@press=${this.sendEmail}>
								send login link
						</xio-button>
					</div>
				</div>
				${ops.isReady(this.sentLoading)
            ? $ `
						<p>email sent to ${ops.value(this.sentLoading).email}</p>
						<p>please wait a few minutes for it to arrive</p>
						<xio-button @press=${this.resetSentLoading}>
							restart
						</xio-button>
					`
            : null}
			</xio-op>
		`;
        }
        render() {
            const accessOp = this.share.accessModel.getAccessOp();
            this.status = "loading";
            if (ops.isReady(accessOp)) {
                this.status = ops.value(accessOp)?.user
                    ? "logged-in"
                    : "logged-out";
            }
            return renderOp(accessOp, access => access?.user
                ? this.renderLoggedIn(access)
                : this.renderLoggedOut());
        }
    };
    __decorate$c([
        e({ type: Boolean, reflect: true })
    ], XiomeLoginPanel.prototype, "show-logout", void 0);
    __decorate$c([
        e({ type: String, reflect: true })
    ], XiomeLoginPanel.prototype, "status", void 0);
    __decorate$c([
        e()
    ], XiomeLoginPanel.prototype, "sentLoading", void 0);
    __decorate$c([
        i("xio-text-input")
    ], XiomeLoginPanel.prototype, "textInput", void 0);
    __decorate$c([
        e({ type: String })
    ], XiomeLoginPanel.prototype, "emailIsValid", void 0);
    XiomeLoginPanel = __decorate$c([
        mixinStyles(styles$b)
    ], XiomeLoginPanel);

    var styles$a = r$2 `

.creator {
	margin: 1em auto;
}

.privilege {
	display: inline-flex;
	flex-direction: row;
	padding: 0.2em 0.5em;
	margin: 0.2em;
	border: 1px solid;
}

.privilege .icon {
	padding-right: 0.5em;
}

.privilege xio-button {
	--xio-button-padding: 0;
	--xio-button-border: none;
}

.privilege[data-hard] {
	opacity: 0.5;
	border: 1px solid dashed;
}

`;

    var wrenchSvg = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><g fill="none"><path d="M7 5a4 4 0 0 1 5.445-3.73a.5.5 0 0 1 .173.819L10.708 4L12 5.293l1.91-1.91a.5.5 0 0 1 .82.172a4 4 0 0 1-4.829 5.292L4.897 13.92a1.986 1.986 0 0 1-2.843-2.774l5.051-5.234A4.01 4.01 0 0 1 7 5zm4-3a3 3 0 0 0-2.862 3.903a.5.5 0 0 1-.117.498L2.773 11.84a.986.986 0 0 0 1.41 1.377l5.225-5.293a.5.5 0 0 1 .532-.116a3 3 0 0 0 4.046-3.088l-1.633 1.634a.5.5 0 0 1-.707 0l-2-2a.5.5 0 0 1 0-.707l1.634-1.634A3.045 3.045 0 0 0 11 2z" fill="currentColor"/></g></svg>`;

    var cancelSvg = y `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill="currentColor" fill-rule="evenodd" d="M7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm0 1.3c1.3 0 2.5.44 3.47 1.17l-8 8A5.755 5.755 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zm0 11.41c-1.3 0-2.5-.44-3.47-1.17l8-8c.73.97 1.17 2.17 1.17 3.47 0 3.14-2.56 5.7-5.7 5.7z"/></svg>`;

    function renderPrivilege({ privilege: { hard, label, privilegeId }, onDeleteClick, }) {
        function renderSystemIcon() {
            return $ `
			<div class="icon system">
				${wrenchSvg}
			</div>
		`;
        }
        function renderDeleteButton() {
            return $ `
			<xio-button
				title="delete privilege"
				class="icon delete"
				@press=${onDeleteClick}>
					${cancelSvg}
			</xio-button>
		`;
        }
        return $ `
		<div
			class=privilege
			?data-hard=${hard}>
				${hard ? renderSystemIcon() : renderDeleteButton()}
				<span class=text>${label}</span>
		</div>
	`;
    }

    const validatePermissionsLabel = validator$1(string(), minLength(1), maxLength(32));

    var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldSet$4 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$7 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomePrivileges_instances, _XiomePrivileges_busy, _XiomePrivileges_clearCreatorTextInput, _XiomePrivileges_createPrivilege, _XiomePrivileges_deletePrivilege, _XiomePrivileges_labelDraft, _XiomePrivileges_handleCreatorLabelChange, _XiomePrivileges_renderPrivilegeCreator;
    let XiomePrivileges = class XiomePrivileges extends ComponentWithShare {
        constructor() {
            super(...arguments);
            _XiomePrivileges_instances.add(this);
            _XiomePrivileges_busy.set(this, false);
            _XiomePrivileges_labelDraft.set(this, void 0);
            _XiomePrivileges_handleCreatorLabelChange.set(this, (event) => {
                __classPrivateFieldSet$4(this, _XiomePrivileges_labelDraft, event.detail.value, "f");
                this.requestUpdate();
            });
        }
        get model() {
            return this.share.permissionsModel;
        }
        init() {
            this.model.initialize();
        }
        render() {
            const { readable: { permissionsDisplay } } = this.model;
            const allowed = this.model.getUserCanCustomizePermissions();
            return renderOp(permissionsDisplay, permissions => allowed ? $ `
			<div class=privileges>
				${__classPrivateFieldGet$7(this, _XiomePrivileges_instances, "m", _XiomePrivileges_renderPrivilegeCreator).call(this)}
				${permissions.privileges.map(privilege => renderPrivilege({
            privilege,
            onDeleteClick: () => __classPrivateFieldGet$7(this, _XiomePrivileges_instances, "m", _XiomePrivileges_deletePrivilege).call(this, privilege)
        }))}
			</div>
		` : $ `
			<p>you are not permitted to customize privileges</p>
		`);
        }
    };
    _XiomePrivileges_busy = new WeakMap(), _XiomePrivileges_labelDraft = new WeakMap(), _XiomePrivileges_handleCreatorLabelChange = new WeakMap(), _XiomePrivileges_instances = new WeakSet(), _XiomePrivileges_clearCreatorTextInput = function _XiomePrivileges_clearCreatorTextInput() {
        const input = this.shadowRoot.querySelector(".creator xio-text-input");
        input.text = "";
    }, _XiomePrivileges_createPrivilege = async function _XiomePrivileges_createPrivilege() {
        if (__classPrivateFieldGet$7(this, _XiomePrivileges_busy, "f"))
            throw new Error("privilege creator is busy");
        const label = __classPrivateFieldGet$7(this, _XiomePrivileges_labelDraft, "f");
        __classPrivateFieldGet$7(this, _XiomePrivileges_instances, "m", _XiomePrivileges_clearCreatorTextInput).call(this);
        __classPrivateFieldSet$4(this, _XiomePrivileges_busy, true, "f");
        try {
            await this.model.createPrivilege({ label });
        }
        finally {
            __classPrivateFieldSet$4(this, _XiomePrivileges_busy, false, "f");
        }
    }, _XiomePrivileges_deletePrivilege = async function _XiomePrivileges_deletePrivilege({ privilegeId, label }) {
        const confirm = await this.share.modals.confirm({
            title: $ `delete privilege ${label}?`,
            body: $ `are you sure you want to delete this privilege?`,
        });
        if (confirm)
            await this.model.deletePrivilege({ privilegeId });
    }, _XiomePrivileges_renderPrivilegeCreator = function _XiomePrivileges_renderPrivilegeCreator() {
        const isCreateButtonDisabled = !__classPrivateFieldGet$7(this, _XiomePrivileges_labelDraft, "f");
        return $ `
			<div class=creator>
				<xio-text-input
					?disabled=${__classPrivateFieldGet$7(this, _XiomePrivileges_busy, "f")}
					.validator=${validatePermissionsLabel}
					@valuechange=${__classPrivateFieldGet$7(this, _XiomePrivileges_handleCreatorLabelChange, "f")}
					@enterpress=${__classPrivateFieldGet$7(this, _XiomePrivileges_instances, "m", _XiomePrivileges_createPrivilege)}>
						privilege label
				</xio-text-input>
				<xio-button
					?disabled=${isCreateButtonDisabled}
					@press=${__classPrivateFieldGet$7(this, _XiomePrivileges_instances, "m", _XiomePrivileges_createPrivilege)}>
						create privilege
				</xio-button>
			</div>
		`;
    };
    XiomePrivileges = __decorate$b([
        mixinStyles(styles$a)
    ], XiomePrivileges);

    var styles$9 = r$2 `

* {
	ZZoutline: 1px solid #0f02;
}

:host {
	display: block;
	width: 100%;
}

.container {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	gap: 0.5em;
}

.container > * {
	flex: 3 1 10em;
	display: flex;
	flex-direction: column;
}

.roles {
	flex: 1 3 10em;
}

.roles xio-button[data-hard] {
	opacity: 0.6;
}

.container > * > p {
	padding: 0 0.5em;
}

[part=plate] {
	flex: 1 1 auto;
	padding: 0.5em;
	background: #fff2;
}

[part=plate] xio-button {
	display: inline-block;
	margin: 0.2em 0.1em;
	--xio-button-disabled-opacity: 0.6;
}

[part=plate] xio-button[data-hard] {
	opacity: 0.6;
}

[part=plate] xio-button[data-selected]::part(button) {
	border: 1px solid lime;
	background: yellow;
	color: black;
}

[part=plate] xio-button > div {
	display: flex;
	flex-direction: row;
}

[part=plate] xio-button .icon {
	margin-right: 0.2em;
}

[part=plate] xio-button svg {
	width: 0.8em;
	height: 0.8em;
}

.buttonbar {
	text-align: right;
	background: #0002;
}

.buttonbar [data-button=delete] {
	--xio-button-hover-color: red;
	--xio-button-hover-background: transparent;
}

.buttonbar [data-button=new] {
	--xio-button-hover-color: lime;
	--xio-button-hover-background: transparent;
}

`;

    var lockSvg = y `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-lock"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`;

    var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomePermissions = class XiomePermissions extends ComponentWithShare {
        constructor() {
            super(...arguments);
            this.clickRole = (role) => () => {
                this.roleSelected = role;
            };
            this.clickDeleteRole = async () => {
                const { modals, permissionsModel } = this.share;
                const role = this.roleSelected;
                const confirmed = await modals.confirm({
                    title: "Delete role?",
                    body: `Are you sure you want to permanently delete the role "${role.label}"`,
                    yes: { vibe: "negative", label: "Delete role" },
                    no: { vibe: "neutral", label: "Nevermind" },
                    focusNthElement: 2,
                });
                if (confirmed)
                    await permissionsModel.deleteRole({ roleId: role.roleId });
            };
            this.clickNewRole = async () => {
                const { modals, permissionsModel } = this.share;
                const result = await modals.prompt({
                    title: "Create a new role",
                    input: {
                        label: "Role name",
                        validator: roleLabelValidator,
                    },
                    yes: { vibe: "positive", label: "Create role" }
                });
                if (result)
                    await permissionsModel.createRole({ label: result.value });
            };
            this.clickAvailablePrivilege = (privilegeId) => async () => {
                const { roleSelected } = this;
                if (roleSelected)
                    await this.share.permissionsModel.assignPrivilege({
                        privilegeId,
                        roleId: roleSelected.roleId,
                    });
            };
            this.clickAssignedPrivilege = (privilegeId) => async () => {
                const { roleSelected } = this;
                if (roleSelected)
                    await this.share.permissionsModel.unassignPrivilege({
                        privilegeId,
                        roleId: roleSelected.roleId,
                    });
            };
        }
        init() {
            this.share.permissionsModel.initialize();
        }
        getAssignedPrivileges(permissions) {
            const { roleSelected } = this;
            if (!roleSelected)
                return [];
            const assignedPrivilegeIds = permissions.rolesHavePrivileges
                .filter(({ roleId }) => roleId === roleSelected.roleId)
                .map(({ privilegeId }) => privilegeId);
            return permissions.privileges
                .filter(({ privilegeId }) => assignedPrivilegeIds.includes(privilegeId))
                .map(privilege => {
                const { active, immutable } = permissions.rolesHavePrivileges.find(rp => rp.roleId === roleSelected.roleId &&
                    rp.privilegeId === privilege.privilegeId);
                return { ...privilege, active, immutable };
            });
        }
        renderPrivilege({ privilegeId, label, hard, immutable, onPrivilegeClick, }) {
            return $ `
			<xio-button
				title="${privilegeId}"
				?disabled=${immutable}
				?data-hard=${hard}
				?data-soft=${!hard}
				?data-immutable=${immutable}
				@press=${onPrivilegeClick}>
					<div>
						${hard
            ? $ `<div class=icon>${wrenchSvg}</div>`
            : null}
						${immutable
            ? $ `<div class=icon>${lockSvg}</div>`
            : null}
						${label}
					</div>
			</xio-button>
		`;
        }
        renderPermissions(permissions) {
            const assignedPrivileges = this.getAssignedPrivileges(permissions);
            const activePrivileges = assignedPrivileges.filter(p => p.active);
            const availablePrivileges = this.roleSelected
                ? [
                    ...permissions.privileges
                        .filter(privilege => {
                        const assigned = assignedPrivileges
                            .find(priv => priv.privilegeId === privilege.privilegeId);
                        return !assigned;
                    })
                        .map(privilege => ({ ...privilege, immutable: false })),
                    ...assignedPrivileges
                        .filter(privilege => !privilege.active)
                ]
                : [];
            return $ `
			<div class=container>
				<div class=roles>
					<p>roles</p>
					<div part=plate>
						${permissions.roles.map(role => $ `
							<xio-button
								title="${role.roleId}"
								?data-selected=${this.roleSelected &&
            role.roleId === this.roleSelected.roleId}
								?data-hard=${role.hard}
								?disabled=${this.roleSelected &&
            role.roleId === this.roleSelected.roleId}
								@click=${this.clickRole(role)}>
								<div>
									${role.hard
            ? $ `<div class=icon>${wrenchSvg}</div>`
            : null}
									${role.label}
								</div>
							</xio-button>
						`)}
					</div>
					<div part=plate class=buttonbar>
						${this.roleSelected
            ? $ `
								<xio-button
									data-button=delete
									?disabled=${this.roleSelected.hard}
									@press=${this.clickDeleteRole}>
										delete role
								</xio-button>
							`
            : null}
						<xio-button data-button=new @press=${this.clickNewRole}>
							new role
						</xio-button>
					</div>
				</div>

				<div class=assigned>
					<p>
						privileges assigned
						${this.roleSelected
            ? ` to "${this.roleSelected.label}"`
            : null}
					</p>
					<div part=plate>
						${activePrivileges.map(privilege => this.renderPrivilege({
            ...privilege,
            onPrivilegeClick: this.clickAssignedPrivilege(privilege.privilegeId)
        }))}
					</div>
				</div>

				<div class=available>
					<p>privileges available</p>
					<div part=plate>
						${availablePrivileges.map(privilege => this.renderPrivilege({
            ...privilege,
            onPrivilegeClick: this.clickAvailablePrivilege(privilege.privilegeId),
        }))}
					</div>
				</div>
			</div>
		`;
        }
        render() {
            const { permissionsModel } = this.share;
            const { getUserCanCustomizePermissions, readable } = permissionsModel;
            return getUserCanCustomizePermissions()
                ? renderOp(readable.permissionsDisplay, this.renderPermissions.bind(this))
                : $ `
				<p>you are not privileged to customize permissions</p>
			`;
        }
    };
    __decorate$a([
        e()
    ], XiomePermissions.prototype, "roleSelected", void 0);
    XiomePermissions = __decorate$a([
        mixinStyles(styles$9)
    ], XiomePermissions);

    function integrateAuthComponents({ models, modals }) {
        const { accessModel, appsModel, personalModel, permissionsModel } = models;
        return {
            XiomeMyAvatar: mixinSnapstateSubscriptions(accessModel.subscribe)(mixinShare({
                accessModel,
            })(XiomeMyAvatar)),
            XiomeLoginPanel: mixinSnapstateSubscriptions(accessModel.subscribe)(mixinShare({
                accessModel,
            })(XiomeLoginPanel)),
            XiomeAppManager: mixinSnapstateSubscriptions(appsModel.subscribe)(mixinShare({
                modals,
                appsModel,
            })(XiomeAppManager)),
            XiomeMyAccount: mixinSnapstateSubscriptions(personalModel.subscribe)(mixinShare({
                personalModel,
            })(XiomeMyAccount)),
            XiomePermissions: mixinSnapstateSubscriptions(permissionsModel.subscribe)(mixinShare({
                modals,
                permissionsModel,
            })(XiomePermissions)),
            XiomePrivileges: mixinSnapstateSubscriptions(permissionsModel.subscribe)(mixinShare({
                modals,
                permissionsModel,
            })(XiomePrivileges)),
        };
    }

    var styles$8 = r$2 `

:host {
	display: block;
}

`;

    function renderView({ view, onDeleteClick, getPrivilegeDisplay }) {
        return $ `
		<div class="view">
			<div class="view-details">
				<div>
					<h4>hosting provider</h4>
					<p>${view.provider}</p>
				</div>
				<div>
					<h4>content type</h4>
					<p>${view.type}</p>
				</div>
				<div>
					<h4>content id</h4>
					<xio-id id="${view.id}"></xio-id>
				</div>
			</div>
			<h4>privileges with access</h4>
			<ul>
				${view.privileges.map(getPrivilegeDisplay)
        .map(privilege => privilege
        ? $ `<li>${privilege.label}</li>`
        : null)}
			</ul>
			<div class=buttonbar>
			<xio-button @press=${onDeleteClick}>
				unassign from this display
			</xio-button>
			</div>
		</div>
	`;
    }

    var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeVideoViews = class XiomeVideoViews extends ComponentWithShare {
        async init() {
            this.share.contentModel.initializeForModerationData();
        }
        render() {
            const model = this.share.contentModel;
            return model.allowance.canModerateVideos
                ? renderOp(model.state.viewsOp, views => $ `
				<slot>
					<h3>all video views</h3>
				</slot>
				${views.length ? $ `
					<div class=views>
						${views.map(view => renderView({
                view,
                onDeleteClick: () => model.deleteView(view.label),
                getPrivilegeDisplay: id => model.getPrivilege(id),
            }))}
					</div>
				` : $ `
					<slot name=no-views>
						<p>no video views are registered</p>
					</slot>
				`}
			`)
                : $ `
				<slot name=unprivileged>
					<p>you don't have sufficient privileges to moderate video views</p>
				</slot>
			`;
        }
    };
    XiomeVideoViews = __decorate$9([
        mixinStyles(styles$8)
    ], XiomeVideoViews);

    var clockIcon = y `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>`;

    var styles$7 = r$2 `

:host {
	display: block;
	width: 24em;
	max-width: 100%;
	border: 1px solid;
	border-radius: 5px;
	--xiome-video-hosting-warning-color: red;
}

.dacastbox {
	padding: 1em;
}

xio-text-input::part(problems) {
	width: 100%;
}

.buttonbar {
	display: flex;
	flex-direction: row;
	justify-content: flex-end;
}

.buttonbar > * {
	margin: 0.4em 0.2em;
}

.failed {
	color: var(--xiome-video-hosting-warning-color);
	display: flex;
	align-items: center;
	padding: 0.5em 0;
}

.failed svg {
	margin-right: 0.5em;
}

.linked {
	display: flex;
}

.helpbox ul {
	padding-left: 1.5em;
}

.link-time-info {
	display: inline-flex;
	align-items: center;
	padding: 0.5em 0;
}


.unlink-button {
	display: flex;
	justify-content: flex-end;
}

.link-time-info svg {
	width: 6em;
	height: 3em;
}
`;

    var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldSet$3 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$6 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeVideoHosting_showHelp, _XiomeVideoHosting_linkFailed, _XiomeVideoHosting_apiKeyDraft, _XiomeVideoHosting_handleInputChange, _XiomeVideoHosting_handleLinkClick, _XiomeVideoHosting_handleUnlinkClick, _XiomeVideoHosting_toggleHelp, _XiomeVideoHosting_renderHelp, _XiomeVideoHosting_renderWhenUnlinked, _XiomeVideoHosting_renderWhenLinked;
    let XiomeVideoHosting = class XiomeVideoHosting extends ComponentWithShare {
        constructor() {
            super(...arguments);
            _XiomeVideoHosting_showHelp.set(this, false);
            _XiomeVideoHosting_linkFailed.set(this, false);
            _XiomeVideoHosting_apiKeyDraft.set(this, "");
            _XiomeVideoHosting_handleInputChange.set(this, ({ detail: { value } }) => {
                __classPrivateFieldSet$3(this, _XiomeVideoHosting_apiKeyDraft, value, "f");
                this.requestUpdate();
            });
            _XiomeVideoHosting_handleLinkClick.set(this, async () => {
                const apiKey = __classPrivateFieldGet$6(this, _XiomeVideoHosting_apiKeyDraft, "f");
                if (apiKey) {
                    __classPrivateFieldSet$3(this, _XiomeVideoHosting_linkFailed, false, "f");
                    __classPrivateFieldSet$3(this, _XiomeVideoHosting_apiKeyDraft, "", "f");
                    const link = await this.share.dacastModel.linkAccount({ apiKey });
                    __classPrivateFieldSet$3(this, _XiomeVideoHosting_linkFailed, !link, "f");
                }
            });
            _XiomeVideoHosting_handleUnlinkClick.set(this, async () => {
                __classPrivateFieldSet$3(this, _XiomeVideoHosting_apiKeyDraft, "", "f");
                await this.share.dacastModel.unlinkAccount();
            });
            _XiomeVideoHosting_toggleHelp.set(this, () => {
                __classPrivateFieldSet$3(this, _XiomeVideoHosting_showHelp, !__classPrivateFieldGet$6(this, _XiomeVideoHosting_showHelp, "f"), "f");
                this.requestUpdate();
            });
            _XiomeVideoHosting_renderHelp.set(this, () => {
                return $ `
			<div class=helpbox>
				<p>how to find your dacast api key:</p>
				<ul>
					<li>create a <a part=link target=_blank href="https://dacast.com/">dacast</a> account</li>
					<li>if you have a trial account, you must email support and ask them to activate your account's "api access"</li>
					<li>generate an api key in your <a part=link target=_blank href="https://app.dacast.com/settings/integrations">dacast integrations settings</a></li>
				</ul>
			</div>
		`;
            });
            _XiomeVideoHosting_renderWhenUnlinked.set(this, () => {
                return $ `
			<h2>link your dacast account</h2>
			<xio-text-input
				placeholder="api key"
				.validator=${validateDacastApiKeyAllowingMock}
				@enterpress=${__classPrivateFieldGet$6(this, _XiomeVideoHosting_handleLinkClick, "f")}
				@valuechange=${__classPrivateFieldGet$6(this, _XiomeVideoHosting_handleInputChange, "f")}>
			</xio-text-input>
			${__classPrivateFieldGet$6(this, _XiomeVideoHosting_linkFailed, "f")
                ? $ `<div class=failed>${warningSvg} <p>dacast rejected the api link</p></div>`
                : null}
			<div class=buttonbar>
				<xio-button
					class=help-button
					@press=${__classPrivateFieldGet$6(this, _XiomeVideoHosting_toggleHelp, "f")}>
						${__classPrivateFieldGet$6(this, _XiomeVideoHosting_showHelp, "f")
                ? "hide help"
                : "show help"}
				</xio-button>
				<xio-button
					class=link-button
					?disabled=${!__classPrivateFieldGet$6(this, _XiomeVideoHosting_apiKeyDraft, "f")}
					@press=${__classPrivateFieldGet$6(this, _XiomeVideoHosting_handleLinkClick, "f")}>
						link
				</xio-button>
			</div>
			${__classPrivateFieldGet$6(this, _XiomeVideoHosting_showHelp, "f")
                ? __classPrivateFieldGet$6(this, _XiomeVideoHosting_renderHelp, "f").call(this)
                : null}
		`;
            });
            _XiomeVideoHosting_renderWhenLinked.set(this, (linkedAccount) => {
                return $ `
			<h2>your dacast account is linked</h2>
			<div class=link-time-info>
				${clockIcon}
				<p>linked on ${formatDate(linkedAccount.time).full}</p>
			</div>
			<div class=unlink-button>
				<xio-button @press=${__classPrivateFieldGet$6(this, _XiomeVideoHosting_handleUnlinkClick, "f")}>unlink</xio-button>
			</div>
		`;
            });
        }
        get state() {
            return this.share.dacastModel.state;
        }
        async init() {
            await this.share.dacastModel.initialize();
        }
        render() {
            return renderOp(this.state.accessOp, access => $ `
			<div class=dacastbox>
				${access.permit.privileges.includes(videoPrivileges["moderate videos"])
            ? renderOp(this.state.linkedAccountOp, linkedAccount => linkedAccount
                ? __classPrivateFieldGet$6(this, _XiomeVideoHosting_renderWhenLinked, "f").call(this, linkedAccount)
                : __classPrivateFieldGet$6(this, _XiomeVideoHosting_renderWhenUnlinked, "f").call(this))
            : $ `<slot name=forbidden>you don't have permission to edit video hosting settings</slot>`}
			</div>
		`);
        }
    };
    _XiomeVideoHosting_showHelp = new WeakMap(), _XiomeVideoHosting_linkFailed = new WeakMap(), _XiomeVideoHosting_apiKeyDraft = new WeakMap(), _XiomeVideoHosting_handleInputChange = new WeakMap(), _XiomeVideoHosting_handleLinkClick = new WeakMap(), _XiomeVideoHosting_handleUnlinkClick = new WeakMap(), _XiomeVideoHosting_toggleHelp = new WeakMap(), _XiomeVideoHosting_renderHelp = new WeakMap(), _XiomeVideoHosting_renderWhenUnlinked = new WeakMap(), _XiomeVideoHosting_renderWhenLinked = new WeakMap();
    XiomeVideoHosting = __decorate$8([
        mixinStyles(styles$7)
    ], XiomeVideoHosting);

    var styles$6 = r$2 `

:host {
	display: block;
	--_select-bg: var(--xiome-video-display-select-background, #222);
	--xiome-video-display-selected-option-color: cyan;
}

.controls-title,
.view,
.viewcreator {
	max-width: 42rem;
}

[part="iframe"] {
	width: 100%;
	height: 100%;
	border: none;
}

.mock-embed img {
	width: 100%;
}

.buttonbar {
	text-align: right;
}

.controls-title,
.viewcreator,
.view {
	border: 1px solid;
	border-radius: 0.2em;
}

.controls-title {
	padding: 0.1em 0.5em;
}
.controls-title[data-open] {
	border-bottom-left-radius: 0;
	border-bottom-right-radius: 0;
}
.view, .viewcreator {
	border-top: 0;
	border-top-left-radius: 0;
	border-top-right-radius: 0;
}

.controls-title {
	display: flex;
	align-items: center;
}
.controls-title div span {
	display: block;
}
.controls-title span:nth-of-type(2) {
	opacity: 0.8;
	font-size: 0.8em;
	font-weight: normal;
	padding-left: 0.2em;
}

.togglebutton {
	--xio-button-border: 0;
	margin-left: auto;
	transition: transform 300ms ease;
	transform: rotate(0deg);
}
[data-open] .togglebutton {
	transform: rotate(180deg);
}

.view, .viewcreator {
	display: flex;
	flex-direction: column;
	gap: 0.2em;
	padding: 0.5em;
}

.viewcreator .selectionarea {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	width: 100%;
	gap: 0.5em;
	margin: 0.5em 0;
}

.viewcreator .selectionarea > * {
	flex: 1 1 auto;
}

select {
	color: inherit;
	background: transparent;
	border: 1px solid;
	width: 100%;
}

select[multiple] {
	min-height: 10em;
}

select option {
	padding: 0.1em 0.2em;
	color: inherit;
	background: var(--_select-bg);
}

.create-privileges {
	visibility: hidden;
}

.create-privileges[data-visible] {
	visibility: visible;
}

.create-privileges option[selected] {
	color: var(--xiome-video-display-selected-option-color);
}

::-webkit-scrollbar { width: 5px; }
::-webkit-scrollbar-thumb { background: currentColor; }

::scrollbar { width: 8px; }
::scrollbar-thumb { background: currentColor; }

/* When video is displayed css */

.view-details {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-around;
	gap: 0.8em;
	margin: 0.5em 0;
}

.view-details > * {
	text-align: center;
}

.view ul {
	display: flex;
	justify-content: left;
	text-align: center;
	list-style-type: none;
	flex-wrap: wrap;
}

.view ul li {
	border: 1px solid;
	margin: 0.2em;
	padding: 0.1em 0.4em;
	border-radius: 1em;
}

`;

    function makeHtmlElement(tag, attributes) {
        const element = document.createElement(tag);
        for (const [key, value] of Object.entries(attributes))
            element.setAttribute(key, value);
        return element;
    }

    const dacastIframeRegex = /"(https:\/\/iframe\.dacast\.com\/(\S+)\/(\S+))"/i;
    function parseDacastIframeSrc(code) {
        const parts = code.match(dacastIframeRegex);
        if (!parts)
            throw new Error(`failed to parse dacast iframe embed code: make-dacast-iframe likely needs to be updated`);
        const [, , resource, id] = parts;
        const fixedResource = resource === "playlists"
            ? "playlist"
            : resource;
        return `https://iframe.dacast.com/${fixedResource}/${id}`;
    }

    let mockCount = 0;
    function prepareEmbeds() {
        const map = new Map();
        return {
            obtain(details, mockEmbed) {
                if (details.provider !== "dacast")
                    throw new Error(`unsupported video provider "${details.provider}"`);
                let div = map.get(details.id);
                if (!div) {
                    div = makeHtmlElement("div", {
                        "data-id": details.id,
                    });
                    const embed = mockEmbed
                        ? makeHtmlElement("img", {
                            part: "iframe",
                            alt: "",
                            src: `https://source.unsplash.com/random/480x270?${mockCount++}`
                        })
                        : makeHtmlElement("iframe", {
                            src: parseDacastIframeSrc(details.embed),
                            part: "iframe",
                            allowfullscreen: "",
                            webkitallowfullscreen: "",
                            mozallowfullscreen: "",
                            oallowfullscreen: "",
                            msallowfullscreen: "",
                            frameborder: "0",
                            scrolling: "no",
                            allow: "autoplay",
                        });
                    div.appendChild(embed);
                    map.set(details.id, div);
                }
                return div;
            },
        };
    }

    function renderViewCreator({ isContentSelected, isCreateButtonDisabled, privilegesOp, catalogOp, selectedContent, queryAll, onCatalogSelect, onPrivilegesSelect, onCreateClick, isPrivilegeSelected, }) {
        const onCatalogSelectChange = (event) => {
            const target = event.target;
            onCatalogSelect(parseInt(target.value));
        };
        const onPrivilegesSelectChange = () => {
            onPrivilegesSelect(queryAll(".create-privileges select option")
                .filter(option => option.selected).map(option => option.value));
        };
        function renderContentSelector() {
            const catalog = ops.value(catalogOp);
            return $ `
			<div class=create-content>
				${catalog.length ? $ `
					<h5>Select content for this view</h5>
					<select @change=${onCatalogSelectChange}>
						${isContentSelected
            ? null
            : $ `
								<option disabled selected>
									(select video content)
								</option>
							`}
						${catalog.map(({ provider, type, title }, index) => $ `
							<option value=${index} ?selected=${index === selectedContent}>
								${`${provider} ${type} ${title}`}
							</option>
						`)}
					</select>
				` : $ `
					<p>no available video content (are your video accounts linked?)</p>
				`}
			</div>
		`;
        }
        function renderPrivilegeSelector() {
            const privileges = ops.value(privilegesOp);
            return $ `
			<div class="create-privileges" ?data-visible=${isContentSelected}>
				<h5>Select which privileges have access</h5>
				<select multiple @change=${onPrivilegesSelectChange}>
					${privileges.map(privilege => $ `
						<option
							?selected=${isPrivilegeSelected(privilege.privilegeId)}
							value="${privilege.privilegeId}">
								${privilege.label}
						</option>
					`)}
				</select>
			</div>
		`;
        }
        return renderOp(ops.combine(catalogOp, privilegesOp), () => $ `
		<div class=viewcreator>
			<h4>Assign Video Content</h4>
			<div class=selectionarea>
				${renderContentSelector()}
				${renderPrivilegeSelector()}
			</div>
			<div class=buttonbar>
				<xio-button
					class=create-button
					?disabled=${isCreateButtonDisabled}
					@press=${onCreateClick}>
						Assign To This Video
				</xio-button>
			</div>
		</div>
	`);
    }

    var triangle = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><g transform="rotate(180 8 8)"><g fill="currentColor"><path fill-rule="evenodd" d="M7.022 1.566a1.13 1.13 0 0 1 1.96 0l6.857 11.667c.457.778-.092 1.767-.98 1.767H1.144c-.889 0-1.437-.99-.98-1.767L7.022 1.566z"/></g></g></svg>`;

    function videoControls({ queryAll, contentModel: model, requestUpdate, }) {
        const { readable, writable, subscribe } = snapstate({
            open: false,
            selectedContent: undefined,
            selectedPrivileges: [],
        });
        const toggleControls = () => {
            writable.open = !writable.open;
        };
        function render(label) {
            const currentView = model.getView(label);
            return $ `
			<h3 class=controls-title ?data-open=${readable.open}>
				<div>
					<span>video display controls</span>
					<span>label = <em>"${label}"</em></span>
				</div>
				<xio-button
					class=togglebutton
					title="${readable.open ? "close" : "open"} video controls"
					@press=${toggleControls}>
						${triangle}
				</xio-button>
			</h3>
			${readable.open ? $ `
				${currentView
            ? renderView({
                view: currentView,
                onDeleteClick: () => model.deleteView(label),
                getPrivilegeDisplay: id => model.getPrivilege(id),
            })
            : renderViewCreator({
                queryAll,
                catalogOp: model.state.catalogOp,
                privilegesOp: model.state.privilegesOp,
                isContentSelected: readable.selectedContent !== undefined,
                selectedContent: readable.selectedContent,
                isCreateButtonDisabled: readable.selectedContent === undefined
                    || readable.selectedPrivileges.length === 0,
                onCatalogSelect: index => {
                    writable.selectedContent = index;
                    writable.selectedPrivileges = [];
                },
                isPrivilegeSelected: id => {
                    return readable.selectedPrivileges.some(e => e === id);
                },
                onPrivilegesSelect: privileges => {
                    writable.selectedPrivileges = privileges;
                },
                onCreateClick: () => {
                    const { selectedContent, selectedPrivileges } = readable;
                    writable.selectedContent = undefined;
                    writable.selectedPrivileges = [];
                    const content = model.catalog[selectedContent];
                    model.setView({
                        label,
                        privileges: selectedPrivileges,
                        reference: {
                            id: content.id,
                            type: content.type,
                            provider: content.provider,
                        },
                    });
                }
            })}
			` : null}
		`;
        }
        return {
            render,
            subscribe: () => subscribe(requestUpdate),
        };
    }

    var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$5 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeVideoDisplay_instances, _XiomeVideoDisplay_model_get, _XiomeVideoDisplay_embeds, _XiomeVideoDisplay_videoControls, _XiomeVideoDisplay_renderShow;
    let XiomeVideoDisplay = class XiomeVideoDisplay extends ComponentWithShare {
        constructor() {
            super(...arguments);
            _XiomeVideoDisplay_instances.add(this);
            this.label = "default";
            this["mock-embed"] = false;
            this["show-title"] = false;
            _XiomeVideoDisplay_embeds.set(this, prepareEmbeds());
            _XiomeVideoDisplay_videoControls.set(this, (() => {
                const controls = videoControls({
                    contentModel: __classPrivateFieldGet$5(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get),
                    requestUpdate: () => this.requestUpdate(),
                    queryAll: s => Array.from(this.shadowRoot.querySelectorAll(s)),
                });
                this.addSubscription(controls.subscribe);
                return controls;
            })());
        }
        async init() {
            await __classPrivateFieldGet$5(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).initializeForVideo(this.label);
        }
        render() {
            return renderOp(__classPrivateFieldGet$5(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).state.accessOp, () => $ `
			${__classPrivateFieldGet$5(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).allowance.canModerateVideos
            ? __classPrivateFieldGet$5(this, _XiomeVideoDisplay_videoControls, "f").render(this.label)
            : null}
			${__classPrivateFieldGet$5(this, _XiomeVideoDisplay_instances, "m", _XiomeVideoDisplay_renderShow).call(this)}
		`);
        }
    };
    _XiomeVideoDisplay_embeds = new WeakMap(), _XiomeVideoDisplay_videoControls = new WeakMap(), _XiomeVideoDisplay_instances = new WeakSet(), _XiomeVideoDisplay_model_get = function _XiomeVideoDisplay_model_get() {
        return this.share.contentModel;
    }, _XiomeVideoDisplay_renderShow = function _XiomeVideoDisplay_renderShow() {
        const show = __classPrivateFieldGet$5(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).getShow(this.label);
        return show
            ? show.details
                ? $ `
					${this["show-title"]
                ? $ `<h4 part=title>${show.details.title}</h4>`
                : null}
					${__classPrivateFieldGet$5(this, _XiomeVideoDisplay_embeds, "f")
                .obtain(show.details, this["mock-embed"])
                ?? "(embed missing)"}
					<slot></slot>
				`
                : $ `<slot name=unprivileged></slot>`
            : $ `<slot name=unavailable></slot>`;
    };
    __decorate$7([
        e({ type: String })
    ], XiomeVideoDisplay.prototype, "label", void 0);
    __decorate$7([
        e({ type: Boolean, reflect: true })
    ], XiomeVideoDisplay.prototype, "mock-embed", void 0);
    __decorate$7([
        e({ type: Boolean, reflect: true })
    ], XiomeVideoDisplay.prototype, "show-title", void 0);
    XiomeVideoDisplay = __decorate$7([
        mixinStyles(styles$6)
    ], XiomeVideoDisplay);

    var styles$5 = r$2 `

:host {
	display: block;
}

`;

    var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$4 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeVideoCompanion_instances, _XiomeVideoCompanion_model_get;
    let XiomeVideoCompanion = class XiomeVideoCompanion extends ComponentWithShare {
        constructor() {
            super(...arguments);
            _XiomeVideoCompanion_instances.add(this);
            this.label = "default";
        }
        init() {
            __classPrivateFieldGet$4(this, _XiomeVideoCompanion_instances, "a", _XiomeVideoCompanion_model_get).initializeForVideo(this.label);
        }
        render() {
            const show = __classPrivateFieldGet$4(this, _XiomeVideoCompanion_instances, "a", _XiomeVideoCompanion_model_get).getShow(this.label);
            const { accessOp, showsOp } = __classPrivateFieldGet$4(this, _XiomeVideoCompanion_instances, "a", _XiomeVideoCompanion_model_get).state;
            const combinedOp = ops.combine(accessOp, showsOp);
            return renderOp(combinedOp, () => show
                ? show.details
                    ? $ `<slot></slot>`
                    : $ `<slot name=unprivileged></slot>`
                : $ `<slot name=unavailable></slot>`);
        }
    };
    _XiomeVideoCompanion_instances = new WeakSet(), _XiomeVideoCompanion_model_get = function _XiomeVideoCompanion_model_get() {
        return this.share.contentModel;
    };
    __decorate$6([
        e({ type: String })
    ], XiomeVideoCompanion.prototype, "label", void 0);
    XiomeVideoCompanion = __decorate$6([
        mixinStyles(styles$5)
    ], XiomeVideoCompanion);

    function integrateVideoComponents({ models }) {
        const { dacastModel, contentModel } = models.videoModels;
        return {
            XiomeVideoHosting: (mixinSnapstateSubscriptions(dacastModel.subscribe)(mixinShare({
                dacastModel,
            })(XiomeVideoHosting))),
            XiomeVideoDisplay: (mixinSnapstateSubscriptions(contentModel.subscribe)(mixinShare({
                contentModel,
            })(XiomeVideoDisplay))),
            XiomeVideoViews: (mixinSnapstateSubscriptions(contentModel.subscribe)(mixinShare({
                contentModel,
            })(XiomeVideoViews))),
            XiomeVideoCompanion: (mixinSnapstateSubscriptions(contentModel.subscribe)(mixinShare({
                contentModel,
            })(XiomeVideoCompanion))),
        };
    }

    var styles$4 = r$2 `

:host {
	display: block;
}

`;

    var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeExample = class XiomeExample extends ComponentWithShare {
        get state() {
            return this.share.exampleModel.state;
        }
        render() {
            return renderOp(this.state.accessOp, access => $ `
			<p>Example Component</p>
			${access?.user
            ? $ `<p>Welcome, ${access.user.profile.nickname}</p>`
            : $ `<p>User is not logged in.</p>`}
		`);
        }
    };
    XiomeExample = __decorate$5([
        mixinStyles(styles$4)
    ], XiomeExample);

    function integrateExampleComponents({ models, modals }) {
        const { exampleModel } = models;
        return {
            XiomeExample: (mixinSnapstateSubscriptions(exampleModel.subscribe)(mixinShare({
                modals,
                exampleModel,
            })(XiomeExample))),
        };
    }

    var votingUnitCss = r$2 `

[data-vote] {
	display: block;
	border: none;
	font: inherit;
	background: transparent;
	color: inherit;
}

[data-vote] {
	cursor: pointer;
	opacity: 0.6;
	user-select: none;
}

[data-vote="report"] {
	opacity: 0.4;
}

[data-vote]:not([disabled]):hover,
[data-vote]:not([disabled]):focus {
	opacity: 1;
}

[data-vote][disabled] {
	cursor: default;
}

[data-vote="like"][data-active] {
	color: var(--like-color);
}

[data-vote="report"][data-active] {
	color: var(--report-color);
}

[data-vote] > span {
	vertical-align: middle;
}

[data-vote] > span:nth-child(2) {
	font-size: 0.9em;
}

[data-vote] svg {
	width: 1.4em;
	height: 1.4em;
	position: relative;
	top: 0.1em;
}

`;

    var postCss = r$2 `

${votingUnitCss}

.post {
	display: grid;
	grid-template-rows: auto;
	grid-template-columns: auto 1fr auto;
	grid-template-areas:
		".... tophat    ...."
		"bar1 bubble    bar2"
		".... buttonbar ....";
}

a {
	opacity: 0.5;
	color: inherit;
	text-decoration: none;
}

a:hover, a:focus {
	opacity: 0.8;
	text-decoration: underline;
}

/*
** normal questions
*/

.post .tophat { grid-area: tophat }
.post .bar1 { grid-area: bar1 }
.post .bar2 { grid-area: bar2 }
.post .bubble { grid-area: bubble }
.post .buttonbar { grid-area: buttonbar }

.post .bar {
	padding: 0.5em;
	padding-top: 0.2em;
	display: flex;
	flex-direction: column;
}

.post .bar > * + * {
	margin-top: 0.1em;
}

.post .bar.bar2 {
	padding-top: 0;
}

.post .metabar {
	font-size: 0.7em;
	padding: 0 1.5em;
	opacity: 0.6;
}

.post .tophat xio-profile-card {
	width: 100%;
}

.post .bubble {
	flex: 1 1 auto;
	/* padding-left: 1em; */
}

.post .bubble xio-text-input {
	--xio-text-input-border-radius: 0 1em 1em 1em;
	--xio-text-input-pad: 0.5em;
}

.post .bubble .textbox p {
	border-radius: 0 1em 1em 1em;
	border: 1px solid;
	padding: 0.5em;
	min-height: 4em;
}

.post [part="bubble"] {
	white-space: pre-wrap;
}

/*
** question editor
*/

.intro {
	margin-bottom: 1em;
}

.intro .heading {
	font-size: 2em;
}

.post.editor .buttonbar {
	text-align: right;
	padding: 0.5em;
}

.post.editor {
	padding-bottom: 2em;
	margin-bottom: 2em;
	border-bottom: 1px dashed;
}

`;

    var styles$3 = r$2 `

/* * {
	outline: 1px solid #f002;
} */

:host {
	display: block;
	max-width: 42em;
	--like-color: var(--xiome-questions-like-color, cyan);
	--report-color: var(--xiome-questions-report-color, #f90);
}

.questions-moderation-panel {
	padding: 1em;
	border: 1px dotted;
	margin-bottom: 1em;
}

.questions-moderation-panel .purge-button {
	--xio-button-hover-color: red;
}

slot[name="empty"] {
	display: block;
	margin-top: 1em;
}

[part="questions-list"] {
	list-style: none;

}

[part="questions-list"] > li {
	margin-top: 2em;
}

${postCss}

[part="answers-list"] {
	list-style: none;
	margin-left: 3.4em;
	margin-right: 1em;
	margin-bottom: 1em;
}

[part="answers-list"] > li {
	
	margin-top: 1em;
}

@media (max-width: 420px) {
	[part="answers-list"] {
		margin-left: 1em;
		margin-right: 0;
	}
	[part="answers-list"] > li {
		border-left: 1px solid;
	}
}

/*
** question editor
*/

.editor .intro {
	margin-bottom: 1em;
}

.editor .intro .heading {
	font-size: 2em;
}

.editor .buttonbar {
	text-align: right;
	padding: 0.5em;
}

.question-editor {
	padding-bottom: 2em;
	margin-bottom: 2em;
	border-bottom: 1px dashed;
}

/*
** answer editor
*/

.answer-editor {
	border: 1px dashed;
	margin-left: 5em;
	margin-top: 1em;
}

.answer-editor .intro {
	padding: 1em;
}

`;

    const timeFactor = 1 * day;
    function sortQuestions(questions, myUserId) {
        const myQuestions = [];
        const otherQuestions = [];
        for (const question of questions) {
            const isMine = myUserId && question.authorUserId === myUserId;
            if (isMine)
                myQuestions.push(question);
            else
                otherQuestions.push(question);
        }
        return [
            ...myQuestions.sort(compareQuestions),
            ...otherQuestions.sort(compareQuestions),
        ];
    }
    function compareQuestions(a, b) {
        const promoteA = -1;
        const promoteB = 1;
        const scoreA = score(a);
        const scoreB = score(b);
        if (scoreA > scoreB)
            return promoteA;
        if (scoreB < scoreA)
            return promoteB;
        return 0;
    }
    function score({ timePosted, likes, reports }) {
        return timePosted
            + voteValue(likes, timeFactor)
            - voteValue(reports, 2 * timeFactor);
    }
    function voteValue(votes, timeFactor) {
        const voteWeight = votes === 0
            ? 0
            : 1 + Math.log10(votes);
        return voteWeight * timeFactor;
    }

    function renderBubble({ content, editable, timePosted, handleValueChange = () => { }, }) {
        const { date, time } = formatDate(timePosted);
        return $ `
		<div class=bubble ?data-editable=${editable}>
			<div class=textbox>
				${editable
        ? $ `
						<xio-text-input
							exportparts="textinput: bubble"
							textarea
							.validator=${validatePostContent}
							@valuechange=${handleValueChange}
						></xio-text-input>
					`
        : $ `
						<p part=bubble>${content}</p>
					`}
			</div>
			<div class=metabar>
				<p>${`${date} ${time}`}</p>
			</div>
		</div>
	`;
    }

    function linkClick(handler) {
        return (event) => {
            event.preventDefault();
            handler();
        };
    }

    var PostType;
    (function (PostType) {
        PostType[PostType["Question"] = 0] = "Question";
        PostType[PostType["Answer"] = 1] = "Answer";
        PostType[PostType["Editor"] = 2] = "Editor";
    })(PostType || (PostType = {}));

    var heartSvg = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M6.736 4C4.657 4 2.5 5.88 2.5 8.514c0 3.107 2.324 5.96 4.861 8.12a29.66 29.66 0 0 0 4.566 3.175l.073.041l.073-.04c.271-.153.661-.38 1.13-.674c.94-.588 2.19-1.441 3.436-2.502c2.537-2.16 4.861-5.013 4.861-8.12C21.5 5.88 19.343 4 17.264 4c-2.106 0-3.801 1.389-4.553 3.643a.75.75 0 0 1-1.422 0C10.537 5.389 8.841 4 6.736 4zM12 20.703l.343.667a.75.75 0 0 1-.686 0l.343-.667zM1 8.513C1 5.053 3.829 2.5 6.736 2.5C9.03 2.5 10.881 3.726 12 5.605C13.12 3.726 14.97 2.5 17.264 2.5C20.17 2.5 23 5.052 23 8.514c0 3.818-2.801 7.06-5.389 9.262a31.146 31.146 0 0 1-5.233 3.576l-.025.013l-.007.003l-.002.001l-.344-.666l-.343.667l-.003-.002l-.007-.003l-.025-.013A29.308 29.308 0 0 1 10 20.408a31.147 31.147 0 0 1-3.611-2.632C3.8 15.573 1 12.332 1 8.514z" fill="currentColor"/></svg>`;

    var heartFillSvg = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M14 20.408c-.492.308-.903.546-1.192.709c-.153.086-.308.17-.463.252h-.002a.75.75 0 0 1-.686 0a16.709 16.709 0 0 1-.465-.252a31.147 31.147 0 0 1-4.803-3.34C3.8 15.572 1 12.331 1 8.513C1 5.052 3.829 2.5 6.736 2.5C9.03 2.5 10.881 3.726 12 5.605C13.12 3.726 14.97 2.5 17.264 2.5C20.17 2.5 23 5.052 23 8.514c0 3.818-2.801 7.06-5.389 9.262A31.146 31.146 0 0 1 14 20.408z" fill="currentColor"/></svg>`;

    function renderVotingUnit({ title, dataVote, voteCount, voteCasted, icon, castVote, }) {
        const handleClick = castVote
            ? voteCasted
                ? () => castVote(false)
                : () => castVote(true)
            : () => { };
        return $ `
		<button
			tabindex=0
			data-vote="${dataVote}"
			?data-active=${voteCasted}
			?disabled=${!castVote}
			title="${title}"
			@click=${handleClick}>
				<span>${icon}</span>
				<span>${voteCount}</span>
		</button>
	`;
    }

    function renderLiking(liking) {
        return renderVotingUnit({
            dataVote: "like",
            icon: liking.liked
                ? heartFillSvg
                : heartSvg,
            title: liking.liked
                ? "unlike this post"
                : "like this post",
            voteCount: liking.likes,
            voteCasted: liking.liked,
            castVote: liking.castLikeVote
                ? status => liking.castLikeVote(status)
                : undefined,
        });
    }

    var warningFillSvg = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 20 20"><g fill="none"><path d="M8.686 2.852L2.127 14.777A1.5 1.5 0 0 0 3.441 17H16.56a1.5 1.5 0 0 0 1.314-2.223L11.314 2.852a1.5 1.5 0 0 0-2.628 0zM10 6.75a.75.75 0 0 1 .75.75v4a.75.75 0 0 1-1.5 0v-4a.75.75 0 0 1 .75-.75zm.75 7a.75.75 0 1 1-1.5 0a.75.75 0 0 1 1.5 0z" fill="currentColor"/></g></svg>`;

    function renderReporting(reporting) {
        return renderVotingUnit({
            dataVote: "report",
            icon: reporting.reported
                ? warningFillSvg
                : warningSvg,
            title: reporting.reported
                ? "unreport this post"
                : "report this post",
            voteCount: reporting.reports,
            voteCasted: reporting.reported,
            castVote: reporting.castReportVote
                ? status => reporting.castReportVote(status)
                : undefined,
        });
    }

    function renderPostStructure({ postOptions, bar1, bubble, bar2, buttonBar }) {
        return $ `
		<div class=post data-post-id="${postOptions.postId ?? ""}">
			<div class=tophat>
				<xio-profile-card .user=${postOptions.author} show-details></xio-profile-card>
			</div>
			<div class="bar bar1">
				${bar1}
			</div>
			${bubble}
			<div class="bar bar2">
				${bar2}
			</div>
			${buttonBar
        ? $ `
					<div class=buttonbar>
						${buttonBar}
					</div>
				`
        : null}
		</div>
	`;
    }

    function renderPost(options) {
        const { author, content, timePosted, ...specificOptions } = options;
        switch (specificOptions.type) {
            case PostType.Question: {
                const { liking, reporting, deletePost, toggleAnswerEditor } = specificOptions;
                return renderPostStructure({
                    postOptions: options,
                    bar1: $ `
					${renderLiking(liking)}
				`,
                    bubble: renderBubble({
                        content,
                        timePosted,
                        editable: false,
                        handleValueChange: undefined,
                    }),
                    bar2: $ `
					${renderReporting(reporting)}
					${deletePost
                    ? $ `<a href="#" @click=${linkClick(deletePost)}>delete</a>`
                    : null}
					${toggleAnswerEditor
                    ? $ `<a href="#" @click=${linkClick(toggleAnswerEditor)}>answer</a>`
                    : null}
				`,
                    buttonBar: undefined,
                });
            }
            case PostType.Answer: {
                const { liking, reporting, deletePost } = specificOptions;
                return renderPostStructure({
                    postOptions: options,
                    bar1: $ `
					${renderLiking(liking)}
				`,
                    bubble: renderBubble({
                        content,
                        timePosted,
                        editable: false,
                        handleValueChange: undefined,
                    }),
                    bar2: $ `
					${renderReporting(reporting)}
					${deletePost
                    ? $ `<a href="#" @click=${linkClick(deletePost)}>delete</a>`
                    : null}
				`,
                    buttonBar: undefined,
                });
            }
            case PostType.Editor: {
                const { isPostable, postButtonText, changeDraftContent, submitPost } = specificOptions;
                return renderPostStructure({
                    postOptions: options,
                    bar1: null,
                    bubble: renderBubble({
                        content,
                        timePosted,
                        editable: true,
                        handleValueChange: changeDraftContent,
                    }),
                    bar2: null,
                    buttonBar: $ `
					<xio-button
						?disabled=${!isPostable}
						@click=${submitPost}
							>${postButtonText}</xio-button>
				`,
                });
            }
        }
    }

    function renderAnswer({ answer, questionId, modals, boardModel, canDeleteAnswer, }) {
        const permissions = boardModel.getPermissions();
        const canLike = permissions["like questions"];
        const canReport = permissions["report questions"];
        return renderPost({
            type: PostType.Answer,
            postId: answer.answerId,
            author: boardModel.getUser(answer.authorUserId),
            content: answer.content,
            timePosted: answer.timePosted,
            liking: {
                liked: answer.liked,
                likes: answer.likes,
                castLikeVote: canLike
                    ? like => boardModel.likeAnswer(questionId, answer.answerId, like)
                    : undefined,
            },
            reporting: {
                reported: answer.reported,
                reports: answer.reports,
                castReportVote: canReport
                    ? async (report) => {
                        const confirmed = report
                            ? await modals.confirm({
                                title: "Report answer?",
                                body: "Are you sure you want to submit a report against this answer?",
                                yes: { vibe: "negative", label: "Submit report" },
                                no: { vibe: "neutral", label: "Nevermind" },
                                focusNthElement: 2,
                            })
                            : true;
                        if (confirmed)
                            await boardModel.reportAnswer(questionId, answer.answerId, report);
                    }
                    : undefined,
            },
            deletePost: canDeleteAnswer(answer)
                ? async () => {
                    const confirmed = await modals.confirm({
                        title: "Delete answer?",
                        body: "Are you sure you want to delete this answer? This cannot be undone.",
                        yes: { vibe: "negative", label: "Delete answer" },
                        no: { vibe: "neutral", label: "Nevermind" },
                        focusNthElement: 2,
                    });
                    if (confirmed)
                        await boardModel.archiveAnswer(questionId, answer.answerId, true);
                }
                : undefined,
        });
    }

    function renderAnswerEditor({ now, boardModel, answerEditor, }) {
        const answerEditorState = answerEditor.getState();
        return $ `
		<div class="editor answer-editor">
			<div class=intro>
				<p class=heading>Post your answer</p>
			</div>
			${renderPost({
        author: boardModel.getAccess().user,
        type: PostType.Editor,
        timePosted: now,
        postButtonText: "post answer",
        content: answerEditorState.draftText,
        isPostable: answerEditorState.isPostable,
        submitPost: answerEditor.submitAnswer,
        changeDraftContent: answerEditor.actions.handleValueChange,
    })}
		</div>
	`;
    }

    function renderQuestion({ now, question, modals, boardModel, answerEditor, }) {
        const { questionId } = question;
        const access = boardModel.getAccess();
        const permissions = boardModel.getPermissions();
        const author = boardModel.getUser(question.authorUserId);
        const questionAuthorities = (() => {
            const isAuthor = (access && access.user)
                ? access.user.userId === author.userId
                : false;
            const canDelete = permissions["moderate questions"] || isAuthor;
            const canAnswer = permissions["answer questions"];
            const canLike = permissions["like questions"];
            const canReport = permissions["report questions"];
            return { canDelete, canAnswer, canLike, canReport };
        })();
        const handleDelete = async () => {
            const confirmed = await modals.confirm({
                title: "Delete question?",
                body: "Are you sure you want to delete this question? This cannot be undone.",
                yes: { vibe: "negative", label: "Delete question" },
                no: { vibe: "neutral", label: "Nevermind" },
                focusNthElement: 2,
            });
            if (confirmed)
                await boardModel.archiveQuestion(questionId, true);
        };
        const handleLike = (like) => {
            boardModel.likeQuestion(questionId, like);
        };
        const handleReport = async (report) => {
            const confirmed = report
                ? await modals.confirm({
                    title: "Report question?",
                    body: "Are you sure you want to submit a report against this question?",
                    yes: { vibe: "negative", label: "Submit report" },
                    no: { vibe: "neutral", label: "Nevermind" },
                    focusNthElement: 2,
                })
                : true;
            if (confirmed)
                await boardModel.reportQuestion(questionId, report);
        };
        const answerEditorState = answerEditor.getState();
        const canDeleteAnswer = (answer) => {
            const isAuthor = access?.user?.userId === answer.authorUserId;
            return permissions["moderate questions"] || isAuthor;
        };
        return $ `
		${renderPost({
        type: PostType.Question,
        author,
        content: question.content,
        deletePost: questionAuthorities.canDelete
            ? handleDelete
            : undefined,
        liking: {
            liked: question.liked,
            likes: question.likes,
            castLikeVote: questionAuthorities.canLike
                ? handleLike
                : undefined,
        },
        postId: question.questionId,
        reporting: {
            reported: question.reported,
            reports: question.reports,
            castReportVote: questionAuthorities.canReport
                ? handleReport
                : undefined,
        },
        timePosted: question.timePosted,
        toggleAnswerEditor: questionAuthorities.canAnswer
            ? answerEditor.actions.toggleEditMode
            : undefined,
    })}
		${answerEditorState.editMode
        ? renderAnswerEditor({ now, boardModel, answerEditor })
        : null}
		${question.answers.length ? $ `
			<ol part=answers-list>
				${question.answers.map(answer => $ `
					<li part=answer data-answer-id="${answer.answerId}">
						${renderAnswer({
        answer,
        modals,
        questionId,
        boardModel,
        canDeleteAnswer,
    })}
					</li>
				`)}
			</ol>
		` : null}
	`;
    }

    function makeEditorState() {
        return happystate({
            state: {
                draftText: "",
                isPostable: false,
            },
            actions: state => ({
                handleValueChange(event) {
                    state.draftText = event.detail.value;
                    state.isPostable = !!state.draftText;
                },
            }),
        });
    }

    function makeQuestionEditor({ requestUpdate, getTextInput, getBoardModel, }) {
        const { actions, getState, onStateChange } = makeEditorState();
        onStateChange(requestUpdate);
        const resetEditor = () => {
            const input = getTextInput();
            input.text = "";
        };
        return {
            actions,
            getState,
            getTextInput,
            submitQuestion: async () => {
                const { draftText } = getState();
                resetEditor();
                await getBoardModel().postQuestion({
                    content: draftText,
                });
            },
        };
    }

    /*
     * happyCombine is tricky to use because typescript types are tricky.
     * example:
     *     const happy = happyCombine(happy1)(happy2)(happy3).combine()
     * do take note:
     *  - you must end the curried chain with `.combine()`
     *
     *
     */
    function happyCombine(happy1) {
        return function (happy2) {
            const getHappy = () => ({
                actions: { ...happy1.actions, ...happy2.actions },
                getState: () => ({ ...happy1.getState(), ...happy2.getState() }),
                clearStateListeners: () => {
                    happy1.clearStateListeners();
                    happy2.clearStateListeners();
                },
                onStateChange: (listener) => {
                    const subscriptions = [
                        happy1.onStateChange(listener),
                        happy2.onStateChange(listener),
                    ];
                    return () => subscriptions.forEach(unsubscribe => unsubscribe());
                },
            });
            function more(happy3) {
                return happyCombine(getHappy())(happy3);
            }
            more.combine = getHappy;
            return more;
        };
    }

    function makeAnswerEditorGetter({ requestUpdate, getBoardModel, getTextInput, }) {
        const getRecord = strongRecordKeeper()(questionId => {
            const editorHappy = makeEditorState();
            const answerHappy = happystate({
                state: {
                    editMode: false,
                },
                actions: state => ({
                    toggleEditMode() {
                        state.editMode = !state.editMode;
                    },
                }),
            });
            const happy = happyCombine(editorHappy)(answerHappy).combine();
            happy.onStateChange(requestUpdate);
            const resetEditor = () => {
                const input = getTextInput(questionId);
                input.text = "";
            };
            return {
                ...happy,
                submitAnswer: async () => {
                    const { draftText } = happy.getState();
                    resetEditor();
                    happy.actions.toggleEditMode();
                    await getBoardModel().postAnswer(questionId, { content: draftText });
                },
            };
        });
        return (questionId) => getRecord(questionId);
    }

    function renderModerationPanel({ modals, board, archiveBoard }) {
        const handlePressPurgeButton = async () => {
            const confirmed = await modals.confirm({
                title: `Purge questions?`,
                body: `Are you sure you want to delete all the questions on the board "${board}"? This cannot be undone.`,
                yes: { vibe: "negative", label: "Purge all" },
                no: { vibe: "neutral", label: "Nevermind" },
                focusNthElement: 2,
            });
            if (confirmed)
                await archiveBoard();
        };
        return $ `
		<div class=questions-moderation-panel>
			<h3>moderate questions board "${board}"</h3>
			<xio-button
				class=purge-button
				@press=${handlePressPurgeButton}>
					Purge all questions
			</xio-button>
		</div>
	`;
    }

    function renderQuestionEditor({ now, access, postingOp, questionEditor, }) {
        const author = access?.user;
        const editorState = questionEditor.getState();
        return renderOp(postingOp, () => $ `
		<div class="editor question-editor" part=question-editor>
			<div class=intro>
				<p class=heading>Post a new question</p>
			</div>
			${renderPost({
        type: PostType.Editor,
        author,
        content: editorState.draftText,
        isPostable: editorState.isPostable,
        timePosted: now,
        postButtonText: "post question",
        submitPost: questionEditor.submitQuestion,
        changeDraftContent: questionEditor.actions.handleValueChange,
    })}
		</div>
	`);
    }

    var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$3 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$2 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XiomeQuestions_boardModel, _XiomeQuestions_questionEditor, _XiomeQuestions_getAnswerEditor, _XiomeQuestions_now;
    let BaseComponent = class BaseComponent extends ComponentWithShare {
    };
    BaseComponent = __decorate$4([
        mixinTicker(1000)
    ], BaseComponent);
    let XiomeQuestions = class XiomeQuestions extends BaseComponent {
        constructor() {
            super(...arguments);
            _XiomeQuestions_boardModel.set(this, void 0);
            _XiomeQuestions_questionEditor.set(this, makeQuestionEditor({
                getBoardModel: () => __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f"),
                requestUpdate: () => this.requestUpdate(),
                getTextInput: () => (this.shadowRoot.querySelector(".question-editor xio-text-input")),
            }));
            _XiomeQuestions_getAnswerEditor.set(this, makeAnswerEditorGetter({
                getBoardModel: () => __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f"),
                requestUpdate: () => this.requestUpdate(),
                getTextInput: (questionId) => (this.shadowRoot.querySelector(`[part="questions-list"] li[data-question-id="${questionId}"] xio-text-input`)),
            }));
            _XiomeQuestions_now.set(this, Date.now());
            this.board = "default";
        }
        tick() {
            __classPrivateFieldSet$2(this, _XiomeQuestions_now, Date.now(), "f");
        }
        init() {
            __classPrivateFieldSet$2(this, _XiomeQuestions_boardModel, this.share.questionsModel.makeBoardModel(this.board), "f");
            __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f").loadQuestions();
        }
        renderQuestionsBoard() {
            const now = __classPrivateFieldGet$3(this, _XiomeQuestions_now, "f");
            const { modals } = this.share;
            const questionEditor = __classPrivateFieldGet$3(this, _XiomeQuestions_questionEditor, "f");
            const { archiveBoard } = __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f");
            const access = __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f").getAccess();
            const board = __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f").getBoardName();
            const boardOp = __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f").getBoardOp();
            const postingOp = __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f").getPostingOp();
            const permissions = __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f").getPermissions();
            const questions = sortQuestions(__classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f").getQuestions(), access?.user?.userId);
            return renderOp(boardOp, () => $ `

			${permissions["moderate questions"]
            ? renderModerationPanel({ modals, board, archiveBoard })
            : null}

			${permissions["post questions"]
            ? renderQuestionEditor({ now, access, postingOp, questionEditor })
            : null}

			${questions.length > 0
            ? $ `
					<ol part=questions-list>
						${questions.map(question => $ `
							<li data-question-id="${question.questionId}">
								${renderQuestion({
                question,
                now: __classPrivateFieldGet$3(this, _XiomeQuestions_now, "f"),
                modals: this.share.modals,
                boardModel: __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f"),
                answerEditor: __classPrivateFieldGet$3(this, _XiomeQuestions_getAnswerEditor, "f").call(this, question.questionId),
            })}
							</li>
						`)}
					</ol>
				`
            : $ `<slot name=empty><p>Be the first to post a question!</p></slot>`}
		`);
        }
        render() {
            return __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f") && __classPrivateFieldGet$3(this, _XiomeQuestions_boardModel, "f").getBoardOp()
                ? this.renderQuestionsBoard()
                : null;
        }
    };
    _XiomeQuestions_boardModel = new WeakMap(), _XiomeQuestions_questionEditor = new WeakMap(), _XiomeQuestions_getAnswerEditor = new WeakMap(), _XiomeQuestions_now = new WeakMap();
    __decorate$4([
        e({ type: String, reflect: true })
    ], XiomeQuestions.prototype, "board", void 0);
    XiomeQuestions = __decorate$4([
        mixinStyles(styles$3)
    ], XiomeQuestions);

    function integrateQuestionsComponents({ models, modals }) {
        const { questionsModel } = models;
        return {
            XiomeQuestions: mixinHappy(questionsModel.onStateChange)(mixinShare({
                modals,
                questionsModel,
            })(XiomeQuestions)),
        };
    }

    var styles$2 = r$2 `

.container {
	display: block;
	width: 100%;
	max-width: 36em;
	padding: 0.5em !important;
	border: 1px solid;
}

.results {
	margin-top: 0.5em;
}

.userlist {
	list-style: none;
}

.userlist > li {
	display: flex;
	flex-direction: column;
	flex-wrap: wrap;
	background: #0002;
	padding: 0.5em;
	margin-top: 0.5em;
}

.userinfo {
	display: flex;
	flex-direction: row;
}

.userinfo xio-profile-card {
	flex: 1 1 auto;
}

.userinfo .controls {
	margin-left: 1em;
}

.userinfo .controls .edit[data-edit-mode] {
	color: lime;
	--xio-button-hover-color: lime;
}

.editwidget > div {
	margin-top: 1em;
}

.editwidget header + * {
	margin-top: 0.25em;
}

.editwidget header small {
	font-size: inherit;
	opacity: 0.6;
}

.editwidget ul {
	list-style: none;
}

.editwidget .allprivileges li {
	display: inline-block;
	font-size: 0.75em;
	padding: 0.1em 0.3em;
	margin: 0.2em 0.1em;
	border: 1px solid;
	border-radius: 1em;
}

`;

    function makeUserStates({ getUserResultsOp, rerender, }) {
        const states = new Map();
        function cleanupObsoleteStates() {
            const userIdsPendingRemovalFromState = [];
            const userResultsOp = getUserResultsOp();
            if (ops.ready(userResultsOp)) {
                const userResults = ops.value(userResultsOp);
                for (const stateUserId of states.keys()) {
                    const userIsGone = !userResults.find(({ user }) => user.userId === stateUserId);
                    if (userIsGone)
                        userIdsPendingRemovalFromState.push(stateUserId);
                }
            }
            for (const obsoleteUserId of userIdsPendingRemovalFromState)
                states.delete(obsoleteUserId);
        }
        function obtainStateForUser(userId) {
            let state = states.get(userId);
            if (!state) {
                const newState = {
                    editMode: false,
                    toggleEditMode() {
                        newState.editMode = !newState.editMode;
                        rerender();
                    },
                };
                state = newState;
                states.set(userId, state);
            }
            return state;
        }
        return {
            cleanupObsoleteStates,
            obtainStateForUser,
        };
    }

    function sortAssignableFirst(roles) {
        const assignable = roles.filter(role => role.assignable);
        const notAssignable = roles.filter(role => !role.assignable);
        return [...assignable, ...notAssignable];
    }
    function renderRoleButton(role, onClick) {
        return $ `
		<xio-button
			?disabled=${!role.assignable}
			title=${role.roleId}
			data-role-id=${role.roleId}
			@press=${() => onClick(role)}>
				${role.label}
		</xio-button>
	`;
    }
    function renderPrivilegeUserHas(privilege) {
        return $ `
		<li
			title="${privilege.privilegeId}"
			data-privilege-id="${privilege.privilegeId}">
				${privilege.label}
		</li>
	`;
    }
    function renderEditWidget({ permissions, administrativeModel, updateLocalUserResultsCache, userResult: { user: { userId }, roleIds }, blur, search, }) {
        const rolesAssigned = sortAssignableFirst(roleIds
            .map(id => permissions.roles.find(role => role.roleId === id))
            .filter(id => !!id));
        const rolesAvailable = sortAssignableFirst(permissions.roles
            .filter(role => !roleIds.includes(role.roleId))
            .filter(id => !!id));
        const privilegesUserHas = permissions.privileges
            .filter(privilege => {
            const rolesWithThisPrivilege = permissions.rolesHavePrivileges
                .filter(r => r.active && r.privilegeId === privilege.privilegeId);
            const rolesUserHas = rolesWithThisPrivilege
                .filter(r => roleIds.includes(r.roleId));
            return rolesUserHas.length > 0;
        });
        async function ifChangingSelfThenReauthorize() {
            if (userId === administrativeModel.getAccess()?.user?.userId)
                await administrativeModel.reauthorize();
        }
        async function clickToAssign({ roleId }) {
            await administrativeModel.assignRoleToUser({
                userId,
                roleId,
                isPublic: true,
                timeframeEnd: undefined,
                timeframeStart: undefined,
            });
            updateLocalUserResultsCache.assignRole(userId, roleId);
            blur();
            await ifChangingSelfThenReauthorize();
            await search();
        }
        async function clickToRevoke({ roleId }) {
            await administrativeModel.revokeRoleFromUser({
                userId,
                roleId,
            });
            updateLocalUserResultsCache.revokeRole(userId, roleId);
            blur();
            await ifChangingSelfThenReauthorize();
            await search();
        }
        return $ `
		<div class=editwidget>
			<div class=available>
				<header>roles available <small>(click to assign)</small></header>
				<div>
					${rolesAvailable.map(role => renderRoleButton(role, clickToAssign))}
				</div>
			</div>
			<div class=assigned>
				<header>roles assigned <small>(click to revoke)</small></header>
				<div>
					${rolesAssigned.map(role => renderRoleButton(role, clickToRevoke))}
				</div>
			</div>
			<div class=allprivileges>
				<header>user has these privileges</header>
				<ul>
					${privilegesUserHas.map(renderPrivilegeUserHas)}
				</ul>
			</div>
		</div>
	`;
    }

    var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$2 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$1 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XiomeManageUsers_search, _XiomeManageUsers_lastSearch;
    let XiomeManageUsers = class XiomeManageUsers extends ComponentWithShare {
        constructor() {
            super(...arguments);
            this.userResults = ops.ready([]);
            this.updateLocalUserResultsCache = {
                assignRole: (userId, roleId) => {
                    if (!ops.ready(this.userResults))
                        throw new Error("error updating user cache");
                    const userResults = ops.value(this.userResults);
                    this.userResults = ops.ready(userResults.map(result => result.user.userId === userId
                        ? { user: result.user, roleIds: [...result.roleIds, roleId] }
                        : result));
                },
                revokeRole: (userId, roleId) => {
                    if (!ops.ready(this.userResults))
                        throw new Error("error updating user cache");
                    const userResults = ops.value(this.userResults);
                    this.userResults = ops.ready(userResults.map(result => result.user.userId === userId
                        ? { user: result.user, roleIds: result.roleIds.filter(id => id !== roleId) }
                        : result));
                },
            };
            this.userStates = makeUserStates({
                getUserResultsOp: () => this.userResults,
                rerender: () => this.requestUpdate(),
            });
            _XiomeManageUsers_search.set(this, "");
            _XiomeManageUsers_lastSearch.set(this, "");
            this.commitSearch = async () => {
                const isRedundantSearch = __classPrivateFieldGet$2(this, _XiomeManageUsers_search, "f") === __classPrivateFieldGet$2(this, _XiomeManageUsers_lastSearch, "f");
                __classPrivateFieldSet$1(this, _XiomeManageUsers_lastSearch, __classPrivateFieldGet$2(this, _XiomeManageUsers_search, "f"), "f");
                if (!isRedundantSearch) {
                    this.userResults = ops.ready([]);
                    if (__classPrivateFieldGet$2(this, _XiomeManageUsers_search, "f"))
                        await ops.operation({
                            setOp: op => this.userResults = op,
                            promise: this.share.administrativeModel.searchUsers({
                                term: __classPrivateFieldGet$2(this, _XiomeManageUsers_search, "f"),
                            })
                        });
                }
                this.userStates.cleanupObsoleteStates();
            };
            this.commitSearchSoon = debounce(1000, this.commitSearch);
            this.searchChange = (event) => {
                __classPrivateFieldSet$1(this, _XiomeManageUsers_search, event.detail.value ?? "", "f");
                this.commitSearchSoon();
            };
            this.enterPress = () => {
                this.commitSearch();
            };
        }
        init() {
            this.share.administrativeModel.initialize();
        }
        render() {
            const { permissionsOp } = this.share.administrativeModel.state;
            const allowed = this.share.administrativeModel
                .isAllowed("administrate user roles");
            const renderUser = (userResult) => {
                const { user } = userResult;
                const state = this.userStates.obtainStateForUser(user.userId);
                return $ `
				<li>
					<div class=userinfo>
						<xio-profile-card
							.user=${user}
							show-details
						></xio-profile-card>
						<div class=controls>
							<xio-button
								class=edit
								?data-edit-mode=${state.editMode}
								@press=${state.toggleEditMode}>
									${wrenchSvg}
							</xio-button>
						</div>
					</div>
					${state.editMode
                ? renderOp(permissionsOp, permissions => renderEditWidget({
                    userResult,
                    permissions,
                    administrativeModel: this.share.administrativeModel,
                    updateLocalUserResultsCache: this.updateLocalUserResultsCache,
                    blur: () => {
                        const activeElement = document.activeElement;
                        if (activeElement)
                            activeElement.blur();
                    },
                    search: () => this.commitSearch(),
                }))
                : null}
				</li>
			`;
            };
            return $ `
			<div class=container>

				${allowed ? $ `
					<xio-text-input
						placeholder="search for users"
						.validator=${validateUserSearchTerm}
						@valuechange=${this.searchChange}
						@enterpress=${this.enterPress}
					></xio-text-input>

					<div class=results>
						${renderOp(this.userResults, results => results.length > 0
            ? $ `
								<ol class=userlist>
									${results.map(renderUser)}
								</ol>
							`
            : $ `
								<div class=noresults>
									no results
								</div>
							`)}
					</div>
				` : $ `
					<p>you are not permitted to administrate user roles</p>
				`}

			</div>
		`;
        }
    };
    _XiomeManageUsers_search = new WeakMap(), _XiomeManageUsers_lastSearch = new WeakMap();
    __decorate$3([
        e()
    ], XiomeManageUsers.prototype, "userResults", void 0);
    XiomeManageUsers = __decorate$3([
        mixinStyles(styles$2)
    ], XiomeManageUsers);

    function integrateAdministrativeComponents({ models, modals }) {
        const { administrativeModel } = models;
        return {
            XiomeManageUsers: (mixinSnapstateSubscriptions(administrativeModel.subscribe)(mixinShare({
                modals,
                administrativeModel,
            })(XiomeManageUsers))),
        };
    }

    var clearIcon = y `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-trash"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;

    var unmuteIcon = y `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`;

    var onOffIcon = y `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-power"><path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line></svg>`;

    var muteIcon = y `
<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-volume-x"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;

    var deleteIcon = y `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x-circle"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`;

    function renderChatPost({ post, isModerator, mute, remove, mutedIds, }) {
        const postTime = formatDate(post.time);
        const userIsMuted = mutedIds.includes(post.userId);
        return $ `
		<li data-post="${post.postId}">
			<header>
				<span class=nickname>${post.nickname}</span>
				${isModerator
        ? $ `
						<span class=moderation>
							<xio-button
								title="mute user"
								@press=${mute}
								?disabled=${userIsMuted}>
									${muteIcon}
							</xio-button>
							<xio-button
								title="delete post"
								@press=${remove}>
									${deleteIcon}
							</xio-button>
						</span>
					`
        : null}
				<xio-id class=userid title="copy user id" id="${post.userId}"></xio-id>
			</header>
			<div>
				<p class=content>
					${post.content}
					<span class=time title="${postTime.date} ${postTime.zone}">
						${postTime.time}
					</span>
				</p>
			</div>
		</li>
	`;
    }

    function renderChatAuthorship({ sendable, onSendClick, onEnterPress, onValidityChange, }) {
        function handleContentChange(event) {
            const value = event.detail.value;
            onValidityChange(value !== undefined);
        }
        return $ `
		<div class=authorship>

			<xio-text-input
				textarea
				.validator=${validateChatContent}
				@valuechange=${handleContentChange}
				@enterpress=${onEnterPress}>
			</xio-text-input>

			<xio-button
				?disabled=${!sendable}
				@press=${onSendClick}>
					send message
			</xio-button>
		</div>
	`;
    }

    var chatHistoryCss = r$2 `

.history ol,
.history slot[name="no-messages"] {
	height: var(--xiome-chat-history-height);
	overflow-y: auto;
	scrollbar-color: #0004 #0002;
	scrollbar-width: thin;
}

.history ol::-webkit-scrollbar {
	width: 0.4em;
}

.history ol::-webkit-scrollbar-thumb {
	border-radius: 1em;
	background: #0004;
}

.history ol::-webkit-scrollbar-thumb:hover {
	background: #0008;
}

.history ol::-webkit-scrollbar-thumb:active {
	background: #000a;
}

.history ol::-webkit-scrollbar-track {
	border-radius: 1em;
	background: #0002;
}

slot[name="no-messages"] {
	opacity: 0.5;
	display: flex;
	justify-content: center;
	align-items: center;
	text-align: center;
}

.history li + li {
	margin-top: 0.75em;
}

.history li > header {
	display: flex;
	flex-direction: row;
	align-items: center;
	gap: 0.5em;
}

.history li .moderation {
	opacity: 0.5;
}

.history li > header > span {
	display: flex;
	align-items: center;
}

.history li > header > span > xio-button {
	--xio-button-border: none;
	--xio-button-padding: 0 0.3em;
}

.history li .nickname {
	font-size: 1em;
	opacity: var(--xio-chat-nickname-opacity, 0.5);
	color: var(--xio-chat-nickname-color, currentColor);
}

.history li .userid {
	font-size: 1em;
	opacity: var(--xio-chat-userid-opacity, 0.5);
	color: var(--xio-chat-userid-color, currentColor);
}

.history li .content {
	font-size: 1.3em;
	word-break: break-word;
}

.history li .time {
	opacity: 0.3;
	font-size: 1rem;
}

`;

    var xiomeChatCss = r$2 `

:host {
	display: block;
	max-width: 56em;
	--xiome-chat-history-height: var(--xiome-chat-history-height, 20em);
}

.modheader {
	display: flex;
	flex-wrap: wrap;
	flex-direction: row;
	align-items: end;
	padding: 0 1em;
}

.modheader > span:nth-child(1) {
	opacity: 0.5;
	padding: 0.2em 0;
}

.modheader > span:nth-child(2) {
	margin-left: auto;
}

xio-button {
	--xio-button-disabled-border-style: none;
}

.modheader xio-button {
	--xio-button-border: none;
}

.modheader xio-button::part(button-slot) {
	display: flex;
	align-items: center;
	gap: 0.5em;
}

.history {
	padding: 1em;
	border: 1px solid;
	border-radius: 0.5em 0.5em 0 0;
	border-bottom: 0;
}

.chatbox xiome-login-panel {
	display: block;
	border: 1px solid currentColor;
	border-radius: 0 0 0.5em 0.5em;
}

.chatbox xiome-login-panel[status="logged-out"] {
	padding: 1em;
}

.chatbox slot[name="offline"],
.chatbox slot[name="muted"] {
	display: block;
	padding: 2em 1em;
	text-align: center;
}

.chatbox slot[name="offline"] {
	border: 1px solid currentColor;
	border-radius: 0.5em;
}

${chatHistoryCss}

.authorship {
	display: flex;
	align-items: stretch;
	Xborder: 1px solid;
}

.authorship xio-text-input {
	border-right: 1px solid;
	--xio-text-input-height: 6em;
	--xio-text-input-label-opacity: 0.5;
	--xio-text-input-border: 0;
	--xio-text-input-pad: 1em;
}

.authorship xio-button {
	height: 6em;
	flex: 1 1 auto;
	--xio-button-border: 0;
	--xio-button-disabled-border-style: none;
}

.authorship xio-button::part(button) {
	width: 100%;
}

.authorship .inputlabel {
	display: block;
	opacity: 0.5;
	padding: 0.2em 0;
	margin-left: 1em;
}

`;

    var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$1 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeChat_instances, _XiomeChat_model_get, _XiomeChat_room, _XiomeChat_dispose, _XiomeChat_scrolledToBottom, _XiomeChat_updateScrolledToBottom, _XiomeChat_coordinateScrollingBehavior, _XiomeChat_renderModerationHeader, _XiomeChat_renderHistory, _XiomeChat_lastSend, _XiomeChat_updateTooSoon, _XiomeChat_subscribeTooSoon, _XiomeChat_postToChat, _XiomeChat_renderParticipation;
    let XiomeChat = class XiomeChat extends ComponentWithShare {
        constructor() {
            super(...arguments);
            _XiomeChat_instances.add(this);
            this.room = "default";
            _XiomeChat_room.set(this, void 0);
            _XiomeChat_dispose.set(this, () => { });
            _XiomeChat_scrolledToBottom.set(this, true);
            _XiomeChat_coordinateScrollingBehavior.set(this, () => {
                const ol = this.shadowRoot.querySelector(".history ol");
                if (ol) {
                    if (ol.scrollHeight <= ol.clientHeight)
                        __classPrivateFieldSet(this, _XiomeChat_scrolledToBottom, true, "f");
                    else if (__classPrivateFieldGet$1(this, _XiomeChat_scrolledToBottom, "f"))
                        ol.scrollTo(0, ol.scrollHeight - ol.clientHeight);
                }
                else
                    __classPrivateFieldSet(this, _XiomeChat_scrolledToBottom, true, "f");
            });
            this.draftValid = false;
            this.tooSoon = false;
            _XiomeChat_lastSend.set(this, Date.now());
            _XiomeChat_updateTooSoon.set(this, () => {
                const since = Date.now() - __classPrivateFieldGet$1(this, _XiomeChat_lastSend, "f");
                this.tooSoon = since < chatPostCoolOff;
            });
            _XiomeChat_postToChat.set(this, (event) => {
                event.preventDefault();
                const { tooSoon } = this;
                if (!tooSoon) {
                    const { value } = this.authorshipInput;
                    const draft = { content: value };
                    __classPrivateFieldSet(this, _XiomeChat_lastSend, Date.now(), "f");
                    this.authorshipInput.text = "";
                    __classPrivateFieldGet$1(this, _XiomeChat_updateTooSoon, "f").call(this);
                    __classPrivateFieldGet$1(this, _XiomeChat_room, "f").post(draft);
                }
            });
        }
        subscribe() {
            __classPrivateFieldGet$1(this, _XiomeChat_instances, "a", _XiomeChat_model_get).session(this.room)
                .then(({ room, dispose }) => {
                __classPrivateFieldSet(this, _XiomeChat_room, room, "f");
                __classPrivateFieldSet(this, _XiomeChat_dispose, dispose, "f");
            })
                .then(() => this.requestUpdate());
            const unsubs = [
                super.subscribe(),
                () => __classPrivateFieldGet$1(this, _XiomeChat_dispose, "f").call(this),
                __classPrivateFieldGet$1(this, _XiomeChat_instances, "m", _XiomeChat_subscribeTooSoon).call(this),
                __classPrivateFieldGet$1(this, _XiomeChat_instances, "a", _XiomeChat_model_get).subscribeToChange(__classPrivateFieldGet$1(this, _XiomeChat_coordinateScrollingBehavior, "f")),
            ];
            return () => {
                for (const unsub of unsubs)
                    unsub();
            };
        }
        render() {
            return renderOp(__classPrivateFieldGet$1(this, _XiomeChat_instances, "a", _XiomeChat_model_get).state.connectionOp, () => $ `
			<div class=chatbox>
				${__classPrivateFieldGet$1(this, _XiomeChat_room, "f") ?
            $ `
						${__classPrivateFieldGet$1(this, _XiomeChat_instances, "m", _XiomeChat_renderModerationHeader).call(this)}
						${__classPrivateFieldGet$1(this, _XiomeChat_room, "f")?.status === ChatStatus.Online
                ? [
                    __classPrivateFieldGet$1(this, _XiomeChat_instances, "m", _XiomeChat_renderHistory).call(this),
                    __classPrivateFieldGet$1(this, _XiomeChat_instances, "m", _XiomeChat_renderParticipation).call(this),
                ]
                : $ `
								<slot name=offline>
									chat is offline
								</slot>
							`}
					` :
            null}
			</div>
		`);
        }
    };
    _XiomeChat_room = new WeakMap(), _XiomeChat_dispose = new WeakMap(), _XiomeChat_scrolledToBottom = new WeakMap(), _XiomeChat_coordinateScrollingBehavior = new WeakMap(), _XiomeChat_lastSend = new WeakMap(), _XiomeChat_updateTooSoon = new WeakMap(), _XiomeChat_postToChat = new WeakMap(), _XiomeChat_instances = new WeakSet(), _XiomeChat_model_get = function _XiomeChat_model_get() {
        return this.share.chatModel;
    }, _XiomeChat_updateScrolledToBottom = function _XiomeChat_updateScrolledToBottom() {
        const ol = this.shadowRoot.querySelector("ol");
        const { scrollTop, scrollHeight, clientHeight } = ol;
        const scrollTotal = scrollHeight - clientHeight;
        const scrollFromBottom = scrollTotal - scrollTop;
        __classPrivateFieldSet(this, _XiomeChat_scrolledToBottom, scrollFromBottom < 50, "f");
    }, _XiomeChat_renderModerationHeader = function _XiomeChat_renderModerationHeader() {
        const status = __classPrivateFieldGet$1(this, _XiomeChat_room, "f").status;
        const toggleStatus = () => {
            __classPrivateFieldGet$1(this, _XiomeChat_room, "f").setRoomStatus(__classPrivateFieldGet$1(this, _XiomeChat_room, "f").status === ChatStatus.Offline
                ? ChatStatus.Online
                : ChatStatus.Offline);
        };
        const muteCount = __classPrivateFieldGet$1(this, _XiomeChat_room, "f").muted.length;
        return __classPrivateFieldGet$1(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.moderateAllChats
            ? $ `
				<header class=modheader>
					<span>room="${this.room}"</span>
					<span>
						<xio-button
							title="unmute ${muteCount} users"
							?disabled=${muteCount === 0}
							@press=${() => __classPrivateFieldGet$1(this, _XiomeChat_room, "f").unmuteAll()}>
								${unmuteIcon} ${muteCount}
						</xio-button>
						<xio-button
							title="clear chat room"
							@press=${() => __classPrivateFieldGet$1(this, _XiomeChat_room, "f").clear()}>
								${clearIcon}
						</xio-button>
						<xio-button
							title="set chat ${status === ChatStatus.Offline ? "online" : "offline"}"
							@press=${toggleStatus}>
								${onOffIcon}
						</xio-button>
					</span>
				</header>
			`
            : null;
    }, _XiomeChat_renderHistory = function _XiomeChat_renderHistory() {
        return $ `
			<div class=history>
				${__classPrivateFieldGet$1(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.viewAllChats
        ? $ `
						${__classPrivateFieldGet$1(this, _XiomeChat_room, "f").posts.length
            ? $ `
								<ol @scroll=${__classPrivateFieldGet$1(this, _XiomeChat_instances, "m", _XiomeChat_updateScrolledToBottom)}>
									${__classPrivateFieldGet$1(this, _XiomeChat_room, "f").posts.map(post => renderChatPost({
                post,
                isModerator: __classPrivateFieldGet$1(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.moderateAllChats,
                mute: () => __classPrivateFieldGet$1(this, _XiomeChat_room, "f").mute(post.userId),
                remove: () => __classPrivateFieldGet$1(this, _XiomeChat_room, "f").remove([post.postId]),
                mutedIds: __classPrivateFieldGet$1(this, _XiomeChat_room, "f").muted
            }))}
								</ol>
							`
            : $ `
								<slot name=no-messages>
									no messages
								</slot>
							`}
					`
        : $ `
						<slot name=cannot-view>
							you are not privileged to view the chat
						</slot>
					`}
			</div>
		`;
    }, _XiomeChat_subscribeTooSoon = function _XiomeChat_subscribeTooSoon() {
        const interval = setInterval(__classPrivateFieldGet$1(this, _XiomeChat_updateTooSoon, "f"), 1000);
        return () => clearInterval(interval);
    }, _XiomeChat_renderParticipation = function _XiomeChat_renderParticipation() {
        const authorshipArea = () => {
            return __classPrivateFieldGet$1(this, _XiomeChat_room, "f").weAreBanned
                ? $ `<slot name=banned>you are banned</slot>`
                : __classPrivateFieldGet$1(this, _XiomeChat_room, "f").weAreMuted
                    ? $ `<slot name=muted>you are muted</slot>`
                    : renderChatAuthorship({
                        sendable: !!this.draftValid && !this.tooSoon,
                        onSendClick: __classPrivateFieldGet$1(this, _XiomeChat_postToChat, "f"),
                        onEnterPress: __classPrivateFieldGet$1(this, _XiomeChat_postToChat, "f"),
                        onValidityChange: valid => this.draftValid = valid,
                    });
        };
        return $ `
			<xiome-login-panel>
				${whenOpReady(__classPrivateFieldGet$1(this, _XiomeChat_instances, "a", _XiomeChat_model_get).state.accessOp, () => $ `
					<slot name=logged-out slot=logged-out>
						login to participate in the chat
					</slot>
					<div class=participation>
						${__classPrivateFieldGet$1(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.participateInAllChats
        ? authorshipArea()
        : $ `
								<slot name=cannot-participate>
									you do not have privilege to participate in the chat
								</slot>
							`}
					</div>
				`)}
			</xiome-login-panel>
		`;
    };
    __decorate$2([
        e({ type: String })
    ], XiomeChat.prototype, "room", void 0);
    __decorate$2([
        e()
    ], XiomeChat.prototype, "draftValid", void 0);
    __decorate$2([
        i(".authorship xio-text-input")
    ], XiomeChat.prototype, "authorshipInput", void 0);
    __decorate$2([
        e()
    ], XiomeChat.prototype, "tooSoon", void 0);
    XiomeChat = __decorate$2([
        mixinStyles(xiomeChatCss)
    ], XiomeChat);

    function integrateChatComponents({ models, modals }) {
        const { chatModel } = models;
        return {
            XiomeChat: (mixinSnapstateSubscriptions(chatModel.subscribe)(mixinShare({
                modals,
                chatModel,
            })(XiomeChat))),
        };
    }

    var styles$1 = r$2 `

:host {
	display: block;
}

[data-tab] {
	font-weight: normal;
}

[data-tab][data-active='true'] {
	font-weight: bold;
	color: bisque;
}

`;

    var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeNotes_instances, _XiomeNotes_model, _XiomeNotes_cacheDetails, _XiomeNotes_cache, _XiomeNotes_renderTabs, _XiomeNotes_renderNotes, _XiomeNotes_renderPagination, _XiomeNotes_renderButtonbar, _XiomeNotes_renderBasedOnStateOfNotesArray;
    let XiomeNotes = class XiomeNotes extends ComponentWithShare {
        constructor() {
            super(...arguments);
            _XiomeNotes_instances.add(this);
            _XiomeNotes_model.set(this, this.share.notesModel);
            _XiomeNotes_cacheDetails.set(this, this.share.notesModel.createNotesCacheDetails());
            _XiomeNotes_cache.set(this, __classPrivateFieldGet(this, _XiomeNotes_cacheDetails, "f").cache);
        }
        async init() {
            await __classPrivateFieldGet(this, _XiomeNotes_model, "f").initialize();
        }
        subscribe() {
            const unsubs = [
                super.subscribe(),
                __classPrivateFieldGet(this, _XiomeNotes_cacheDetails, "f").setup(),
                __classPrivateFieldGet(this, _XiomeNotes_cache, "f").subscribe(() => this.requestUpdate()),
            ];
            if (__classPrivateFieldGet(this, _XiomeNotes_model, "f").isLoggedIn) {
                __classPrivateFieldGet(this, _XiomeNotes_cache, "f").fetchAppropriateNotes();
            }
            return () => unsubs.forEach(unsub => unsub());
        }
        render() {
            return renderOp(__classPrivateFieldGet(this, _XiomeNotes_model, "f").state.accessOp, access => access?.user
                ? $ `
					${__classPrivateFieldGet(this, _XiomeNotes_instances, "m", _XiomeNotes_renderBasedOnStateOfNotesArray).call(this)}
				`
                : $ `
					<slot name="logged-out">
						you must be logged in to see your notifications
					</slot>
				`);
        }
    };
    _XiomeNotes_model = new WeakMap(), _XiomeNotes_cacheDetails = new WeakMap(), _XiomeNotes_cache = new WeakMap(), _XiomeNotes_instances = new WeakSet(), _XiomeNotes_renderTabs = function _XiomeNotes_renderTabs() {
        const { old } = __classPrivateFieldGet(this, _XiomeNotes_cache, "f").cacheState;
        const { switchTabNew, switchTabOld } = __classPrivateFieldGet(this, _XiomeNotes_cache, "f");
        return $ `
			<div class=tabs>
				<xio-button
					@press=${switchTabNew}
					data-tab="new"
					?data-active=${!old}>
						new
				</xio-button>
				<xio-button 
					@press=${switchTabOld}
					data-tab="old"
					?data-active=${old}>
						old
				</xio-button>
			</div>
		`;
    }, _XiomeNotes_renderNotes = function _XiomeNotes_renderNotes() {
        const { old, notesOp } = __classPrivateFieldGet(this, _XiomeNotes_cache, "f").cacheState;
        const { markSpecificNoteNew, markSpecificNoteOld } = __classPrivateFieldGet(this, _XiomeNotes_cache, "f");
        return renderOp(notesOp, notes => $ `
			<ol>
				${notes.map(note => $ `
					<li>
						<p>noteId: ${note.noteId}</p>
						<p>noteTitle: ${note.title}</p>
						<p>noteText: ${note.text}</p>
						<p>noteTime: ${note.time}</p>
						<p>noteFrom: ${note.from}</p>
						<p>noteTo: ${note.to}</p>
						<p>noteDetails: ${note.details}</p>
						<p>noteType: ${note.type}</p>
						${old ? $ `
							<xio-button @press=${() => markSpecificNoteNew(note.noteId)}>
								+
							</xio-button>
						` : $ `
							<xio-button @press=${() => markSpecificNoteOld(note.noteId)}>
								x
							</xio-button>
						`}
					</li>
				`)}
			</ol>
		`);
    }, _XiomeNotes_renderPagination = function _XiomeNotes_renderPagination() {
        const { pageNumber } = __classPrivateFieldGet(this, _XiomeNotes_cache, "f").cacheState;
        const { nextPage, previousPage, totalPages, isNextPageAvailable, isPreviousPageAvailable, } = __classPrivateFieldGet(this, _XiomeNotes_cache, "f");
        return $ `
			${(isNextPageAvailable || isPreviousPageAvailable)
        ? $ `
				<xio-button
					?disabled=${!isPreviousPageAvailable}
					@press=${previousPage}>
						previous
				</xio-button>
				<span>
					${pageNumber} / ${totalPages}
				</span>
				<xio-button
					?disabled=${!isNextPageAvailable}
					@press=${nextPage}>
						next
				</xio-button>
				`
        : null}
		`;
    }, _XiomeNotes_renderButtonbar = function _XiomeNotes_renderButtonbar() {
        const { old } = __classPrivateFieldGet(this, _XiomeNotes_cache, "f").cacheState;
        const { markAllNotesOld } = __classPrivateFieldGet(this, _XiomeNotes_cache, "f");
        return $ `
			<div class=buttonbar>
				${old
        ? null
        : $ `
						<xio-button @press=${markAllNotesOld}>
							mark all old
						</xio-button>
					`}
			</div>
		`;
    }, _XiomeNotes_renderBasedOnStateOfNotesArray = function _XiomeNotes_renderBasedOnStateOfNotesArray() {
        const { old, notesOp } = __classPrivateFieldGet(this, _XiomeNotes_cache, "f").cacheState;
        return $ `
			${ops.value(notesOp)?.length === 0
        ? $ `
					${__classPrivateFieldGet(this, _XiomeNotes_instances, "m", _XiomeNotes_renderTabs).call(this)}
					<slot name="empty">
						you have no ${old ? 'old' : 'new'} notifications
					</slot>
				`
        : $ `
					${__classPrivateFieldGet(this, _XiomeNotes_instances, "m", _XiomeNotes_renderTabs).call(this)}
					${__classPrivateFieldGet(this, _XiomeNotes_instances, "m", _XiomeNotes_renderNotes).call(this)}
					${__classPrivateFieldGet(this, _XiomeNotes_instances, "m", _XiomeNotes_renderPagination).call(this)}
					${__classPrivateFieldGet(this, _XiomeNotes_instances, "m", _XiomeNotes_renderButtonbar).call(this)}
				`}
		`;
    };
    XiomeNotes = __decorate$1([
        mixinStyles(styles$1)
    ], XiomeNotes);

    var bell = y `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-bell"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>`;

    var styles = r$2 `

:host {
	display: inline-block;
	--xiome-notes-indicator-count-size: 1em;
	--xiome-notes-indicator-color: red;
	--xiome-notes-indicator-bleedout: 0em;
	font-size: var(--xiome-notes-indicator-size, 1em);
	width: var(--xiome-notes-indicator-icon-size, 3em);
	position: relative;
}

:host([no-icon]) .bell {
	display: none;
}

.count {
	display: flex;
	justify-content: center;
	align-items: center;
	vertical-align: top;
	position: absolute;
	height: 1em;
	width: 1em;
	background-color: var(--xiome-notes-indicator-color);
	border-radius: 50%;
	text-align: center;
	right: var(--xiome-notes-indicator-bleedout);
	top: var(--xiome-notes-indicator-bleedout);
	font-weight: bold;
	color: white;
	font-size: var(--xiome-notes-indicator-count-size);
}
`;

    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeNotesIndicator = class XiomeNotesIndicator extends ComponentWithShare {
        constructor() {
            super(...arguments);
            this.noIcon = false;
        }
        render() {
            const bellSpan = $ `<span class="bell">${bell}</span>`;
            const { stats } = this.share.notesModel;
            return $ `
				${stats.newCount === 0 ? $ `${bellSpan}`
            : $ `
					<span class="count">${stats.newCount}</span>
					${bellSpan}
				`}
			`;
        }
    };
    __decorate([
        e({ attribute: "no-icon" })
    ], XiomeNotesIndicator.prototype, "noIcon", void 0);
    XiomeNotesIndicator = __decorate([
        mixinStyles(styles)
    ], XiomeNotesIndicator);

    function integrateNotesComponents({ models: { notesModel } }) {
        return {
            XiomeNotes: (mixinSnapstateSubscriptions(notesModel.stateSubscribe)(mixinShare({
                notesModel,
            })(XiomeNotes))),
            XiomeNotesIndicator: (mixinSnapstateSubscriptions(notesModel.stateSubscribe)(mixinShare({
                notesModel,
            })(XiomeNotesIndicator))),
        };
    }

    function getComponents(options) {
        return themeComponents(theme, {
            ...integrateXioComponents(),
            ...integrateExampleComponents(options),
            ...integrateAuthComponents(options),
            ...integrateQuestionsComponents(options),
            ...integrateAdministrativeComponents(options),
            ...integrateVideoComponents(options),
            ...integrateChatComponents(options),
            ...integrateNotesComponents(options),
            // // TODO reactivate store
            // ...xiomeStoreComponents(options),
        });
    }

    function trapFocus(element, focusNth) {
        const blueprint = `
		[focusable]:not([disabled])
		[tabindex]:not([disabled])
		a[href]:not([disabled])
		button:not([disabled])
		textarea:not([disabled])
		input[type="text"]:not([disabled])
		input[type="radio"]:not([disabled])
		input[type="checkbox"]:not([disabled])
		select:not([disabled])
	`;
        const selector = blueprint
            .split("\n")
            .map(l => l.trim())
            .filter(l => l.length)
            .join(", ");
        const focusable = Array.from(element.querySelectorAll(selector));
        if (focusable.length === 0)
            throw new Error("cannot trap focus: no focusable element");
        const firstFocusable = focusable[0];
        const lastFocusable = focusable[focusable.length - 1];
        const nthFocusable = focusable[focusNth - 1];
        setTimeout(() => nthFocusable.focus(), 0);
        element.onkeydown = event => {
            if (event.key === "Tab") {
                if (event.shiftKey) {
                    if (document.activeElement === firstFocusable) {
                        lastFocusable.focus();
                        event.preventDefault();
                    }
                }
                else {
                    if (document.activeElement === lastFocusable) {
                        firstFocusable.focus();
                        event.preventDefault();
                    }
                }
            }
        };
    }

    function preparePrompt(popup) {
        return async ({ title, input, body = null, yes = { label: "okay", vibe: "positive" }, no = { label: "nevermind", vibe: "neutral" }, focusNthElement = 1, blanketClickMeansCancel = true, }) => new Promise(resolve => {
            const xioTextInput = document.createElement("xio-text-input");
            xioTextInput.textarea = input.textarea ?? false;
            xioTextInput.parser = input.parser;
            xioTextInput.validator = input.validator;
            xioTextInput.textContent = input.label;
            function hasProblems() {
                void xioTextInput.value;
                return xioTextInput.problems.length !== 0;
            }
            function getCurrentValue() {
                return hasProblems()
                    ? undefined
                    : { value: xioTextInput.value };
            }
            function prepareFinishingMoves(controls) {
                return {
                    yes: () => {
                        const currentValue = getCurrentValue();
                        if (!hasProblems()) {
                            controls.close();
                            resolve(currentValue);
                        }
                    },
                    no: () => {
                        controls.close();
                        resolve(undefined);
                    },
                };
            }
            const { controls, modal } = popup({
                focusNthElement,
                onBlanketClick: blanketClickMeansCancel
                    ? controls => {
                        controls.close();
                        resolve(undefined);
                    }
                    : () => { },
                renderContent: controls => {
                    const finish = prepareFinishingMoves(controls);
                    return $ `
					<div data-confirm>
						${typeof title == "string" ? $ `<h2>${title}</h2>` : title}
						${typeof body == "string" ? $ `<p>${body}</p>` : body}
						${xioTextInput}
						<div data-buttons>
							<xio-button
								data-button=yes
								data-vibe=${yes.vibe}
								?disabled=${hasProblems()}
								@press=${finish.yes}>
									${yes.label}
							</xio-button>
							<xio-button
								data-button=no
								data-vibe=${no.vibe}
								@press=${finish.no}>
									${no.label}
							</xio-button>
						</div>
					</div>
				`;
                },
            });
            const finish = prepareFinishingMoves(controls);
            xioTextInput.onvaluechange = () => controls.rerender();
            xioTextInput.onenterpress = () => finish.yes();
            modal.addEventListener("keyup", ({ key }) => {
                if (key === "Escape")
                    finish.no();
            });
        });
    }

    function prepareConfirm(popup) {
        return async ({ title, body = null, yes = { label: "yes", vibe: "positive" }, no = { label: "no", vibe: "neutral" }, focusNthElement = 1, blanketClickMeansNo = true, }) => new Promise(resolve => {
            popup({
                focusNthElement,
                onBlanketClick: blanketClickMeansNo
                    ? controls => {
                        controls.close();
                        resolve(false);
                    }
                    : () => { },
                renderContent: controls => {
                    const onYes = () => {
                        controls.close();
                        resolve(true);
                    };
                    const onNo = () => {
                        controls.close();
                        resolve(false);
                    };
                    return $ `
					<div data-confirm>
						${typeof title == "string" ? $ `<h2>${title}</h2>` : title}
						${typeof body == "string" ? $ `<p>${body}</p>` : body}
						<div data-buttons>
							<xio-button
								focusable
								data-button=yes
								data-vibe="${yes.vibe}"
								@press=${onYes}>
									${yes.label}
							</xio-button>
							${no ? $ `
								<xio-button
									focusable
									data-button=no
									data-vibe="${no.vibe}"
									@press=${onNo}>
										${no.label}
								</xio-button>
							` : null}
						</div>
					</div>
				`;
                },
            });
        });
    }

    var modalSystemStyles = r$2 `

*:focus {
	outline: var(--focus-outline);
}

[data-modal-system] {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	display: block;
}

[data-modal-system] [data-blanket] {
	z-index: 101;
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	display: block;
	background: #0008;
	backdrop-filter: blur(10px);
}

[data-modal-system] [data-plate] {
	z-index: 102;
	position: absolute;
	top: 0;
	left: 0;
	right: 0;

	width: 96%;
	max-width: 32em;
	min-height: 1em;
	margin: 2em auto;

	background: linear-gradient(to bottom right, #fff, #ccc);
	color: #444;
}

[data-modal-system] [data-content]:focus {
	outline: unset;
}

[data-modal-system] [data-confirm] {
	padding: 1em;
}

[data-modal-system] [data-buttons] {
	margin-top: 1em;
	text-align: right;
}

[data-modal-system] [data-button] {
	--xio-button-hover-color: white;
	--xio-button-hover-background: #666;
}

[data-modal-system] [data-vibe=positive] {
	color: green;
	--xio-button-hover-color: white;
	--xio-button-hover-background: green;
}

[data-modal-system] [data-vibe=negative] {
	color: #a00;
	--xio-button-hover-color: white;
	--xio-button-hover-background: #a00;
}

`;

    function prepareModalSystemRendering(listModals) {
        const style = document.createElement("style");
        x(modalSystemStyles, style);
        const element = document.createElement("div");
        element.setAttribute("data-modal-system", "");
        function rerender() {
            x($ `
			${style}
			${listModals().map(modal => modal.render())}
		`, element);
        }
        return { element, rerender };
    }

    function prepareAlert(confirm) {
        return async ({ title, body = null, button = { label: "ok", vibe: "neutral" }, focusNthElement = 1, blanketClickMeansNo = true, }) => {
            await confirm({
                title,
                body,
                blanketClickMeansNo,
                yes: button,
                no: null,
            });
        };
    }

    function setupModalSystem() {
        let count = 0;
        const modals = new Map();
        const listModals = () => Array.from(modals.values());
        const { rerender, element } = prepareModalSystemRendering(listModals);
        function popup({ focusNthElement, renderContent, onBlanketClick }) {
            const id = count++;
            const controls = {
                rerender,
                close: () => {
                    modals.delete(id);
                    rerender();
                },
            };
            const top = window.pageYOffset
                ?? document.documentElement.scrollTop
                ?? document.body.scrollTop
                ?? 0;
            const handleBlanketClick = () => onBlanketClick(controls);
            modals.set(id, {
                render() {
                    return $ `
					<div data-modal="${id}">
						<div data-blanket @click=${handleBlanketClick}></div>
						<div data-plate style="top: ${top}px">
							${renderContent(controls)}
						</div>
					</div>
				`;
                },
            });
            rerender();
            const modal = element.querySelector(`[data-modal="${id}"]`);
            trapFocus(modal, focusNthElement);
            return { controls, modal };
        }
        const confirm = prepareConfirm(popup);
        return {
            modalsElement: element,
            modals: {
                popup,
                confirm,
                alert: prepareAlert(confirm),
                prompt: preparePrompt(popup),
            },
        };
    }

    function parseQuery(query = location.search) {
        const parsed = {};
        query = query.startsWith("?") ? query.slice(1) : query;
        query = query.startsWith("#") ? query.slice(1) : query;
        const parts = query.split("&");
        for (const part of parts) {
            const [key, ...rest] = part.split("=");
            const value = rest.join("=");
            parsed[decodeURIComponent(key)] = decodeURIComponent(value);
        }
        return parsed;
    }

    async function loginWithLinkTokenOrUseExistingLogin({ link, accessModel, onDone, onError, }) {
        const { hash } = new URL(link);
        const { login } = parseQuery(hash);
        if (login) {
            try {
                await accessModel.login(login);
            }
            catch (error) {
                onError(error);
            }
            onDone();
        }
        else
            await accessModel.useExistingLogin();
    }

    async function assembleAndInitializeFrontend({ appId, popups, storage, authMediator, remote, chatConnect, }) {
        const { modals, modalsElement } = setupModalSystem();
        const models = await assembleModels({
            appId,
            remote,
            popups,
            storage,
            authMediator,
            chatConnect,
        });
        const components = getComponents({ models, modals });
        await loginWithLinkTokenOrUseExistingLogin({
            accessModel: models.accessModel,
            link: window.location.toString(),
            onError: error => {
                if (error instanceof AccessLoginExpiredError)
                    modals.alert({
                        title: "expired login link",
                        body: "this login link has expired, please try again",
                    });
                else
                    modals.alert({
                        title: "invalid login link",
                        body: "something is wrong with this login link, please try again",
                    });
            },
            onDone: () => {
                window.location.hash = "";
            },
        });
        return { appId, components, models, modals, modalsElement };
    }

    async function assembleXiomeMock(mockConfig) {
        const connection = await mockConnect(mockConfig);
        connection.setMockLatency({ min: 200, max: 800 });
        const frontend = await assembleAndInitializeFrontend(connection);
        applyMockHacks({
            frontend,
            connection: connection,
        });
        return { ...connection, ...frontend };
    }

    function configReading(selector) {
        const element = document.querySelector(selector);
        if (!element)
            throw new Error(`${selector} is required`);
        return {
            attr(key) {
                return element.getAttribute(key) ?? undefined;
            },
        };
    }

    function readXiomeMock() {
        const { attr } = configReading("xiome-mock");
        const rawMode = attr("mode");
        return {
            mode: (rawMode === undefined
                ? undefined
                : rawMode === "platform"
                    ? "platform"
                    : "app")
        };
    }

    void async function xiomeMock() {
        const xiome = await assembleXiomeMock(readXiomeMock());
        document.body.prepend(xiome.modalsElement);
        registerComponents(xiome.components);
        window.xiome = xiome;
    }();

})();
//# sourceMappingURL=xiome-mock.bundle.js.map
