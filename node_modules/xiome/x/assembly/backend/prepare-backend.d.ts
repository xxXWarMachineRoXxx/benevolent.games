/// <reference types="stripe/types/crypto/crypto" />
/// <reference types="stripe/types/shared" />
/// <reference types="stripe/types/Errors" />
/// <reference types="stripe/types/OAuth" />
/// <reference types="stripe/types/Webhooks" />
/// <reference types="stripe/types/2020-08-27/AccountLinks" />
/// <reference types="stripe/types/2020-08-27/Accounts" />
/// <reference types="stripe/types/2020-08-27/AlipayAccounts" />
/// <reference types="stripe/types/2020-08-27/ApplePayDomains" />
/// <reference types="stripe/types/2020-08-27/ApplicationFees" />
/// <reference types="stripe/types/2020-08-27/Applications" />
/// <reference types="stripe/types/2020-08-27/Balance" />
/// <reference types="stripe/types/2020-08-27/BalanceTransactions" />
/// <reference types="stripe/types/2020-08-27/BankAccounts" />
/// <reference types="stripe/types/2020-08-27/BillingPortal/Configurations" />
/// <reference types="stripe/types/2020-08-27/BillingPortal/Sessions" />
/// <reference types="stripe/types/2020-08-27/BitcoinReceivers" />
/// <reference types="stripe/types/2020-08-27/BitcoinTransactions" />
/// <reference types="stripe/types/2020-08-27/Capabilities" />
/// <reference types="stripe/types/2020-08-27/Cards" />
/// <reference types="stripe/types/2020-08-27/Charges" />
/// <reference types="stripe/types/2020-08-27/Checkout/Sessions" />
/// <reference types="stripe/types/2020-08-27/ConnectCollectionTransfers" />
/// <reference types="stripe/types/2020-08-27/CountrySpecs" />
/// <reference types="stripe/types/2020-08-27/Coupons" />
/// <reference types="stripe/types/2020-08-27/CreditNoteLineItems" />
/// <reference types="stripe/types/2020-08-27/CreditNotes" />
/// <reference types="stripe/types/2020-08-27/CustomerBalanceTransactions" />
/// <reference types="stripe/types/2020-08-27/CustomerSources" />
/// <reference types="stripe/types/2020-08-27/Customers" />
/// <reference types="stripe/types/2020-08-27/Discounts" />
/// <reference types="stripe/types/2020-08-27/Disputes" />
/// <reference types="stripe/types/2020-08-27/EphemeralKeys" />
/// <reference types="stripe/types/2020-08-27/Events" />
/// <reference types="stripe/types/2020-08-27/ExchangeRates" />
/// <reference types="stripe/types/2020-08-27/ExternalAccounts" />
/// <reference types="stripe/types/2020-08-27/FeeRefunds" />
/// <reference types="stripe/types/2020-08-27/FileLinks" />
/// <reference types="stripe/types/2020-08-27/Files" />
/// <reference types="stripe/types/2020-08-27/Identity/VerificationReports" />
/// <reference types="stripe/types/2020-08-27/Identity/VerificationSessions" />
/// <reference types="stripe/types/2020-08-27/InvoiceItems" />
/// <reference types="stripe/types/2020-08-27/InvoiceLineItems" />
/// <reference types="stripe/types/2020-08-27/Invoices" />
/// <reference types="stripe/types/2020-08-27/IssuerFraudRecords" />
/// <reference types="stripe/types/2020-08-27/Issuing/Authorizations" />
/// <reference types="stripe/types/2020-08-27/Issuing/CardDetails" />
/// <reference types="stripe/types/2020-08-27/Issuing/Cardholders" />
/// <reference types="stripe/types/2020-08-27/Issuing/Cards" />
/// <reference types="stripe/types/2020-08-27/Issuing/Disputes" />
/// <reference types="stripe/types/2020-08-27/Issuing/Transactions" />
/// <reference types="stripe/types/2020-08-27/LineItems" />
/// <reference types="stripe/types/2020-08-27/LoginLinks" />
/// <reference types="stripe/types/2020-08-27/Mandates" />
/// <reference types="stripe/types/2020-08-27/OrderItems" />
/// <reference types="stripe/types/2020-08-27/OrderReturns" />
/// <reference types="stripe/types/2020-08-27/Orders" />
/// <reference types="stripe/types/2020-08-27/PaymentIntents" />
/// <reference types="stripe/types/2020-08-27/PaymentMethods" />
/// <reference types="stripe/types/2020-08-27/Payouts" />
/// <reference types="stripe/types/2020-08-27/Persons" />
/// <reference types="stripe/types/2020-08-27/Plans" />
/// <reference types="stripe/types/2020-08-27/PlatformTaxFees" />
/// <reference types="stripe/types/2020-08-27/Prices" />
/// <reference types="stripe/types/2020-08-27/Products" />
/// <reference types="stripe/types/2020-08-27/PromotionCodes" />
/// <reference types="stripe/types/2020-08-27/Quotes" />
/// <reference types="stripe/types/2020-08-27/Radar/EarlyFraudWarnings" />
/// <reference types="stripe/types/2020-08-27/Radar/ValueListItems" />
/// <reference types="stripe/types/2020-08-27/Radar/ValueLists" />
/// <reference types="stripe/types/2020-08-27/Recipients" />
/// <reference types="stripe/types/2020-08-27/Refunds" />
/// <reference types="stripe/types/2020-08-27/Reporting/ReportRuns" />
/// <reference types="stripe/types/2020-08-27/Reporting/ReportTypes" />
/// <reference types="stripe/types/2020-08-27/ReserveTransactions" />
/// <reference types="stripe/types/2020-08-27/Reviews" />
/// <reference types="stripe/types/2020-08-27/SKUs" />
/// <reference types="stripe/types/2020-08-27/SetupAttempts" />
/// <reference types="stripe/types/2020-08-27/SetupIntents" />
/// <reference types="stripe/types/2020-08-27/ShippingRates" />
/// <reference types="stripe/types/2020-08-27/Sigma/ScheduledQueryRuns" />
/// <reference types="stripe/types/2020-08-27/SourceMandateNotifications" />
/// <reference types="stripe/types/2020-08-27/SourceTransactions" />
/// <reference types="stripe/types/2020-08-27/Sources" />
/// <reference types="stripe/types/2020-08-27/SubscriptionItems" />
/// <reference types="stripe/types/2020-08-27/SubscriptionSchedules" />
/// <reference types="stripe/types/2020-08-27/Subscriptions" />
/// <reference types="stripe/types/2020-08-27/TaxCodes" />
/// <reference types="stripe/types/2020-08-27/TaxDeductedAtSources" />
/// <reference types="stripe/types/2020-08-27/TaxIds" />
/// <reference types="stripe/types/2020-08-27/TaxRates" />
/// <reference types="stripe/types/2020-08-27/Terminal/ConnectionTokens" />
/// <reference types="stripe/types/2020-08-27/Terminal/Locations" />
/// <reference types="stripe/types/2020-08-27/Terminal/Readers" />
/// <reference types="stripe/types/2020-08-27/Tokens" />
/// <reference types="stripe/types/2020-08-27/Topups" />
/// <reference types="stripe/types/2020-08-27/TransferReversals" />
/// <reference types="stripe/types/2020-08-27/Transfers" />
/// <reference types="stripe/types/2020-08-27/UsageRecordSummaries" />
/// <reference types="stripe/types/2020-08-27/UsageRecords" />
/// <reference types="stripe/types/2020-08-27/WebhookEndpoints" />
/// <reference types="stripe" />
/// <reference types="stripe/types/lib" />
/// <reference types="stripe/types/net/net" />
import { SecretConfig } from "./types/secret-config.js";
import { Configurators } from "./types/configurators.js";
import { DamnId } from "../../toolbox/damnedb/damn-id.js";
export declare function prepareBackend(configurators: Configurators): (config: SecretConfig) => Promise<{
    rando: {
        random: () => number;
        compare: (a: string, b: string) => boolean;
        randomId: () => DamnId;
        randomBuffer: (bytes: number) => ArrayBuffer;
        randomSample: <T>(palette: T[]) => T;
        randomSequence: (length: number, palette: string[]) => string;
    };
    api: {
        auth: {
            apps: {
                appService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").PlatformUserMeta, import("../../features/auth/types/auth-metas.js").PlatformUserAuth, {
                    listApps({ ownerUserId: ownerUserIdString }: {
                        ownerUserId: string;
                    }): Promise<import("../../features/auth/aspects/apps/types/app-display.js").AppDisplay[]>;
                    registerApp({ appDraft, ownerUserId: ownerUserIdString }: {
                        appDraft: import("../../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                        ownerUserId: string;
                    }): Promise<import("../../features/auth/aspects/apps/types/app-display.js").AppDisplay>;
                }>;
                appEditService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").AppOwnerMeta, import("../../features/auth/types/auth-metas.js").AppOwnerAuth, {
                    updateApp({ appId: appIdString, appDraft }: {
                        appId: string;
                        appDraft: import("../../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                    }): Promise<void>;
                    deleteApp({ appId: appIdString }: {
                        appId: string;
                    }): Promise<void>;
                    listAdmins({ appId: appIdString }: {
                        appId: string;
                    }): Promise<import("../../features/auth/aspects/apps/types/admin-email-display.js").AdminEmailDisplay[]>;
                    assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }: {
                        appId: string;
                        platformUserId: string;
                    }): Promise<void>;
                    assignAdmin({ appId: appIdString, email }: {
                        appId: string;
                        email: string;
                    }): Promise<void>;
                    revokeAdmin({ appId: appIdString, userId: userIdString }: {
                        appId: string;
                        userId: string;
                    }): Promise<void>;
                }>;
            };
            users: {
                greenService: import("renraku").Service<undefined, import("../../features/auth/types/auth-metas.js").GreenAuth, {
                    authorize({ scope, refreshToken, appId: appIdString, }: {
                        scope: import("../../features/auth/types/auth-tokens.js").CoreScope;
                        appId: string;
                        refreshToken?: string;
                    }): Promise<string>;
                }>;
                loginService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").AnonMeta, import("../../features/auth/types/auth-metas.js").LoginAuth, {
                    sendLoginLink(inputs: {
                        email: string;
                    }): Promise<void>;
                    authenticateViaLoginToken({ loginToken }: {
                        loginToken: string;
                    }): Promise<import("../../toolbox/concurrent.js").AwaitProps<{
                        accessToken: Promise<string>;
                        refreshToken: Promise<string>;
                    }>>;
                }>;
                userService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").AnonMeta, import("../../features/auth/types/auth-metas.js").LoginAuth, {
                    getUser({ userId }: {
                        userId: string;
                    }): Promise<{
                        userId: string;
                        profile: import("../../features/auth/aspects/users/types/profile.js").Profile;
                        roles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                        stats: import("../../features/auth/aspects/users/types/user-stats.js").UserStats;
                    }>;
                }>;
                personalService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").UserMeta, import("../../features/auth/types/auth-metas.js").UserAuth, {
                    setProfile({ userId: userIdString, profileDraft }: {
                        userId: string;
                        profileDraft: import("../../features/auth/aspects/users/routines/personal/types/profile-draft.js").ProfileDraft;
                    }): Promise<void>;
                }>;
            };
            permissions: {
                permissionsService: import("renraku").Service<import("../../features/auth/aspects/permissions/types/permissions-auth-and-metas.js").PermissionsMeta, {
                    engine: {
                        getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                            userIds: string[];
                            onlyGetPublicRoles: boolean;
                        }) => Promise<{
                            userId: string;
                            userHasRoles: {
                                userId: DamnId;
                                roleId: DamnId;
                                timeframeStart: number;
                                timeframeEnd: number;
                                public: boolean;
                                hard: boolean;
                                time: number;
                            }[];
                        }[]>;
                        getAnonymousPrivileges: () => Promise<string[]>;
                        getPrivilegesForUsers: (userIds: string[]) => Promise<{
                            userId: string;
                            privileges: string[];
                        }[]>;
                        getPublicRolesForUsers: (userIds: string[]) => Promise<{
                            userId: string;
                            publicUserRoles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                        }[]>;
                        getPermissionsDisplay: () => Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        getPrivileges: (privilegeIds: string[]) => Promise<{
                            hard: boolean;
                            label: string;
                            time: number;
                            privilegeId: string;
                        }[]>;
                        getAllPrivileges: () => Promise<{
                            hard: boolean;
                            label: string;
                            time: number;
                            privilegeId: string;
                        }[]>;
                        getUserPrivileges: (userId: string) => Promise<string[]>;
                    };
                    access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                    authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
                    checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                        universal: string;
                        banned: string;
                        "moderate all chats": string;
                        "control stripe account": string;
                        "manage store": string;
                        "give away freebies": string;
                        "view all videos": string;
                        "moderate videos": string;
                        "edit any profile": string;
                        "customize permissions": string;
                        "answer questions": string;
                        "moderate questions": string;
                        "view stats": string;
                        "administrate user roles": string;
                        "view all chats": string;
                        "participate in all chats": string;
                        "read questions": string;
                        "post questions": string;
                        "like questions": string;
                        "report questions": string;
                    }>;
                }, {
                    fetchPermissions(): Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    createRole({ label }: {
                        label: string;
                    }): Promise<void>;
                    deleteRole({ roleId: roleIdString }: {
                        roleId: string;
                    }): Promise<void>;
                    assignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                        roleId: string;
                        privilegeId: string;
                    }): Promise<void>;
                    unassignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                        roleId: string;
                        privilegeId: string;
                    }): Promise<void>;
                    createPrivilege({ label }: {
                        label: string;
                    }): Promise<import("../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
                    deletePrivilege({ privilegeId: privilegeIdString }: {
                        privilegeId: string;
                    }): Promise<void>;
                }>;
            };
        };
        administrative: {
            roleAssignmentService: import("renraku").Service<import("../../features/auth/aspects/permissions/types/permissions-auth-and-metas.js").PermissionsMeta, {
                engine: {
                    getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                        userIds: string[];
                        onlyGetPublicRoles: boolean;
                    }) => Promise<{
                        userId: string;
                        userHasRoles: {
                            userId: DamnId;
                            roleId: DamnId;
                            timeframeStart: number;
                            timeframeEnd: number;
                            public: boolean;
                            hard: boolean;
                            time: number;
                        }[];
                    }[]>;
                    getAnonymousPrivileges: () => Promise<string[]>;
                    getPrivilegesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        privileges: string[];
                    }[]>;
                    getPublicRolesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        publicUserRoles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                    }[]>;
                    getPermissionsDisplay: () => Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    getPrivileges: (privilegeIds: string[]) => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getAllPrivileges: () => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getUserPrivileges: (userId: string) => Promise<string[]>;
                };
                access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
                checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                    universal: string;
                    banned: string;
                    "moderate all chats": string;
                    "control stripe account": string;
                    "manage store": string;
                    "give away freebies": string;
                    "view all videos": string;
                    "moderate videos": string;
                    "edit any profile": string;
                    "customize permissions": string;
                    "answer questions": string;
                    "moderate questions": string;
                    "view stats": string;
                    "administrate user roles": string;
                    "view all chats": string;
                    "participate in all chats": string;
                    "read questions": string;
                    "post questions": string;
                    "like questions": string;
                    "report questions": string;
                }>;
            }, {
                fetchPermissions(): Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                searchUsers(options: {
                    term: string;
                }): Promise<{
                    user: {
                        userId: string;
                        profile: import("../../features/auth/aspects/users/types/profile.js").Profile;
                        roles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                        stats: import("../../features/auth/aspects/users/types/user-stats.js").UserStats;
                    };
                    roleIds: string[];
                }[]>;
                assignRoleToUser(options: {
                    roleId: string;
                    userId: string;
                    isPublic: boolean;
                    timeframeEnd: number;
                    timeframeStart: number;
                }): Promise<void>;
                revokeRoleFromUser(options: {
                    roleId: string;
                    userId: string;
                }): Promise<void>;
            }>;
        };
        questions: {
            questionsReadingService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").AnonMeta, import("../../features/auth/types/auth-metas.js").LoginAuth & {
                questionsTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": DamnId;
                }, import("../../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
            }, {
                fetchQuestions({ board }: {
                    board: string;
                }): Promise<{
                    users: {
                        userId: string;
                        profile: import("../../features/auth/aspects/users/types/profile.js").Profile;
                        roles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                        stats: import("../../features/auth/aspects/users/types/user-stats.js").UserStats;
                    }[];
                    questions: {
                        answers: import("../../features/questions/api/types/questions-and-answers.js").Answer[];
                        questionId: string;
                        authorUserId: string;
                        board: string;
                        content: string;
                        archive: boolean;
                        timePosted: number;
                        liked: boolean;
                        likes: number;
                        reports: number;
                        reported: boolean;
                    }[];
                }>;
            }>;
            questionsPostingService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").UserMeta, import("../../features/auth/types/auth-metas.js").UserAuth & {
                questionsTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": DamnId;
                }, import("../../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
            }, {
                postQuestion(inputs: {
                    questionDraft: import("../../features/questions/api/types/question-draft.js").QuestionDraft;
                }): Promise<import("../../features/questions/api/types/questions-and-answers.js").Question>;
                archiveQuestion(inputs: {
                    archive: boolean;
                    questionId: string;
                }): Promise<void>;
                likeQuestion(inputs: {
                    like: boolean;
                    questionId: string;
                }): Promise<void>;
                reportQuestion(inputs: {
                    report: boolean;
                    questionId: string;
                }): Promise<void>;
            }>;
            questionsAnsweringService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").UserMeta, import("../../features/auth/types/auth-metas.js").UserAuth & {
                questionsTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": DamnId;
                }, import("../../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
            }, {
                postAnswer(inputs: {
                    questionId: string;
                    answerDraft: import("../../features/questions/api/types/answer-draft.js").AnswerDraft;
                }): Promise<import("../../features/questions/api/types/questions-and-answers.js").Answer>;
                archiveAnswer(inputs: {
                    archive: boolean;
                    answerId: string;
                }): Promise<void>;
                likeAnswer(inputs: {
                    like: boolean;
                    answerId: string;
                }): Promise<void>;
                reportAnswer(inputs: {
                    report: boolean;
                    answerId: string;
                }): Promise<void>;
            }>;
            questionsModerationService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").UserMeta, import("../../features/auth/types/auth-metas.js").UserAuth & {
                questionsTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": DamnId;
                }, import("../../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
            }, {
                archiveBoard({ board }: {
                    board: string;
                }): Promise<void>;
                fetchReportedQuestions(): Promise<void>;
            }>;
        };
        example: {
            exampleService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").UserMeta, {
                exampleTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": DamnId;
                }, import("../../features/example/api/types/example-tables.js").ExampleTables>;
                access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
                checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                    universal: string;
                    banned: string;
                    "moderate all chats": string;
                    "control stripe account": string;
                    "manage store": string;
                    "give away freebies": string;
                    "view all videos": string;
                    "moderate videos": string;
                    "edit any profile": string;
                    "customize permissions": string;
                    "answer questions": string;
                    "moderate questions": string;
                    "view stats": string;
                    "administrate user roles": string;
                    "view all chats": string;
                    "participate in all chats": string;
                    "read questions": string;
                    "post questions": string;
                    "like questions": string;
                    "report questions": string;
                }>;
            }, {
                exampleFunction({ something }: {
                    something: string;
                }): Promise<void>;
            }>;
        };
        videos: {
            dacastService: import("renraku").Service<import("../../features/videos/types/video-auth.js").VideoMeta, {
                checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                    "view all videos": string;
                    "moderate videos": string;
                }>;
                engine: {
                    getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                        userIds: string[];
                        onlyGetPublicRoles: boolean;
                    }) => Promise<{
                        userId: string;
                        userHasRoles: {
                            userId: DamnId;
                            roleId: DamnId;
                            timeframeStart: number;
                            timeframeEnd: number;
                            public: boolean;
                            hard: boolean;
                            time: number;
                        }[];
                    }[]>;
                    getAnonymousPrivileges: () => Promise<string[]>;
                    getPrivilegesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        privileges: string[];
                    }[]>;
                    getPublicRolesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        publicUserRoles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                    }[]>;
                    getPermissionsDisplay: () => Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    getPrivileges: (privilegeIds: string[]) => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getAllPrivileges: () => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getUserPrivileges: (userId: string) => Promise<string[]>;
                };
                videoTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": DamnId;
                }, import("../../features/videos/types/video-tables.js").VideoTables>;
                access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
            }, {
                getLink(): Promise<import("../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                setLink(inputs: {
                    apiKey: string;
                }): Promise<import("../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                clearLink(): Promise<void>;
            }>;
            contentService: import("renraku").Service<import("../../features/videos/types/video-auth.js").VideoMeta, {
                engine: {
                    getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                        userIds: string[];
                        onlyGetPublicRoles: boolean;
                    }) => Promise<{
                        userId: string;
                        userHasRoles: {
                            userId: DamnId;
                            roleId: DamnId;
                            timeframeStart: number;
                            timeframeEnd: number;
                            public: boolean;
                            hard: boolean;
                            time: number;
                        }[];
                    }[]>;
                    getAnonymousPrivileges: () => Promise<string[]>;
                    getPrivilegesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        privileges: string[];
                    }[]>;
                    getPublicRolesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        publicUserRoles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                    }[]>;
                    getPermissionsDisplay: () => Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    getPrivileges: (privilegeIds: string[]) => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getAllPrivileges: () => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getUserPrivileges: (userId: string) => Promise<string[]>;
                };
                checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                    "view all videos": string;
                    "moderate videos": string;
                }>;
                videoTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": DamnId;
                }, import("../../features/videos/types/video-tables.js").VideoTables>;
                access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
            }, {
                fetchModerationData(): Promise<import("../../features/videos/types/video-concepts.js").VideoModerationData>;
                writeView({ label, privileges, reference, }: {
                    label: string;
                    privileges: string[];
                    reference: import("../../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
                }): Promise<void>;
                deleteView({ label }: {
                    label: string;
                }): Promise<void>;
                getShows({ labels }: {
                    labels: string[];
                }): Promise<import("../../features/videos/types/video-concepts.js").VideoShow[]>;
            }>;
        };
        notes: {
            notesService: import("renraku").Service<import("../../features/notes/api/types/notes-auth.js").NotesMeta, {
                notesTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": DamnId;
                }, import("../../features/notes/api/tables/notes-tables.js").NotesTables>;
                access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
                checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                    universal: string;
                    banned: string;
                    "moderate all chats": string;
                    "control stripe account": string;
                    "manage store": string;
                    "give away freebies": string;
                    "view all videos": string;
                    "moderate videos": string;
                    "edit any profile": string;
                    "customize permissions": string;
                    "answer questions": string;
                    "moderate questions": string;
                    "view stats": string;
                    "administrate user roles": string;
                    "view all chats": string;
                    "participate in all chats": string;
                    "read questions": string;
                    "post questions": string;
                    "like questions": string;
                    "report questions": string;
                }>;
            }, {
                getNotesStats(): Promise<import("../../features/notes/types/notes-concepts.js").NotesStats>;
                getNewNotes(pagination: import("../../features/notes/types/notes-concepts.js").Pagination): Promise<import("../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                getOldNotes(pagination: import("../../features/notes/types/notes-concepts.js").Pagination): Promise<import("../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                markAllNotesOld(): Promise<void>;
                markNotesNewOrOld(input: {
                    old: boolean;
                    noteIds: string[];
                }): Promise<void>;
            }>;
        };
    };
    config: SecretConfig;
    emails: {
        sendEmail: import("../../features/auth/types/emails/send-email.js").SendEmail;
        enableEmails: () => void;
        disableEmails: () => void;
        sendLoginEmail: (details: import("../../features/auth/aspects/users/types/emails/login-email-details.js").LoginEmailDetails) => Promise<void>;
        recallLatestLoginEmail: () => import("../../features/auth/aspects/users/types/emails/login-email-details.js").LoginEmailDetails;
    };
    database: import("./types/database.js").DatabaseFinal;
    stripeLiaison: {
        accounts: {
            create(params: import("stripe").Stripe.AccountCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Account>>;
            retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Account>>;
            createLoginLink(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.LoginLink>>;
        };
        accountLinks: {
            create(params: import("stripe").Stripe.AccountLinkCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.AccountLink>>;
        };
        account(stripeAccount: string): {
            customers: {
                create(params: import("stripe").Stripe.CustomerCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Customer>>;
                retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Customer | import("stripe").Stripe.DeletedCustomer>>;
                update(id: string, params: import("stripe").Stripe.CustomerUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Customer>>;
            };
            products: {
                create(params: import("stripe").Stripe.ProductCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Product>>;
                retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Product>>;
                update(id: string, params: import("stripe").Stripe.ProductUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Product>>;
            };
            prices: {
                create(params: import("stripe").Stripe.PriceCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Price>>;
                retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Price>>;
                update(id: string, params: import("stripe").Stripe.PriceUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Price>>;
            };
            paymentMethods: {
                retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.PaymentMethod>>;
            };
            setupIntents: {
                retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.SetupIntent>>;
            };
            subscriptions: {
                retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Subscription>>;
                update(id: string, params: import("stripe").Stripe.SubscriptionUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Subscription>>;
            };
            checkout: {
                sessions: {
                    create(params: import("stripe").Stripe.Checkout.SessionCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Checkout.Session>>;
                };
            };
        };
    };
    mockStripeOperations: {
        linkStripeAccount(stripeAccountId: string): Promise<void>;
        linkStripeAccountThatIsIncomplete(stripeAccountId: string): Promise<void>;
    };
    platformAppId: string;
    prepareNotesDepositBox: (appId: DamnId) => {
        sendNotes: (drafts: import("../../features/notes/types/notes-concepts.js").DraftForNote<import("../../features/notes/types/notes-concepts.js").Notes.Any>[]) => Promise<{
            noteId: string;
        }[]>;
        sendNote: (draft: import("../../features/notes/types/notes-concepts.js").DraftForNote<import("../../features/notes/types/notes-concepts.js").Notes.Any>) => Promise<{
            noteId: string;
        }>;
    };
    mockBrowser: () => Promise<{
        mockAppWindow: ({ appId }: {
            appId: string;
        }) => Promise<{
            models: {
                exampleModel: {
                    state: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                    }>;
                    subscribe: (listener: (context: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                    }>) => void) => () => void;
                    updateAccessOp: (op: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>) => void;
                };
                appsModel: {
                    state: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        active: boolean;
                        appRecords: import("../../framework/ops.js").Op<import("../../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
                        addingNewApp: import("../../framework/ops.js").Op<null>;
                    }>;
                    subscribe: (listener: (context: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        active: boolean;
                        appRecords: import("../../framework/ops.js").Op<import("../../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
                        addingNewApp: import("../../framework/ops.js").Op<null>;
                    }>) => void) => () => void;
                    appEditService: {
                        updateApp({ appId: appIdString, appDraft }: {
                            appId: string;
                            appDraft: import("../../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                        }): Promise<void>;
                        deleteApp({ appId: appIdString }: {
                            appId: string;
                        }): Promise<void>;
                        listAdmins({ appId: appIdString }: {
                            appId: string;
                        }): Promise<import("../../features/auth/aspects/apps/types/admin-email-display.js").AdminEmailDisplay[]>;
                        assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }: {
                            appId: string;
                            platformUserId: string;
                        }): Promise<void>;
                        assignAdmin({ appId: appIdString, email }: {
                            appId: string;
                            email: string;
                        }): Promise<void>;
                        revokeAdmin({ appId: appIdString, userId: userIdString }: {
                            appId: string;
                            userId: string;
                        }): Promise<void>;
                    };
                    getApp(appId: string): import("../../features/auth/aspects/apps/types/app-display.js").AppDisplay;
                    loadApps: () => Promise<import("../../features/auth/aspects/apps/types/app-display.js").AppDisplay[]>;
                    deleteApp: (appId: string) => Promise<void>;
                    updateApp: (appId: string, appDraft: import("../../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<void>;
                    registerApp: (appDraft: import("../../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<import("../../features/auth/aspects/apps/types/app-display.js").AppDisplay>;
                    updateAccessOp(op: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                };
                chatModel: {
                    state: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        connectionOp: import("../../framework/ops.js").Op<import("../../features/chat/common/types/chat-concepts.js").ChatConnection>;
                        cache: {
                            mutedUserIds: string[];
                            rooms: {
                                [key: string]: {
                                    status: import("../../features/chat/common/types/chat-concepts.js").ChatStatus;
                                    posts: import("../../features/chat/common/types/chat-concepts.js").ChatPost[];
                                };
                            };
                        };
                    }>;
                    subscribe: (listener: (context: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        connectionOp: import("../../framework/ops.js").Op<import("../../features/chat/common/types/chat-concepts.js").ChatConnection>;
                        cache: {
                            mutedUserIds: string[];
                            rooms: {
                                [key: string]: {
                                    status: import("../../features/chat/common/types/chat-concepts.js").ChatStatus;
                                    posts: import("../../features/chat/common/types/chat-concepts.js").ChatPost[];
                                };
                            };
                        };
                    }>) => void) => () => void;
                    subscribeToChange: (...listeners: (() => void | Promise<void>)[]) => () => void;
                    readonly allowance: {
                        moderateAllChats: boolean;
                        participateInAllChats: boolean;
                        viewAllChats: boolean;
                        banned: boolean;
                    };
                    updateAccessOp(op: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                    session: (label: string) => Promise<{
                        dispose: () => void;
                        room: {
                            readonly posts: import("../../features/chat/common/types/chat-concepts.js").ChatPost[];
                            readonly status: import("../../features/chat/common/types/chat-concepts.js").ChatStatus;
                            readonly muted: string[];
                            readonly weAreMuted: boolean;
                            readonly weAreBanned: boolean;
                            setRoomStatus(status: import("../../features/chat/common/types/chat-concepts.js").ChatStatus): void;
                            post(draft: import("../../features/chat/common/types/chat-concepts.js").ChatDraft): void;
                            remove(postIds: string[]): void;
                            clear(): void;
                            mute(userId: string): void;
                            unmute(userId: string): void;
                            unmuteAll(): void;
                        };
                    }>;
                    disconnect: () => Promise<void>;
                    reconnect: () => Promise<import("../../features/chat/common/types/chat-concepts.js").ChatConnection>;
                };
                accessModel: {
                    getAccessOp(): import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                    getAccess(): import("../../features/auth/types/auth-tokens.js").AccessPayload;
                    getValidAccess(): Promise<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                    useExistingLogin(): Promise<void>;
                    sendLoginLink(email: string): Promise<void>;
                    login(loginToken: string): Promise<void>;
                    logout(): Promise<void>;
                    reauthorize(): Promise<void>;
                    readable: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                    }>;
                    track: <X>(observer: import("../../toolbox/snapstate/parts/types.js").Observer<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                    }, X>, reaction?: import("../../toolbox/snapstate/parts/types.js").Reaction<X>) => () => void;
                    subscribe: (listener: (context: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                    }>) => void) => () => void;
                };
                videoModels: {
                    dacastModel: {
                        state: import("../../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                            linkedAccountOp: import("../../framework/ops.js").Op<import("../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                        }>;
                        subscribe: (listener: (context: import("../../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                            linkedAccountOp: import("../../framework/ops.js").Op<import("../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                        }>) => void) => () => void;
                        onLinkChange: (listener: (context: import("../../features/videos/types/dacast-link.js").DacastLinkDisplay) => void) => () => void;
                        updateAccessOp(op: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                        initialize(): Promise<void>;
                        readonly linkedAccount: import("../../features/videos/types/dacast-link.js").DacastLinkDisplay;
                        linkAccount({ apiKey }: {
                            apiKey: string;
                        }): Promise<import("../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                        unlinkAccount(): Promise<void>;
                    };
                    contentModel: {
                        state: import("../../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                            catalogOp: import("../../framework/ops.js").Op<import("../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                            viewsOp: import("../../framework/ops.js").Op<import("../../features/videos/types/video-concepts.js").VideoView[]>;
                            privilegesOp: import("../../framework/ops.js").Op<import("../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                            showsOp: import("../../framework/ops.js").Op<import("../../features/videos/types/video-concepts.js").VideoShow[]>;
                        }>;
                        subscribe: (listener: (context: import("../../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                            catalogOp: import("../../framework/ops.js").Op<import("../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                            viewsOp: import("../../framework/ops.js").Op<import("../../features/videos/types/video-concepts.js").VideoView[]>;
                            privilegesOp: import("../../framework/ops.js").Op<import("../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                            showsOp: import("../../framework/ops.js").Op<import("../../features/videos/types/video-concepts.js").VideoShow[]>;
                        }>) => void) => () => void;
                        updateAccessOp(op: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                        onVideoHostingUpdate(): Promise<void>;
                        initializeForModerationData(): Promise<void>;
                        initializeForVideo(label: string): Promise<void>;
                        readonly allowance: {
                            canModerateVideos: boolean;
                            canViewAllVideos: boolean;
                        };
                        readonly catalog: import("../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[];
                        readonly views: import("../../features/videos/types/video-concepts.js").VideoView[];
                        readonly privileges: import("../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[];
                        readonly shows: import("../../features/videos/types/video-concepts.js").VideoShow[];
                        getView(label: string): import("../../features/videos/types/video-concepts.js").VideoView;
                        getPrivilege(id: string): import("../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay;
                        getShow(label: string): import("../../features/videos/types/video-concepts.js").VideoShow;
                        setView(options: {
                            label: string;
                            privileges: string[];
                            reference: import("../../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
                        }): Promise<void>;
                        deleteView(label: string): Promise<void>;
                    };
                    updateAccessOp(accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>): void;
                };
                notesModel: {
                    initialize: () => Promise<import("../../features/notes/types/notes-concepts.js").NotesStats>;
                    state: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        statsOp: import("../../framework/ops.js").Op<import("../../features/notes/types/notes-concepts.js").NotesStats>;
                    }>;
                    stateSubscribe: (listener: (context: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        statsOp: import("../../framework/ops.js").Op<import("../../features/notes/types/notes-concepts.js").NotesStats>;
                    }>) => void) => () => void;
                    updateAccessOp(op: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                    readonly isLoggedIn: boolean;
                    readonly stats: import("../../features/notes/types/notes-concepts.js").NotesStats;
                    propagateChangeToOtherTabs: import("../../toolbox/subbies.js").Subbie<undefined>;
                    loadStats: () => Promise<import("../../features/notes/types/notes-concepts.js").NotesStats>;
                    overwriteStatsOp(op: import("../../framework/ops.js").Op<import("../../features/notes/types/notes-concepts.js").NotesStats>): void;
                    createNotesCacheDetails: () => {
                        cache: {
                            subscribe: (listener: (context: import("../../toolbox/snapstate/parts/types.js").Readable<{
                                old: boolean;
                                pageNumber: number;
                                pageSize: number;
                                notesOp: import("../../framework/ops.js").Op<import("../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                            }>) => void) => () => void;
                            cacheState: import("../../toolbox/snapstate/parts/types.js").Readable<{
                                old: boolean;
                                pageNumber: number;
                                pageSize: number;
                                notesOp: import("../../framework/ops.js").Op<import("../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                            }>;
                            loginStatusChanged(): Promise<void>;
                            readonly notes: import("../../features/notes/types/notes-concepts.js").Notes.Any[];
                            fetchAppropriateNotes: () => Promise<import("../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                            switchTabNew(): Promise<void>;
                            switchTabOld(): Promise<void>;
                            readonly isNextPageAvailable: boolean;
                            readonly isPreviousPageAvailable: boolean;
                            nextPage(): Promise<void>;
                            previousPage(): Promise<void>;
                            markAllNotesOld(): Promise<void>;
                            markSpecificNoteOld(noteId: string): Promise<void>;
                            markSpecificNoteNew(noteId: string): Promise<void>;
                            readonly totalPages: number;
                        };
                        setup: () => () => void;
                    };
                };
                personalModel: {
                    track: <X_1>(observer: import("../../toolbox/snapstate/parts/types.js").Observer<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        submitDraftOp: import("../../framework/ops.js").Op<void>;
                    }, X_1>, reaction?: import("../../toolbox/snapstate/parts/types.js").Reaction<X_1>) => () => void;
                    subscribe: (listener: (context: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        submitDraftOp: import("../../framework/ops.js").Op<void>;
                    }>) => void) => () => void;
                    readable: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        submitDraftOp: import("../../framework/ops.js").Op<void>;
                    }>;
                    saveProfile(profileDraft: import("../../features/auth/aspects/users/routines/personal/types/profile-draft.js").ProfileDraft): Promise<void>;
                    updateAccessOp(op: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>): void;
                };
                questionsModel: {
                    onStateChange: import("../../toolbox/pubsub.js").Subscribe<import("../../toolbox/pubsub.js").AnyListener>;
                    makeBoardModel: (board: string) => {
                        getPermissions(): {
                            readonly "read questions": boolean;
                            readonly "post questions": boolean;
                            readonly "moderate questions": boolean;
                            readonly "answer questions": boolean;
                            readonly "like questions": boolean;
                            readonly "report questions": boolean;
                        };
                        getBoardName(): string;
                        getAccess(): import("../../features/auth/types/auth-tokens.js").AccessPayload;
                        getBoardOp(): import("../../framework/ops.js").Op<void>;
                        getPostingOp(): import("../../framework/ops.js").Op<void>;
                        getQuestions(): {
                            answers: import("../../features/questions/api/types/questions-and-answers.js").Answer[];
                            questionId: string;
                            authorUserId: string;
                            board: string;
                            content: string;
                            archive: boolean;
                            timePosted: number;
                            liked: boolean;
                            likes: number;
                            reports: number;
                            reported: boolean;
                        }[];
                        getUser(userId: string): import("../../features/auth/aspects/users/types/user.js").User;
                        loadQuestions(): Promise<void>;
                        postQuestion({ content }: {
                            content: string;
                        }): Promise<import("../../features/questions/api/types/questions-and-answers.js").Question>;
                        postAnswer(questionId: string, answerDraft: import("../../features/questions/api/types/answer-draft.js").AnswerDraft): Promise<import("../../features/questions/api/types/questions-and-answers.js").Answer>;
                        likeQuestion(questionId: string, like: boolean): Promise<void>;
                        likeAnswer(questionId: string, answerId: string, like: boolean): Promise<void>;
                        reportQuestion(questionId: string, report: boolean): Promise<void>;
                        reportAnswer(questionId: string, answerId: string, report: boolean): Promise<void>;
                        archiveQuestion(questionId: string, archive: boolean): Promise<void>;
                        archiveAnswer(questionId: string, answerId: string, archive: boolean): Promise<void>;
                        archiveBoard(): Promise<void>;
                    };
                    accessChange: (access: import("../../features/auth/types/auth-tokens.js").AccessPayload) => void;
                };
                permissionsModel: {
                    readable: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        active: boolean;
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        permissionsDisplay: import("../../framework/ops.js").Op<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    }>;
                    subscribe: (listener: (context: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        active: boolean;
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        permissionsDisplay: import("../../framework/ops.js").Op<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    }>) => void) => () => void;
                    track: <X_2>(observer: import("../../toolbox/snapstate/parts/types.js").Observer<{
                        active: boolean;
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        permissionsDisplay: import("../../framework/ops.js").Op<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    }, X_2>, reaction?: import("../../toolbox/snapstate/parts/types.js").Reaction<X_2>) => () => void;
                    getAccess: () => import("../../features/auth/types/auth-tokens.js").AccessPayload;
                    initialize: () => Promise<void>;
                    getUserCanCustomizePermissions: () => boolean;
                    createRole: ({ label }: {
                        label: string;
                    }) => Promise<void>;
                    deleteRole: ({ roleId: roleIdString }: {
                        roleId: string;
                    }) => Promise<void>;
                    assignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                        roleId: string;
                        privilegeId: string;
                    }) => Promise<void>;
                    unassignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                        roleId: string;
                        privilegeId: string;
                    }) => Promise<void>;
                    deletePrivilege: ({ privilegeId: privilegeIdString }: {
                        privilegeId: string;
                    }) => Promise<void>;
                    createPrivilege: ({ label }: {
                        label: string;
                    }) => Promise<import("../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
                    updateAccessOp(op: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                };
                administrativeModel: {
                    state: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        permissionsOp: import("../../framework/ops.js").Op<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    }>;
                    subscribe: (listener: (context: import("../../toolbox/snapstate/parts/types.js").Readable<{
                        accessOp: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>;
                        permissionsOp: import("../../framework/ops.js").Op<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    }>) => void) => () => void;
                    getAccess: () => import("../../features/auth/types/auth-tokens.js").AccessPayload;
                    initialize: () => Promise<void>;
                    readonly isAllowed: (privilege: "universal" | "banned" | "view all chats" | "participate in all chats" | "read questions" | "post questions" | "like questions" | "report questions" | "moderate all chats" | "control stripe account" | "manage store" | "give away freebies" | "view all videos" | "moderate videos" | "edit any profile" | "customize permissions" | "answer questions" | "moderate questions" | "view stats" | "administrate user roles") => boolean;
                    reauthorize: () => Promise<void>;
                    searchUsers: (options: {
                        term: string;
                    }) => Promise<{
                        user: {
                            userId: string;
                            profile: import("../../features/auth/aspects/users/types/profile.js").Profile;
                            roles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                            stats: import("../../features/auth/aspects/users/types/user-stats.js").UserStats;
                        };
                        roleIds: string[];
                    }[]>;
                    assignRoleToUser: (options: {
                        roleId: string;
                        userId: string;
                        isPublic: boolean;
                        timeframeEnd: number;
                        timeframeStart: number;
                    }) => Promise<void>;
                    revokeRoleFromUser: (options: {
                        roleId: string;
                        userId: string;
                    }) => Promise<void>;
                    updateAccessOp(op: import("../../framework/ops.js").Op<import("../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                };
            };
            remote: import("renraku").ApiRemote<{
                auth: {
                    apps: {
                        appService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").PlatformUserMeta, import("../../features/auth/types/auth-metas.js").PlatformUserAuth, {
                            listApps({ ownerUserId: ownerUserIdString }: {
                                ownerUserId: string;
                            }): Promise<import("../../features/auth/aspects/apps/types/app-display.js").AppDisplay[]>;
                            registerApp({ appDraft, ownerUserId: ownerUserIdString }: {
                                appDraft: import("../../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                                ownerUserId: string;
                            }): Promise<import("../../features/auth/aspects/apps/types/app-display.js").AppDisplay>;
                        }>;
                        appEditService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").AppOwnerMeta, import("../../features/auth/types/auth-metas.js").AppOwnerAuth, {
                            updateApp({ appId: appIdString, appDraft }: {
                                appId: string;
                                appDraft: import("../../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                            }): Promise<void>;
                            deleteApp({ appId: appIdString }: {
                                appId: string;
                            }): Promise<void>;
                            listAdmins({ appId: appIdString }: {
                                appId: string;
                            }): Promise<import("../../features/auth/aspects/apps/types/admin-email-display.js").AdminEmailDisplay[]>;
                            assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }: {
                                appId: string;
                                platformUserId: string;
                            }): Promise<void>;
                            assignAdmin({ appId: appIdString, email }: {
                                appId: string;
                                email: string;
                            }): Promise<void>;
                            revokeAdmin({ appId: appIdString, userId: userIdString }: {
                                appId: string;
                                userId: string;
                            }): Promise<void>;
                        }>;
                    };
                    users: {
                        greenService: import("renraku").Service<undefined, import("../../features/auth/types/auth-metas.js").GreenAuth, {
                            authorize({ scope, refreshToken, appId: appIdString, }: {
                                scope: import("../../features/auth/types/auth-tokens.js").CoreScope;
                                appId: string;
                                refreshToken?: string;
                            }): Promise<string>;
                        }>;
                        loginService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").AnonMeta, import("../../features/auth/types/auth-metas.js").LoginAuth, {
                            sendLoginLink(inputs: {
                                email: string;
                            }): Promise<void>;
                            authenticateViaLoginToken({ loginToken }: {
                                loginToken: string;
                            }): Promise<import("../../toolbox/concurrent.js").AwaitProps<{
                                accessToken: Promise<string>;
                                refreshToken: Promise<string>;
                            }>>;
                        }>;
                        userService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").AnonMeta, import("../../features/auth/types/auth-metas.js").LoginAuth, {
                            getUser({ userId }: {
                                userId: string;
                            }): Promise<{
                                userId: string;
                                profile: import("../../features/auth/aspects/users/types/profile.js").Profile;
                                roles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                stats: import("../../features/auth/aspects/users/types/user-stats.js").UserStats;
                            }>;
                        }>;
                        personalService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").UserMeta, import("../../features/auth/types/auth-metas.js").UserAuth, {
                            setProfile({ userId: userIdString, profileDraft }: {
                                userId: string;
                                profileDraft: import("../../features/auth/aspects/users/routines/personal/types/profile-draft.js").ProfileDraft;
                            }): Promise<void>;
                        }>;
                    };
                    permissions: {
                        permissionsService: import("renraku").Service<import("../../features/auth/aspects/permissions/types/permissions-auth-and-metas.js").PermissionsMeta, {
                            engine: {
                                getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                                    userIds: string[];
                                    onlyGetPublicRoles: boolean;
                                }) => Promise<{
                                    userId: string;
                                    userHasRoles: {
                                        userId: DamnId;
                                        roleId: DamnId;
                                        timeframeStart: number;
                                        timeframeEnd: number;
                                        public: boolean;
                                        hard: boolean;
                                        time: number;
                                    }[];
                                }[]>;
                                getAnonymousPrivileges: () => Promise<string[]>;
                                getPrivilegesForUsers: (userIds: string[]) => Promise<{
                                    userId: string;
                                    privileges: string[];
                                }[]>;
                                getPublicRolesForUsers: (userIds: string[]) => Promise<{
                                    userId: string;
                                    publicUserRoles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                }[]>;
                                getPermissionsDisplay: () => Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                                getPrivileges: (privilegeIds: string[]) => Promise<{
                                    hard: boolean;
                                    label: string;
                                    time: number;
                                    privilegeId: string;
                                }[]>;
                                getAllPrivileges: () => Promise<{
                                    hard: boolean;
                                    label: string;
                                    time: number;
                                    privilegeId: string;
                                }[]>;
                                getUserPrivileges: (userId: string) => Promise<string[]>;
                            };
                            access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                            authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
                            checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                                universal: string;
                                banned: string;
                                "moderate all chats": string;
                                "control stripe account": string;
                                "manage store": string;
                                "give away freebies": string;
                                "view all videos": string;
                                "moderate videos": string;
                                "edit any profile": string;
                                "customize permissions": string;
                                "answer questions": string;
                                "moderate questions": string;
                                "view stats": string;
                                "administrate user roles": string;
                                "view all chats": string;
                                "participate in all chats": string;
                                "read questions": string;
                                "post questions": string;
                                "like questions": string;
                                "report questions": string;
                            }>;
                        }, {
                            fetchPermissions(): Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                            createRole({ label }: {
                                label: string;
                            }): Promise<void>;
                            deleteRole({ roleId: roleIdString }: {
                                roleId: string;
                            }): Promise<void>;
                            assignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                                roleId: string;
                                privilegeId: string;
                            }): Promise<void>;
                            unassignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                                roleId: string;
                                privilegeId: string;
                            }): Promise<void>;
                            createPrivilege({ label }: {
                                label: string;
                            }): Promise<import("../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
                            deletePrivilege({ privilegeId: privilegeIdString }: {
                                privilegeId: string;
                            }): Promise<void>;
                        }>;
                    };
                };
                administrative: {
                    roleAssignmentService: import("renraku").Service<import("../../features/auth/aspects/permissions/types/permissions-auth-and-metas.js").PermissionsMeta, {
                        engine: {
                            getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                                userIds: string[];
                                onlyGetPublicRoles: boolean;
                            }) => Promise<{
                                userId: string;
                                userHasRoles: {
                                    userId: DamnId;
                                    roleId: DamnId;
                                    timeframeStart: number;
                                    timeframeEnd: number;
                                    public: boolean;
                                    hard: boolean;
                                    time: number;
                                }[];
                            }[]>;
                            getAnonymousPrivileges: () => Promise<string[]>;
                            getPrivilegesForUsers: (userIds: string[]) => Promise<{
                                userId: string;
                                privileges: string[];
                            }[]>;
                            getPublicRolesForUsers: (userIds: string[]) => Promise<{
                                userId: string;
                                publicUserRoles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                            }[]>;
                            getPermissionsDisplay: () => Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                            getPrivileges: (privilegeIds: string[]) => Promise<{
                                hard: boolean;
                                label: string;
                                time: number;
                                privilegeId: string;
                            }[]>;
                            getAllPrivileges: () => Promise<{
                                hard: boolean;
                                label: string;
                                time: number;
                                privilegeId: string;
                            }[]>;
                            getUserPrivileges: (userId: string) => Promise<string[]>;
                        };
                        access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                        authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
                        checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                            universal: string;
                            banned: string;
                            "moderate all chats": string;
                            "control stripe account": string;
                            "manage store": string;
                            "give away freebies": string;
                            "view all videos": string;
                            "moderate videos": string;
                            "edit any profile": string;
                            "customize permissions": string;
                            "answer questions": string;
                            "moderate questions": string;
                            "view stats": string;
                            "administrate user roles": string;
                            "view all chats": string;
                            "participate in all chats": string;
                            "read questions": string;
                            "post questions": string;
                            "like questions": string;
                            "report questions": string;
                        }>;
                    }, {
                        fetchPermissions(): Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        searchUsers(options: {
                            term: string;
                        }): Promise<{
                            user: {
                                userId: string;
                                profile: import("../../features/auth/aspects/users/types/profile.js").Profile;
                                roles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                stats: import("../../features/auth/aspects/users/types/user-stats.js").UserStats;
                            };
                            roleIds: string[];
                        }[]>;
                        assignRoleToUser(options: {
                            roleId: string;
                            userId: string;
                            isPublic: boolean;
                            timeframeEnd: number;
                            timeframeStart: number;
                        }): Promise<void>;
                        revokeRoleFromUser(options: {
                            roleId: string;
                            userId: string;
                        }): Promise<void>;
                    }>;
                };
                questions: {
                    questionsReadingService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").AnonMeta, import("../../features/auth/types/auth-metas.js").LoginAuth & {
                        questionsTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                            "namespace-appId": DamnId;
                        }, import("../../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                    }, {
                        fetchQuestions({ board }: {
                            board: string;
                        }): Promise<{
                            users: {
                                userId: string;
                                profile: import("../../features/auth/aspects/users/types/profile.js").Profile;
                                roles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                stats: import("../../features/auth/aspects/users/types/user-stats.js").UserStats;
                            }[];
                            questions: {
                                answers: import("../../features/questions/api/types/questions-and-answers.js").Answer[];
                                questionId: string;
                                authorUserId: string;
                                board: string;
                                content: string;
                                archive: boolean;
                                timePosted: number;
                                liked: boolean;
                                likes: number;
                                reports: number;
                                reported: boolean;
                            }[];
                        }>;
                    }>;
                    questionsPostingService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").UserMeta, import("../../features/auth/types/auth-metas.js").UserAuth & {
                        questionsTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                            "namespace-appId": DamnId;
                        }, import("../../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                    }, {
                        postQuestion(inputs: {
                            questionDraft: import("../../features/questions/api/types/question-draft.js").QuestionDraft;
                        }): Promise<import("../../features/questions/api/types/questions-and-answers.js").Question>;
                        archiveQuestion(inputs: {
                            archive: boolean;
                            questionId: string;
                        }): Promise<void>;
                        likeQuestion(inputs: {
                            like: boolean;
                            questionId: string;
                        }): Promise<void>;
                        reportQuestion(inputs: {
                            report: boolean;
                            questionId: string;
                        }): Promise<void>;
                    }>;
                    questionsAnsweringService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").UserMeta, import("../../features/auth/types/auth-metas.js").UserAuth & {
                        questionsTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                            "namespace-appId": DamnId;
                        }, import("../../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                    }, {
                        postAnswer(inputs: {
                            questionId: string;
                            answerDraft: import("../../features/questions/api/types/answer-draft.js").AnswerDraft;
                        }): Promise<import("../../features/questions/api/types/questions-and-answers.js").Answer>;
                        archiveAnswer(inputs: {
                            archive: boolean;
                            answerId: string;
                        }): Promise<void>;
                        likeAnswer(inputs: {
                            like: boolean;
                            answerId: string;
                        }): Promise<void>;
                        reportAnswer(inputs: {
                            report: boolean;
                            answerId: string;
                        }): Promise<void>;
                    }>;
                    questionsModerationService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").UserMeta, import("../../features/auth/types/auth-metas.js").UserAuth & {
                        questionsTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                            "namespace-appId": DamnId;
                        }, import("../../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                    }, {
                        archiveBoard({ board }: {
                            board: string;
                        }): Promise<void>;
                        fetchReportedQuestions(): Promise<void>;
                    }>;
                };
                example: {
                    exampleService: import("renraku").Service<import("../../features/auth/types/auth-metas.js").UserMeta, {
                        exampleTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                            "namespace-appId": DamnId;
                        }, import("../../features/example/api/types/example-tables.js").ExampleTables>;
                        access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                        authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
                        checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                            universal: string;
                            banned: string;
                            "moderate all chats": string;
                            "control stripe account": string;
                            "manage store": string;
                            "give away freebies": string;
                            "view all videos": string;
                            "moderate videos": string;
                            "edit any profile": string;
                            "customize permissions": string;
                            "answer questions": string;
                            "moderate questions": string;
                            "view stats": string;
                            "administrate user roles": string;
                            "view all chats": string;
                            "participate in all chats": string;
                            "read questions": string;
                            "post questions": string;
                            "like questions": string;
                            "report questions": string;
                        }>;
                    }, {
                        exampleFunction({ something }: {
                            something: string;
                        }): Promise<void>;
                    }>;
                };
                videos: {
                    dacastService: import("renraku").Service<import("../../features/videos/types/video-auth.js").VideoMeta, {
                        checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                            "view all videos": string;
                            "moderate videos": string;
                        }>;
                        engine: {
                            getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                                userIds: string[];
                                onlyGetPublicRoles: boolean;
                            }) => Promise<{
                                userId: string;
                                userHasRoles: {
                                    userId: DamnId;
                                    roleId: DamnId;
                                    timeframeStart: number;
                                    timeframeEnd: number;
                                    public: boolean;
                                    hard: boolean;
                                    time: number;
                                }[];
                            }[]>;
                            getAnonymousPrivileges: () => Promise<string[]>;
                            getPrivilegesForUsers: (userIds: string[]) => Promise<{
                                userId: string;
                                privileges: string[];
                            }[]>;
                            getPublicRolesForUsers: (userIds: string[]) => Promise<{
                                userId: string;
                                publicUserRoles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                            }[]>;
                            getPermissionsDisplay: () => Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                            getPrivileges: (privilegeIds: string[]) => Promise<{
                                hard: boolean;
                                label: string;
                                time: number;
                                privilegeId: string;
                            }[]>;
                            getAllPrivileges: () => Promise<{
                                hard: boolean;
                                label: string;
                                time: number;
                                privilegeId: string;
                            }[]>;
                            getUserPrivileges: (userId: string) => Promise<string[]>;
                        };
                        videoTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                            "namespace-appId": DamnId;
                        }, import("../../features/videos/types/video-tables.js").VideoTables>;
                        access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                        authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
                    }, {
                        getLink(): Promise<import("../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                        setLink(inputs: {
                            apiKey: string;
                        }): Promise<import("../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                        clearLink(): Promise<void>;
                    }>;
                    contentService: import("renraku").Service<import("../../features/videos/types/video-auth.js").VideoMeta, {
                        engine: {
                            getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                                userIds: string[];
                                onlyGetPublicRoles: boolean;
                            }) => Promise<{
                                userId: string;
                                userHasRoles: {
                                    userId: DamnId;
                                    roleId: DamnId;
                                    timeframeStart: number;
                                    timeframeEnd: number;
                                    public: boolean;
                                    hard: boolean;
                                    time: number;
                                }[];
                            }[]>;
                            getAnonymousPrivileges: () => Promise<string[]>;
                            getPrivilegesForUsers: (userIds: string[]) => Promise<{
                                userId: string;
                                privileges: string[];
                            }[]>;
                            getPublicRolesForUsers: (userIds: string[]) => Promise<{
                                userId: string;
                                publicUserRoles: import("../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                            }[]>;
                            getPermissionsDisplay: () => Promise<import("../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                            getPrivileges: (privilegeIds: string[]) => Promise<{
                                hard: boolean;
                                label: string;
                                time: number;
                                privilegeId: string;
                            }[]>;
                            getAllPrivileges: () => Promise<{
                                hard: boolean;
                                label: string;
                                time: number;
                                privilegeId: string;
                            }[]>;
                            getUserPrivileges: (userId: string) => Promise<string[]>;
                        };
                        checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                            "view all videos": string;
                            "moderate videos": string;
                        }>;
                        videoTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                            "namespace-appId": DamnId;
                        }, import("../../features/videos/types/video-tables.js").VideoTables>;
                        access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                        authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
                    }, {
                        fetchModerationData(): Promise<import("../../features/videos/types/video-concepts.js").VideoModerationData>;
                        writeView({ label, privileges, reference, }: {
                            label: string;
                            privileges: string[];
                            reference: import("../../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
                        }): Promise<void>;
                        deleteView({ label }: {
                            label: string;
                        }): Promise<void>;
                        getShows({ labels }: {
                            labels: string[];
                        }): Promise<import("../../features/videos/types/video-concepts.js").VideoShow[]>;
                    }>;
                };
                notes: {
                    notesService: import("renraku").Service<import("../../features/notes/api/types/notes-auth.js").NotesMeta, {
                        notesTables: import("../../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                            "namespace-appId": DamnId;
                        }, import("../../features/notes/api/tables/notes-tables.js").NotesTables>;
                        access: import("../../features/auth/types/auth-tokens.js").AccessPayload;
                        authTables: import("../../features/auth/types/auth-tables.js").AuthTables;
                        checker: import("../../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                            universal: string;
                            banned: string;
                            "moderate all chats": string;
                            "control stripe account": string;
                            "manage store": string;
                            "give away freebies": string;
                            "view all videos": string;
                            "moderate videos": string;
                            "edit any profile": string;
                            "customize permissions": string;
                            "answer questions": string;
                            "moderate questions": string;
                            "view stats": string;
                            "administrate user roles": string;
                            "view all chats": string;
                            "participate in all chats": string;
                            "read questions": string;
                            "post questions": string;
                            "like questions": string;
                            "report questions": string;
                        }>;
                    }, {
                        getNotesStats(): Promise<import("../../features/notes/types/notes-concepts.js").NotesStats>;
                        getNewNotes(pagination: import("../../features/notes/types/notes-concepts.js").Pagination): Promise<import("../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                        getOldNotes(pagination: import("../../features/notes/types/notes-concepts.js").Pagination): Promise<import("../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                        markAllNotesOld(): Promise<void>;
                        markNotesNewOrOld(input: {
                            old: boolean;
                            noteIds: string[];
                        }): Promise<void>;
                    }>;
                };
            }>;
            nextModalResults: {
                confirm: boolean;
                prompt: {
                    value: any;
                };
            };
        }>;
    }>;
}>;
