import { AssembleModelsOptions } from "../types/assemble-models-options.js";
export declare function assembleModels({ appId, remote, popups, storage, authMediator, chatConnect, }: AssembleModelsOptions): Promise<{
    exampleModel: {
        state: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
        }>;
        subscribe: (listener: (context: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
        }>) => void) => () => void;
        updateAccessOp: (op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>) => void;
    };
    appsModel: {
        state: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            active: boolean;
            appRecords: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
            addingNewApp: import("../../../framework/ops.js").Op<null>;
        }>;
        subscribe: (listener: (context: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            active: boolean;
            appRecords: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
            addingNewApp: import("../../../framework/ops.js").Op<null>;
        }>) => void) => () => void;
        appEditService: {
            updateApp({ appId: appIdString, appDraft }: {
                appId: string;
                appDraft: import("../../../features/auth/aspects/apps/types/app-draft.js").AppDraft;
            }): Promise<void>;
            deleteApp({ appId: appIdString }: {
                appId: string;
            }): Promise<void>;
            listAdmins({ appId: appIdString }: {
                appId: string;
            }): Promise<import("../../../features/auth/aspects/apps/types/admin-email-display.js").AdminEmailDisplay[]>;
            assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }: {
                appId: string;
                platformUserId: string;
            }): Promise<void>;
            assignAdmin({ appId: appIdString, email }: {
                appId: string;
                email: string;
            }): Promise<void>;
            revokeAdmin({ appId: appIdString, userId: userIdString }: {
                appId: string;
                userId: string;
            }): Promise<void>;
        };
        getApp(appId: string): import("../../../features/auth/aspects/apps/types/app-display.js").AppDisplay;
        loadApps: () => Promise<import("../../../features/auth/aspects/apps/types/app-display.js").AppDisplay[]>;
        deleteApp: (appId: string) => Promise<void>;
        updateApp: (appId: string, appDraft: import("../../../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<void>;
        registerApp: (appDraft: import("../../../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<import("../../../features/auth/aspects/apps/types/app-display.js").AppDisplay>;
        updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
    };
    chatModel: {
        state: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            connectionOp: import("../../../framework/ops.js").Op<import("../../../features/chat/common/types/chat-concepts.js").ChatConnection>;
            cache: {
                mutedUserIds: string[];
                rooms: {
                    [key: string]: {
                        status: import("../../../features/chat/common/types/chat-concepts.js").ChatStatus;
                        posts: import("../../../features/chat/common/types/chat-concepts.js").ChatPost[];
                    };
                };
            };
        }>;
        subscribe: (listener: (context: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            connectionOp: import("../../../framework/ops.js").Op<import("../../../features/chat/common/types/chat-concepts.js").ChatConnection>;
            cache: {
                mutedUserIds: string[];
                rooms: {
                    [key: string]: {
                        status: import("../../../features/chat/common/types/chat-concepts.js").ChatStatus;
                        posts: import("../../../features/chat/common/types/chat-concepts.js").ChatPost[];
                    };
                };
            };
        }>) => void) => () => void;
        subscribeToChange: (...listeners: (() => void | Promise<void>)[]) => () => void;
        readonly allowance: {
            moderateAllChats: boolean;
            participateInAllChats: boolean;
            viewAllChats: boolean;
            banned: boolean;
        };
        updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
        session: (label: string) => Promise<{
            dispose: () => void;
            room: {
                readonly posts: import("../../../features/chat/common/types/chat-concepts.js").ChatPost[];
                readonly status: import("../../../features/chat/common/types/chat-concepts.js").ChatStatus;
                readonly muted: string[];
                readonly weAreMuted: boolean;
                readonly weAreBanned: boolean;
                setRoomStatus(status: import("../../../features/chat/common/types/chat-concepts.js").ChatStatus): void;
                post(draft: import("../../../features/chat/common/types/chat-concepts.js").ChatDraft): void;
                remove(postIds: string[]): void;
                clear(): void;
                mute(userId: string): void;
                unmute(userId: string): void;
                unmuteAll(): void;
            };
        }>;
        disconnect: () => Promise<void>;
        reconnect: () => Promise<import("../../../features/chat/common/types/chat-concepts.js").ChatConnection>;
    };
    accessModel: {
        getAccessOp(): import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
        getAccess(): import("../../../features/auth/types/auth-tokens.js").AccessPayload;
        getValidAccess(): Promise<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
        useExistingLogin(): Promise<void>;
        sendLoginLink(email: string): Promise<void>;
        login(loginToken: string): Promise<void>;
        logout(): Promise<void>;
        reauthorize(): Promise<void>;
        readable: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
        }>;
        track: <X>(observer: import("../../../toolbox/snapstate/parts/types.js").Observer<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
        }, X>, reaction?: import("../../../toolbox/snapstate/parts/types.js").Reaction<X>) => () => void;
        subscribe: (listener: (context: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
        }>) => void) => () => void;
    };
    videoModels: {
        dacastModel: {
            state: import("../../../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                linkedAccountOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
            }>;
            subscribe: (listener: (context: import("../../../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                linkedAccountOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
            }>) => void) => () => void;
            onLinkChange: (listener: (context: import("../../../features/videos/types/dacast-link.js").DacastLinkDisplay) => void) => () => void;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            initialize(): Promise<void>;
            readonly linkedAccount: import("../../../features/videos/types/dacast-link.js").DacastLinkDisplay;
            linkAccount({ apiKey }: {
                apiKey: string;
            }): Promise<import("../../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
            unlinkAccount(): Promise<void>;
        };
        contentModel: {
            state: import("../../../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                catalogOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                viewsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoView[]>;
                privilegesOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                showsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoShow[]>;
            }>;
            subscribe: (listener: (context: import("../../../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                catalogOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                viewsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoView[]>;
                privilegesOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                showsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoShow[]>;
            }>) => void) => () => void;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            onVideoHostingUpdate(): Promise<void>;
            initializeForModerationData(): Promise<void>;
            initializeForVideo(label: string): Promise<void>;
            readonly allowance: {
                canModerateVideos: boolean;
                canViewAllVideos: boolean;
            };
            readonly catalog: import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[];
            readonly views: import("../../../features/videos/types/video-concepts.js").VideoView[];
            readonly privileges: import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[];
            readonly shows: import("../../../features/videos/types/video-concepts.js").VideoShow[];
            getView(label: string): import("../../../features/videos/types/video-concepts.js").VideoView;
            getPrivilege(id: string): import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay;
            getShow(label: string): import("../../../features/videos/types/video-concepts.js").VideoShow;
            setView(options: {
                label: string;
                privileges: string[];
                reference: import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
            }): Promise<void>;
            deleteView(label: string): Promise<void>;
        };
        updateAccessOp(accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): void;
    };
    notesModel: {
        initialize: () => Promise<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
        state: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            statsOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
        }>;
        stateSubscribe: (listener: (context: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            statsOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
        }>) => void) => () => void;
        updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
        readonly isLoggedIn: boolean;
        readonly stats: import("../../../features/notes/types/notes-concepts.js").NotesStats;
        propagateChangeToOtherTabs: import("../../../toolbox/subbies.js").Subbie<undefined>;
        loadStats: () => Promise<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
        overwriteStatsOp(op: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").NotesStats>): void;
        createNotesCacheDetails: () => {
            cache: {
                subscribe: (listener: (context: import("../../../toolbox/snapstate/parts/types.js").Readable<{
                    old: boolean;
                    pageNumber: number;
                    pageSize: number;
                    notesOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                }>) => void) => () => void;
                cacheState: import("../../../toolbox/snapstate/parts/types.js").Readable<{
                    old: boolean;
                    pageNumber: number;
                    pageSize: number;
                    notesOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                }>;
                loginStatusChanged(): Promise<void>;
                readonly notes: import("../../../features/notes/types/notes-concepts.js").Notes.Any[];
                fetchAppropriateNotes: () => Promise<import("../../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                switchTabNew(): Promise<void>;
                switchTabOld(): Promise<void>;
                readonly isNextPageAvailable: boolean;
                readonly isPreviousPageAvailable: boolean;
                nextPage(): Promise<void>;
                previousPage(): Promise<void>;
                markAllNotesOld(): Promise<void>;
                markSpecificNoteOld(noteId: string): Promise<void>;
                markSpecificNoteNew(noteId: string): Promise<void>;
                readonly totalPages: number;
            };
            setup: () => () => void;
        };
    };
    personalModel: {
        track: <X_1>(observer: import("../../../toolbox/snapstate/parts/types.js").Observer<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            submitDraftOp: import("../../../framework/ops.js").Op<void>;
        }, X_1>, reaction?: import("../../../toolbox/snapstate/parts/types.js").Reaction<X_1>) => () => void;
        subscribe: (listener: (context: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            submitDraftOp: import("../../../framework/ops.js").Op<void>;
        }>) => void) => () => void;
        readable: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            submitDraftOp: import("../../../framework/ops.js").Op<void>;
        }>;
        saveProfile(profileDraft: import("../../../features/auth/aspects/users/routines/personal/types/profile-draft.js").ProfileDraft): Promise<void>;
        updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): void;
    };
    questionsModel: {
        onStateChange: import("../../../toolbox/pubsub.js").Subscribe<import("../../../toolbox/pubsub.js").AnyListener>;
        makeBoardModel: (board: string) => {
            getPermissions(): {
                readonly "read questions": boolean;
                readonly "post questions": boolean;
                readonly "moderate questions": boolean;
                readonly "answer questions": boolean;
                readonly "like questions": boolean;
                readonly "report questions": boolean;
            };
            getBoardName(): string;
            getAccess(): import("../../../features/auth/types/auth-tokens.js").AccessPayload;
            getBoardOp(): import("../../../framework/ops.js").Op<void>;
            getPostingOp(): import("../../../framework/ops.js").Op<void>;
            getQuestions(): {
                answers: import("../../../features/questions/api/types/questions-and-answers.js").Answer[];
                questionId: string;
                authorUserId: string;
                board: string;
                content: string;
                archive: boolean;
                timePosted: number;
                liked: boolean;
                likes: number;
                reports: number;
                reported: boolean;
            }[];
            getUser(userId: string): import("../../../features/auth/aspects/users/types/user.js").User;
            loadQuestions(): Promise<void>;
            postQuestion({ content }: {
                content: string;
            }): Promise<import("../../../features/questions/api/types/questions-and-answers.js").Question>;
            postAnswer(questionId: string, answerDraft: import("../../../features/questions/api/types/answer-draft.js").AnswerDraft): Promise<import("../../../features/questions/api/types/questions-and-answers.js").Answer>;
            likeQuestion(questionId: string, like: boolean): Promise<void>;
            likeAnswer(questionId: string, answerId: string, like: boolean): Promise<void>;
            reportQuestion(questionId: string, report: boolean): Promise<void>;
            reportAnswer(questionId: string, answerId: string, report: boolean): Promise<void>;
            archiveQuestion(questionId: string, archive: boolean): Promise<void>;
            archiveAnswer(questionId: string, answerId: string, archive: boolean): Promise<void>;
            archiveBoard(): Promise<void>;
        };
        accessChange: (access: import("../../../features/auth/types/auth-tokens.js").AccessPayload) => void;
    };
    permissionsModel: {
        readable: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            active: boolean;
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            permissionsDisplay: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
        }>;
        subscribe: (listener: (context: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            active: boolean;
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            permissionsDisplay: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
        }>) => void) => () => void;
        track: <X_2>(observer: import("../../../toolbox/snapstate/parts/types.js").Observer<{
            active: boolean;
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            permissionsDisplay: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
        }, X_2>, reaction?: import("../../../toolbox/snapstate/parts/types.js").Reaction<X_2>) => () => void;
        getAccess: () => import("../../../features/auth/types/auth-tokens.js").AccessPayload;
        initialize: () => Promise<void>;
        getUserCanCustomizePermissions: () => boolean;
        createRole: ({ label }: {
            label: string;
        }) => Promise<void>;
        deleteRole: ({ roleId: roleIdString }: {
            roleId: string;
        }) => Promise<void>;
        assignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
            roleId: string;
            privilegeId: string;
        }) => Promise<void>;
        unassignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
            roleId: string;
            privilegeId: string;
        }) => Promise<void>;
        deletePrivilege: ({ privilegeId: privilegeIdString }: {
            privilegeId: string;
        }) => Promise<void>;
        createPrivilege: ({ label }: {
            label: string;
        }) => Promise<import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
        updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
    };
    administrativeModel: {
        state: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            permissionsOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
        }>;
        subscribe: (listener: (context: import("../../../toolbox/snapstate/parts/types.js").Readable<{
            accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            permissionsOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
        }>) => void) => () => void;
        getAccess: () => import("../../../features/auth/types/auth-tokens.js").AccessPayload;
        initialize: () => Promise<void>;
        readonly isAllowed: (privilege: "universal" | "banned" | "view all chats" | "participate in all chats" | "read questions" | "post questions" | "like questions" | "report questions" | "moderate all chats" | "control stripe account" | "manage store" | "give away freebies" | "view all videos" | "moderate videos" | "edit any profile" | "customize permissions" | "answer questions" | "moderate questions" | "view stats" | "administrate user roles") => boolean;
        reauthorize: () => Promise<void>;
        searchUsers: (options: {
            term: string;
        }) => Promise<{
            user: {
                userId: string;
                profile: import("../../../features/auth/aspects/users/types/profile.js").Profile;
                roles: import("../../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                stats: import("../../../features/auth/aspects/users/types/user-stats.js").UserStats;
            };
            roleIds: string[];
        }[]>;
        assignRoleToUser: (options: {
            roleId: string;
            userId: string;
            isPublic: boolean;
            timeframeEnd: number;
            timeframeStart: number;
        }) => Promise<void>;
        revokeRoleFromUser: (options: {
            roleId: string;
            userId: string;
        }) => Promise<void>;
        updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
    };
}>;
