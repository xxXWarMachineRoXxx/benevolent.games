/// <reference types="stripe/types/crypto/crypto" />
/// <reference types="stripe/types/shared" />
/// <reference types="stripe/types/Errors" />
/// <reference types="stripe/types/OAuth" />
/// <reference types="stripe/types/Webhooks" />
/// <reference types="stripe/types/2020-08-27/AccountLinks" />
/// <reference types="stripe/types/2020-08-27/Accounts" />
/// <reference types="stripe/types/2020-08-27/AlipayAccounts" />
/// <reference types="stripe/types/2020-08-27/ApplePayDomains" />
/// <reference types="stripe/types/2020-08-27/ApplicationFees" />
/// <reference types="stripe/types/2020-08-27/Applications" />
/// <reference types="stripe/types/2020-08-27/Balance" />
/// <reference types="stripe/types/2020-08-27/BalanceTransactions" />
/// <reference types="stripe/types/2020-08-27/BankAccounts" />
/// <reference types="stripe/types/2020-08-27/BillingPortal/Configurations" />
/// <reference types="stripe/types/2020-08-27/BillingPortal/Sessions" />
/// <reference types="stripe/types/2020-08-27/BitcoinReceivers" />
/// <reference types="stripe/types/2020-08-27/BitcoinTransactions" />
/// <reference types="stripe/types/2020-08-27/Capabilities" />
/// <reference types="stripe/types/2020-08-27/Cards" />
/// <reference types="stripe/types/2020-08-27/Charges" />
/// <reference types="stripe/types/2020-08-27/Checkout/Sessions" />
/// <reference types="stripe/types/2020-08-27/ConnectCollectionTransfers" />
/// <reference types="stripe/types/2020-08-27/CountrySpecs" />
/// <reference types="stripe/types/2020-08-27/Coupons" />
/// <reference types="stripe/types/2020-08-27/CreditNoteLineItems" />
/// <reference types="stripe/types/2020-08-27/CreditNotes" />
/// <reference types="stripe/types/2020-08-27/CustomerBalanceTransactions" />
/// <reference types="stripe/types/2020-08-27/CustomerSources" />
/// <reference types="stripe/types/2020-08-27/Customers" />
/// <reference types="stripe/types/2020-08-27/Discounts" />
/// <reference types="stripe/types/2020-08-27/Disputes" />
/// <reference types="stripe/types/2020-08-27/EphemeralKeys" />
/// <reference types="stripe/types/2020-08-27/Events" />
/// <reference types="stripe/types/2020-08-27/ExchangeRates" />
/// <reference types="stripe/types/2020-08-27/ExternalAccounts" />
/// <reference types="stripe/types/2020-08-27/FeeRefunds" />
/// <reference types="stripe/types/2020-08-27/FileLinks" />
/// <reference types="stripe/types/2020-08-27/Files" />
/// <reference types="stripe/types/2020-08-27/Identity/VerificationReports" />
/// <reference types="stripe/types/2020-08-27/Identity/VerificationSessions" />
/// <reference types="stripe/types/2020-08-27/InvoiceItems" />
/// <reference types="stripe/types/2020-08-27/InvoiceLineItems" />
/// <reference types="stripe/types/2020-08-27/Invoices" />
/// <reference types="stripe/types/2020-08-27/IssuerFraudRecords" />
/// <reference types="stripe/types/2020-08-27/Issuing/Authorizations" />
/// <reference types="stripe/types/2020-08-27/Issuing/CardDetails" />
/// <reference types="stripe/types/2020-08-27/Issuing/Cardholders" />
/// <reference types="stripe/types/2020-08-27/Issuing/Cards" />
/// <reference types="stripe/types/2020-08-27/Issuing/Disputes" />
/// <reference types="stripe/types/2020-08-27/Issuing/Transactions" />
/// <reference types="stripe/types/2020-08-27/LineItems" />
/// <reference types="stripe/types/2020-08-27/LoginLinks" />
/// <reference types="stripe/types/2020-08-27/Mandates" />
/// <reference types="stripe/types/2020-08-27/OrderItems" />
/// <reference types="stripe/types/2020-08-27/OrderReturns" />
/// <reference types="stripe/types/2020-08-27/Orders" />
/// <reference types="stripe/types/2020-08-27/PaymentIntents" />
/// <reference types="stripe/types/2020-08-27/PaymentMethods" />
/// <reference types="stripe/types/2020-08-27/Payouts" />
/// <reference types="stripe/types/2020-08-27/Persons" />
/// <reference types="stripe/types/2020-08-27/Plans" />
/// <reference types="stripe/types/2020-08-27/PlatformTaxFees" />
/// <reference types="stripe/types/2020-08-27/Prices" />
/// <reference types="stripe/types/2020-08-27/Products" />
/// <reference types="stripe/types/2020-08-27/PromotionCodes" />
/// <reference types="stripe/types/2020-08-27/Quotes" />
/// <reference types="stripe/types/2020-08-27/Radar/EarlyFraudWarnings" />
/// <reference types="stripe/types/2020-08-27/Radar/ValueListItems" />
/// <reference types="stripe/types/2020-08-27/Radar/ValueLists" />
/// <reference types="stripe/types/2020-08-27/Recipients" />
/// <reference types="stripe/types/2020-08-27/Refunds" />
/// <reference types="stripe/types/2020-08-27/Reporting/ReportRuns" />
/// <reference types="stripe/types/2020-08-27/Reporting/ReportTypes" />
/// <reference types="stripe/types/2020-08-27/ReserveTransactions" />
/// <reference types="stripe/types/2020-08-27/Reviews" />
/// <reference types="stripe/types/2020-08-27/SKUs" />
/// <reference types="stripe/types/2020-08-27/SetupAttempts" />
/// <reference types="stripe/types/2020-08-27/SetupIntents" />
/// <reference types="stripe/types/2020-08-27/ShippingRates" />
/// <reference types="stripe/types/2020-08-27/Sigma/ScheduledQueryRuns" />
/// <reference types="stripe/types/2020-08-27/SourceMandateNotifications" />
/// <reference types="stripe/types/2020-08-27/SourceTransactions" />
/// <reference types="stripe/types/2020-08-27/Sources" />
/// <reference types="stripe/types/2020-08-27/SubscriptionItems" />
/// <reference types="stripe/types/2020-08-27/SubscriptionSchedules" />
/// <reference types="stripe/types/2020-08-27/Subscriptions" />
/// <reference types="stripe/types/2020-08-27/TaxCodes" />
/// <reference types="stripe/types/2020-08-27/TaxDeductedAtSources" />
/// <reference types="stripe/types/2020-08-27/TaxIds" />
/// <reference types="stripe/types/2020-08-27/TaxRates" />
/// <reference types="stripe/types/2020-08-27/Terminal/ConnectionTokens" />
/// <reference types="stripe/types/2020-08-27/Terminal/Locations" />
/// <reference types="stripe/types/2020-08-27/Terminal/Readers" />
/// <reference types="stripe/types/2020-08-27/Tokens" />
/// <reference types="stripe/types/2020-08-27/Topups" />
/// <reference types="stripe/types/2020-08-27/TransferReversals" />
/// <reference types="stripe/types/2020-08-27/Transfers" />
/// <reference types="stripe/types/2020-08-27/UsageRecordSummaries" />
/// <reference types="stripe/types/2020-08-27/UsageRecords" />
/// <reference types="stripe/types/2020-08-27/WebhookEndpoints" />
/// <reference types="stripe" />
/// <reference types="stripe/types/lib" />
/// <reference types="stripe/types/net/net" />
import { XiomeMockConfig } from "./frontend/types/xiome-config-mock.js";
export declare function assembleXiomeMock(mockConfig: XiomeMockConfig): Promise<{
    appId: string;
    components: {
        XiomeNotes: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    notesModel: {
                        initialize: () => Promise<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            statsOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        }>;
                        stateSubscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            statsOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        }>) => void) => () => void;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                        readonly isLoggedIn: boolean;
                        readonly stats: import("../features/notes/types/notes-concepts.js").NotesStats;
                        propagateChangeToOtherTabs: import("../toolbox/subbies.js").Subbie<undefined>;
                        loadStats: () => Promise<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        overwriteStatsOp(op: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>): void;
                        createNotesCacheDetails: () => {
                            cache: {
                                subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                                    old: boolean;
                                    pageNumber: number;
                                    pageSize: number;
                                    notesOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                                }>) => void) => () => void;
                                cacheState: import("../toolbox/snapstate/parts/types.js").Readable<{
                                    old: boolean;
                                    pageNumber: number;
                                    pageSize: number;
                                    notesOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                                }>;
                                loginStatusChanged(): Promise<void>;
                                readonly notes: import("../features/notes/types/notes-concepts.js").Notes.Any[];
                                fetchAppropriateNotes: () => Promise<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                                switchTabNew(): Promise<void>;
                                switchTabOld(): Promise<void>;
                                readonly isNextPageAvailable: boolean;
                                readonly isPreviousPageAvailable: boolean;
                                nextPage(): Promise<void>;
                                previousPage(): Promise<void>;
                                markAllNotesOld(): Promise<void>;
                                markSpecificNoteOld(noteId: string): Promise<void>;
                                markSpecificNoteNew(noteId: string): Promise<void>;
                                readonly totalPages: number;
                            };
                            setup: () => () => void;
                        };
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/notes/components/notes/xiome-notes.js").XiomeNotes;
        XiomeNotesIndicator: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    notesModel: {
                        initialize: () => Promise<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            statsOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        }>;
                        stateSubscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            statsOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        }>) => void) => () => void;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                        readonly isLoggedIn: boolean;
                        readonly stats: import("../features/notes/types/notes-concepts.js").NotesStats;
                        propagateChangeToOtherTabs: import("../toolbox/subbies.js").Subbie<undefined>;
                        loadStats: () => Promise<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        overwriteStatsOp(op: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>): void;
                        createNotesCacheDetails: () => {
                            cache: {
                                subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                                    old: boolean;
                                    pageNumber: number;
                                    pageSize: number;
                                    notesOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                                }>) => void) => () => void;
                                cacheState: import("../toolbox/snapstate/parts/types.js").Readable<{
                                    old: boolean;
                                    pageNumber: number;
                                    pageSize: number;
                                    notesOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                                }>;
                                loginStatusChanged(): Promise<void>;
                                readonly notes: import("../features/notes/types/notes-concepts.js").Notes.Any[];
                                fetchAppropriateNotes: () => Promise<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                                switchTabNew(): Promise<void>;
                                switchTabOld(): Promise<void>;
                                readonly isNextPageAvailable: boolean;
                                readonly isPreviousPageAvailable: boolean;
                                nextPage(): Promise<void>;
                                previousPage(): Promise<void>;
                                markAllNotesOld(): Promise<void>;
                                markSpecificNoteOld(noteId: string): Promise<void>;
                                markSpecificNoteNew(noteId: string): Promise<void>;
                                readonly totalPages: number;
                            };
                            setup: () => () => void;
                        };
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/notes/components/notes-indicator/xiome-notes-indicator.js").XiomeNotesIndicator;
        XiomeChat: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    modals: import("./frontend/modal/types/modal-system.js").ModalSystem;
                    chatModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            connectionOp: import("../framework/ops.js").Op<import("../features/chat/common/types/chat-concepts.js").ChatConnection>;
                            cache: {
                                mutedUserIds: string[];
                                rooms: {
                                    [key: string]: {
                                        status: import("../features/chat/common/types/chat-concepts.js").ChatStatus;
                                        posts: import("../features/chat/common/types/chat-concepts.js").ChatPost[];
                                    };
                                };
                            };
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            connectionOp: import("../framework/ops.js").Op<import("../features/chat/common/types/chat-concepts.js").ChatConnection>;
                            cache: {
                                mutedUserIds: string[];
                                rooms: {
                                    [key: string]: {
                                        status: import("../features/chat/common/types/chat-concepts.js").ChatStatus;
                                        posts: import("../features/chat/common/types/chat-concepts.js").ChatPost[];
                                    };
                                };
                            };
                        }>) => void) => () => void;
                        subscribeToChange: (...listeners: (() => void | Promise<void>)[]) => () => void;
                        readonly allowance: {
                            moderateAllChats: boolean;
                            participateInAllChats: boolean;
                            viewAllChats: boolean;
                            banned: boolean;
                        };
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                        session: (label: string) => Promise<{
                            dispose: () => void;
                            room: {
                                readonly posts: import("../features/chat/common/types/chat-concepts.js").ChatPost[];
                                readonly status: import("../features/chat/common/types/chat-concepts.js").ChatStatus;
                                readonly muted: string[];
                                readonly weAreMuted: boolean;
                                readonly weAreBanned: boolean;
                                setRoomStatus(status: import("../features/chat/common/types/chat-concepts.js").ChatStatus): void;
                                post(draft: import("../features/chat/common/types/chat-concepts.js").ChatDraft): void;
                                remove(postIds: string[]): void;
                                clear(): void;
                                mute(userId: string): void;
                                unmute(userId: string): void;
                                unmuteAll(): void;
                            };
                        }>;
                        disconnect: () => Promise<void>;
                        reconnect: () => Promise<import("../features/chat/common/types/chat-concepts.js").ChatConnection>;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/chat/components/xiome-chat/xiome-chat.js").XiomeChat;
        XiomeVideoHosting: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    dacastModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            linkedAccountOp: import("../framework/ops.js").Op<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            linkedAccountOp: import("../framework/ops.js").Op<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                        }>) => void) => () => void;
                        onLinkChange: (listener: (context: import("../features/videos/types/dacast-link.js").DacastLinkDisplay) => void) => () => void;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                        initialize(): Promise<void>;
                        readonly linkedAccount: import("../features/videos/types/dacast-link.js").DacastLinkDisplay;
                        linkAccount({ apiKey }: {
                            apiKey: string;
                        }): Promise<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                        unlinkAccount(): Promise<void>;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/videos/components/video-hosting/xiome-video-hosting.js").XiomeVideoHosting;
        XiomeVideoDisplay: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    contentModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            catalogOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                            viewsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoView[]>;
                            privilegesOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                            showsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            catalogOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                            viewsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoView[]>;
                            privilegesOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                            showsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                        }>) => void) => () => void;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                        onVideoHostingUpdate(): Promise<void>;
                        initializeForModerationData(): Promise<void>;
                        initializeForVideo(label: string): Promise<void>;
                        readonly allowance: {
                            canModerateVideos: boolean;
                            canViewAllVideos: boolean;
                        };
                        readonly catalog: import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[];
                        readonly views: import("../features/videos/types/video-concepts.js").VideoView[];
                        readonly privileges: import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[];
                        readonly shows: import("../features/videos/types/video-concepts.js").VideoShow[];
                        getView(label: string): import("../features/videos/types/video-concepts.js").VideoView;
                        getPrivilege(id: string): import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay;
                        getShow(label: string): import("../features/videos/types/video-concepts.js").VideoShow;
                        setView(options: {
                            label: string;
                            privileges: string[];
                            reference: import("../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
                        }): Promise<void>;
                        deleteView(label: string): Promise<void>;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/videos/components/video-display/xiome-video-display.js").XiomeVideoDisplay;
        XiomeVideoViews: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    contentModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            catalogOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                            viewsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoView[]>;
                            privilegesOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                            showsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            catalogOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                            viewsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoView[]>;
                            privilegesOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                            showsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                        }>) => void) => () => void;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                        onVideoHostingUpdate(): Promise<void>;
                        initializeForModerationData(): Promise<void>;
                        initializeForVideo(label: string): Promise<void>;
                        readonly allowance: {
                            canModerateVideos: boolean;
                            canViewAllVideos: boolean;
                        };
                        readonly catalog: import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[];
                        readonly views: import("../features/videos/types/video-concepts.js").VideoView[];
                        readonly privileges: import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[];
                        readonly shows: import("../features/videos/types/video-concepts.js").VideoShow[];
                        getView(label: string): import("../features/videos/types/video-concepts.js").VideoView;
                        getPrivilege(id: string): import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay;
                        getShow(label: string): import("../features/videos/types/video-concepts.js").VideoShow;
                        setView(options: {
                            label: string;
                            privileges: string[];
                            reference: import("../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
                        }): Promise<void>;
                        deleteView(label: string): Promise<void>;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/videos/components/video-views/xiome-video-views.js").XiomeVideoViews;
        XiomeVideoCompanion: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    contentModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            catalogOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                            viewsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoView[]>;
                            privilegesOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                            showsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            catalogOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                            viewsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoView[]>;
                            privilegesOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                            showsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                        }>) => void) => () => void;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                        onVideoHostingUpdate(): Promise<void>;
                        initializeForModerationData(): Promise<void>;
                        initializeForVideo(label: string): Promise<void>;
                        readonly allowance: {
                            canModerateVideos: boolean;
                            canViewAllVideos: boolean;
                        };
                        readonly catalog: import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[];
                        readonly views: import("../features/videos/types/video-concepts.js").VideoView[];
                        readonly privileges: import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[];
                        readonly shows: import("../features/videos/types/video-concepts.js").VideoShow[];
                        getView(label: string): import("../features/videos/types/video-concepts.js").VideoView;
                        getPrivilege(id: string): import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay;
                        getShow(label: string): import("../features/videos/types/video-concepts.js").VideoShow;
                        setView(options: {
                            label: string;
                            privileges: string[];
                            reference: import("../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
                        }): Promise<void>;
                        deleteView(label: string): Promise<void>;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/videos/components/video-companion/xiome-video-companion.js").XiomeVideoCompanion;
        XiomeManageUsers: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    modals: import("./frontend/modal/types/modal-system.js").ModalSystem;
                    administrativeModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }>) => void) => () => void;
                        getAccess: () => import("../features/auth/types/auth-tokens.js").AccessPayload;
                        initialize: () => Promise<void>;
                        readonly isAllowed: (privilege: "universal" | "banned" | "view all chats" | "participate in all chats" | "read questions" | "post questions" | "like questions" | "report questions" | "moderate all chats" | "control stripe account" | "manage store" | "give away freebies" | "view all videos" | "moderate videos" | "edit any profile" | "customize permissions" | "answer questions" | "moderate questions" | "view stats" | "administrate user roles") => boolean;
                        reauthorize: () => Promise<void>;
                        searchUsers: (options: {
                            term: string;
                        }) => Promise<{
                            user: {
                                userId: string;
                                profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                                roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                            };
                            roleIds: string[];
                        }[]>;
                        assignRoleToUser: (options: {
                            roleId: string;
                            userId: string;
                            isPublic: boolean;
                            timeframeEnd: number;
                            timeframeStart: number;
                        }) => Promise<void>;
                        revokeRoleFromUser: (options: {
                            roleId: string;
                            userId: string;
                        }) => Promise<void>;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/administrative/components/xiome-manage-users/xiome-manage-users.js").XiomeManageUsers;
        XiomeQuestions: {
            new (...args: any[]): {
                "__#6@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    modals: import("./frontend/modal/types/modal-system.js").ModalSystem;
                    questionsModel: {
                        onStateChange: import("../toolbox/pubsub.js").Subscribe<import("../toolbox/pubsub.js").AnyListener>;
                        makeBoardModel: (board: string) => {
                            getPermissions(): {
                                readonly "read questions": boolean;
                                readonly "post questions": boolean;
                                readonly "moderate questions": boolean;
                                readonly "answer questions": boolean;
                                readonly "like questions": boolean;
                                readonly "report questions": boolean;
                            };
                            getBoardName(): string;
                            getAccess(): import("../features/auth/types/auth-tokens.js").AccessPayload;
                            getBoardOp(): import("../framework/ops.js").Op<void>;
                            getPostingOp(): import("../framework/ops.js").Op<void>;
                            getQuestions(): {
                                answers: import("../features/questions/api/types/questions-and-answers.js").Answer[];
                                questionId: string;
                                authorUserId: string;
                                board: string;
                                content: string;
                                archive: boolean;
                                timePosted: number;
                                liked: boolean;
                                likes: number;
                                reports: number;
                                reported: boolean;
                            }[];
                            getUser(userId: string): import("../features/auth/aspects/users/types/user.js").User;
                            loadQuestions(): Promise<void>;
                            postQuestion({ content }: {
                                content: string;
                            }): Promise<import("../features/questions/api/types/questions-and-answers.js").Question>;
                            postAnswer(questionId: string, answerDraft: import("../features/questions/api/types/answer-draft.js").AnswerDraft): Promise<import("../features/questions/api/types/questions-and-answers.js").Answer>;
                            likeQuestion(questionId: string, like: boolean): Promise<void>;
                            likeAnswer(questionId: string, answerId: string, like: boolean): Promise<void>;
                            reportQuestion(questionId: string, report: boolean): Promise<void>;
                            reportAnswer(questionId: string, answerId: string, report: boolean): Promise<void>;
                            archiveQuestion(questionId: string, archive: boolean): Promise<void>;
                            archiveAnswer(questionId: string, answerId: string, archive: boolean): Promise<void>;
                            archiveBoard(): Promise<void>;
                        };
                        accessChange: (access: import("../features/auth/types/auth-tokens.js").AccessPayload) => void;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/questions/components/xiome-questions/xiome-questions.js").XiomeQuestions;
        XiomeMyAvatar: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    accessModel: {
                        getAccessOp(): import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        getAccess(): import("../features/auth/types/auth-tokens.js").AccessPayload;
                        getValidAccess(): Promise<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        useExistingLogin(): Promise<void>;
                        sendLoginLink(email: string): Promise<void>;
                        login(loginToken: string): Promise<void>;
                        logout(): Promise<void>;
                        reauthorize(): Promise<void>;
                        readable: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }>;
                        track: <X>(observer: import("../toolbox/snapstate/parts/types.js").Observer<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }, X>, reaction?: import("../toolbox/snapstate/parts/types.js").Reaction<X>) => () => void;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }>) => void) => () => void;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/auth/aspects/users/components/my-avatar/xiome-my-avatar.js").XiomeMyAvatar;
        XiomeLoginPanel: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    accessModel: {
                        getAccessOp(): import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        getAccess(): import("../features/auth/types/auth-tokens.js").AccessPayload;
                        getValidAccess(): Promise<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        useExistingLogin(): Promise<void>;
                        sendLoginLink(email: string): Promise<void>;
                        login(loginToken: string): Promise<void>;
                        logout(): Promise<void>;
                        reauthorize(): Promise<void>;
                        readable: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }>;
                        track: <X>(observer: import("../toolbox/snapstate/parts/types.js").Observer<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }, X>, reaction?: import("../toolbox/snapstate/parts/types.js").Reaction<X>) => () => void;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }>) => void) => () => void;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/auth/aspects/users/components/login-panel/xiome-login-panel.js").XiomeLoginPanel;
        XiomeAppManager: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    modals: import("./frontend/modal/types/modal-system.js").ModalSystem;
                    appsModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            active: boolean;
                            appRecords: import("../framework/ops.js").Op<import("../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
                            addingNewApp: import("../framework/ops.js").Op<null>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            active: boolean;
                            appRecords: import("../framework/ops.js").Op<import("../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
                            addingNewApp: import("../framework/ops.js").Op<null>;
                        }>) => void) => () => void;
                        appEditService: {
                            updateApp({ appId: appIdString, appDraft }: {
                                appId: string;
                                appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                            }): Promise<void>;
                            deleteApp({ appId: appIdString }: {
                                appId: string;
                            }): Promise<void>;
                            listAdmins({ appId: appIdString }: {
                                appId: string;
                            }): Promise<import("../features/auth/aspects/apps/types/admin-email-display.js").AdminEmailDisplay[]>;
                            assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }: {
                                appId: string;
                                platformUserId: string;
                            }): Promise<void>;
                            assignAdmin({ appId: appIdString, email }: {
                                appId: string;
                                email: string;
                            }): Promise<void>;
                            revokeAdmin({ appId: appIdString, userId: userIdString }: {
                                appId: string;
                                userId: string;
                            }): Promise<void>;
                        };
                        getApp(appId: string): import("../features/auth/aspects/apps/types/app-display.js").AppDisplay;
                        loadApps: () => Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay[]>;
                        deleteApp: (appId: string) => Promise<void>;
                        updateApp: (appId: string, appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<void>;
                        registerApp: (appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay>;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/auth/aspects/apps/components/app-manager/xiome-app-manager.js").XiomeAppManager;
        XiomeMyAccount: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    personalModel: {
                        track: <X_1>(observer: import("../toolbox/snapstate/parts/types.js").Observer<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            submitDraftOp: import("../framework/ops.js").Op<void>;
                        }, X_1>, reaction?: import("../toolbox/snapstate/parts/types.js").Reaction<X_1>) => () => void;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            submitDraftOp: import("../framework/ops.js").Op<void>;
                        }>) => void) => () => void;
                        readable: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            submitDraftOp: import("../framework/ops.js").Op<void>;
                        }>;
                        saveProfile(profileDraft: import("../features/auth/aspects/users/routines/personal/types/profile-draft.js").ProfileDraft): Promise<void>;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): void;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/auth/aspects/users/components/my-account/xiome-my-account.js").XiomeMyAccount;
        XiomePermissions: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    modals: import("./frontend/modal/types/modal-system.js").ModalSystem;
                    permissionsModel: {
                        readable: import("../toolbox/snapstate/parts/types.js").Readable<{
                            active: boolean;
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            active: boolean;
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }>) => void) => () => void;
                        track: <X_2>(observer: import("../toolbox/snapstate/parts/types.js").Observer<{
                            active: boolean;
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }, X_2>, reaction?: import("../toolbox/snapstate/parts/types.js").Reaction<X_2>) => () => void;
                        getAccess: () => import("../features/auth/types/auth-tokens.js").AccessPayload;
                        initialize: () => Promise<void>;
                        getUserCanCustomizePermissions: () => boolean;
                        createRole: ({ label }: {
                            label: string;
                        }) => Promise<void>;
                        deleteRole: ({ roleId: roleIdString }: {
                            roleId: string;
                        }) => Promise<void>;
                        assignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                            roleId: string;
                            privilegeId: string;
                        }) => Promise<void>;
                        unassignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                            roleId: string;
                            privilegeId: string;
                        }) => Promise<void>;
                        deletePrivilege: ({ privilegeId: privilegeIdString }: {
                            privilegeId: string;
                        }) => Promise<void>;
                        createPrivilege: ({ label }: {
                            label: string;
                        }) => Promise<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/auth/aspects/permissions/components/permissions/xiome-permissions.js").XiomePermissions;
        XiomePrivileges: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    modals: import("./frontend/modal/types/modal-system.js").ModalSystem;
                    permissionsModel: {
                        readable: import("../toolbox/snapstate/parts/types.js").Readable<{
                            active: boolean;
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            active: boolean;
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }>) => void) => () => void;
                        track: <X_2>(observer: import("../toolbox/snapstate/parts/types.js").Observer<{
                            active: boolean;
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }, X_2>, reaction?: import("../toolbox/snapstate/parts/types.js").Reaction<X_2>) => () => void;
                        getAccess: () => import("../features/auth/types/auth-tokens.js").AccessPayload;
                        initialize: () => Promise<void>;
                        getUserCanCustomizePermissions: () => boolean;
                        createRole: ({ label }: {
                            label: string;
                        }) => Promise<void>;
                        deleteRole: ({ roleId: roleIdString }: {
                            roleId: string;
                        }) => Promise<void>;
                        assignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                            roleId: string;
                            privilegeId: string;
                        }) => Promise<void>;
                        unassignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                            roleId: string;
                            privilegeId: string;
                        }) => Promise<void>;
                        deletePrivilege: ({ privilegeId: privilegeIdString }: {
                            privilegeId: string;
                        }) => Promise<void>;
                        createPrivilege: ({ label }: {
                            label: string;
                        }) => Promise<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/auth/aspects/permissions/components/privileges/xiome-privileges.js").XiomePrivileges;
        XiomeExample: {
            new (...args: any[]): {
                "__#8@#unsubscribes": (() => void)[];
                connectedCallback(): void;
                disconnectedCallback(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & {
            new (...args: any[]): {
                readonly share: {
                    modals: import("./frontend/modal/types/modal-system.js").ModalSystem;
                    exampleModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }>) => void) => () => void;
                        updateAccessOp: (op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>) => void;
                    };
                };
                init(): void;
                render?(): unknown;
                firstUpdated?(_changedProperties: Map<string | number | symbol, unknown>): void;
                requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: import("lit").PropertyDeclaration<unknown, unknown>) => void;
                readonly updateComplete: Promise<boolean>;
                observedAttributes?: string[];
                connectedCallback?(): void;
                disconnectedCallback?(): void;
                attributeChangedCallback?(attributeName: string, oldValue: string, newValue: string): void;
                accessKey: string;
                readonly accessKeyLabel: string;
                autocapitalize: string;
                dir: string;
                draggable: boolean;
                hidden: boolean;
                innerText: string;
                lang: string;
                readonly offsetHeight: number;
                readonly offsetLeft: number;
                readonly offsetParent: Element;
                readonly offsetTop: number;
                readonly offsetWidth: number;
                outerText: string;
                spellcheck: boolean;
                title: string;
                translate: boolean;
                attachInternals(): ElementInternals;
                click(): void;
                addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                readonly attributes: NamedNodeMap;
                readonly classList: DOMTokenList;
                className: string;
                readonly clientHeight: number;
                readonly clientLeft: number;
                readonly clientTop: number;
                readonly clientWidth: number;
                id: string;
                readonly localName: string;
                readonly namespaceURI: string;
                onfullscreenchange: (this: Element, ev: Event) => any;
                onfullscreenerror: (this: Element, ev: Event) => any;
                outerHTML: string;
                readonly ownerDocument: Document;
                readonly part: DOMTokenList;
                readonly prefix: string;
                readonly scrollHeight: number;
                scrollLeft: number;
                scrollTop: number;
                readonly scrollWidth: number;
                readonly shadowRoot: ShadowRoot;
                slot: string;
                readonly tagName: string;
                attachShadow(init: ShadowRootInit): ShadowRoot;
                closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2];
                closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3];
                closest<E extends Element = Element>(selectors: string): E;
                getAttribute(qualifiedName: string): string;
                getAttributeNS(namespace: string, localName: string): string;
                getAttributeNames(): string[];
                getAttributeNode(qualifiedName: string): Attr;
                getAttributeNodeNS(namespace: string, localName: string): Attr;
                getBoundingClientRect(): DOMRect;
                getClientRects(): DOMRectList;
                getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
                getElementsByTagName<K_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_4): HTMLCollectionOf<HTMLElementTagNameMap[K_4]>;
                getElementsByTagName<K_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<SVGElementTagNameMap[K_5]>;
                getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
                getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
                getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
                hasAttribute(qualifiedName: string): boolean;
                hasAttributeNS(namespace: string, localName: string): boolean;
                hasAttributes(): boolean;
                hasPointerCapture(pointerId: number): boolean;
                insertAdjacentElement(where: InsertPosition, element: Element): Element;
                insertAdjacentHTML(position: InsertPosition, text: string): void;
                insertAdjacentText(where: InsertPosition, data: string): void;
                matches(selectors: string): boolean;
                releasePointerCapture(pointerId: number): void;
                removeAttribute(qualifiedName: string): void;
                removeAttributeNS(namespace: string, localName: string): void;
                removeAttributeNode(attr: Attr): Attr;
                requestFullscreen(options?: FullscreenOptions): Promise<void>;
                requestPointerLock(): void;
                scroll(options?: ScrollToOptions): void;
                scroll(x: number, y: number): void;
                scrollBy(options?: ScrollToOptions): void;
                scrollBy(x: number, y: number): void;
                scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
                scrollTo(options?: ScrollToOptions): void;
                scrollTo(x: number, y: number): void;
                setAttribute(qualifiedName: string, value: string): void;
                setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
                setAttributeNode(attr: Attr): Attr;
                setAttributeNodeNS(attr: Attr): Attr;
                setPointerCapture(pointerId: number): void;
                toggleAttribute(qualifiedName: string, force?: boolean): boolean;
                webkitMatchesSelector(selectors: string): boolean;
                readonly baseURI: string;
                readonly childNodes: NodeListOf<ChildNode>;
                readonly firstChild: ChildNode;
                readonly isConnected: boolean;
                readonly lastChild: ChildNode;
                readonly nextSibling: ChildNode;
                readonly nodeName: string;
                readonly nodeType: number;
                nodeValue: string;
                readonly parentElement: HTMLElement;
                readonly parentNode: ParentNode;
                readonly previousSibling: ChildNode;
                textContent: string;
                appendChild<T extends Node>(node: T): T;
                cloneNode(deep?: boolean): Node;
                compareDocumentPosition(other: Node): number;
                contains(other: Node): boolean;
                getRootNode(options?: GetRootNodeOptions): Node;
                hasChildNodes(): boolean;
                insertBefore<T_1 extends Node>(node: T_1, child: Node): T_1;
                isDefaultNamespace(namespace: string): boolean;
                isEqualNode(otherNode: Node): boolean;
                isSameNode(otherNode: Node): boolean;
                lookupNamespaceURI(prefix: string): string;
                lookupPrefix(namespace: string): string;
                normalize(): void;
                removeChild<T_2 extends Node>(child: T_2): T_2;
                replaceChild<T_3 extends Node>(node: Node, child: T_3): T_3;
                readonly ATTRIBUTE_NODE: number;
                readonly CDATA_SECTION_NODE: number;
                readonly COMMENT_NODE: number;
                readonly DOCUMENT_FRAGMENT_NODE: number;
                readonly DOCUMENT_NODE: number;
                readonly DOCUMENT_POSITION_CONTAINED_BY: number;
                readonly DOCUMENT_POSITION_CONTAINS: number;
                readonly DOCUMENT_POSITION_DISCONNECTED: number;
                readonly DOCUMENT_POSITION_FOLLOWING: number;
                readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;
                readonly DOCUMENT_POSITION_PRECEDING: number;
                readonly DOCUMENT_TYPE_NODE: number;
                readonly ELEMENT_NODE: number;
                readonly ENTITY_NODE: number;
                readonly ENTITY_REFERENCE_NODE: number;
                readonly NOTATION_NODE: number;
                readonly PROCESSING_INSTRUCTION_NODE: number;
                readonly TEXT_NODE: number;
                dispatchEvent(event: Event): boolean;
                ariaAtomic: string;
                ariaAutoComplete: string;
                ariaBusy: string;
                ariaChecked: string;
                ariaColCount: string;
                ariaColIndex: string;
                ariaColSpan: string;
                ariaCurrent: string;
                ariaDisabled: string;
                ariaExpanded: string;
                ariaHasPopup: string;
                ariaHidden: string;
                ariaKeyShortcuts: string;
                ariaLabel: string;
                ariaLevel: string;
                ariaLive: string;
                ariaModal: string;
                ariaMultiLine: string;
                ariaMultiSelectable: string;
                ariaOrientation: string;
                ariaPlaceholder: string;
                ariaPosInSet: string;
                ariaPressed: string;
                ariaReadOnly: string;
                ariaRequired: string;
                ariaRoleDescription: string;
                ariaRowCount: string;
                ariaRowIndex: string;
                ariaRowSpan: string;
                ariaSelected: string;
                ariaSetSize: string;
                ariaSort: string;
                ariaValueMax: string;
                ariaValueMin: string;
                ariaValueNow: string;
                ariaValueText: string;
                animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
                getAnimations(options?: GetAnimationsOptions): Animation[];
                after(...nodes: (string | Node)[]): void;
                before(...nodes: (string | Node)[]): void;
                remove(): void;
                replaceWith(...nodes: (string | Node)[]): void;
                innerHTML: string;
                readonly nextElementSibling: Element;
                readonly previousElementSibling: Element;
                readonly childElementCount: number;
                readonly children: HTMLCollection;
                readonly firstElementChild: Element;
                readonly lastElementChild: Element;
                append(...nodes: (string | Node)[]): void;
                prepend(...nodes: (string | Node)[]): void;
                querySelector<K_6 extends keyof HTMLElementTagNameMap>(selectors: K_6): HTMLElementTagNameMap[K_6];
                querySelector<K_7 extends keyof SVGElementTagNameMap>(selectors: K_7): SVGElementTagNameMap[K_7];
                querySelector<E_1 extends Element = Element>(selectors: string): E_1;
                querySelectorAll<K_8 extends keyof HTMLElementTagNameMap>(selectors: K_8): NodeListOf<HTMLElementTagNameMap[K_8]>;
                querySelectorAll<K_9 extends keyof SVGElementTagNameMap>(selectors: K_9): NodeListOf<SVGElementTagNameMap[K_9]>;
                querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;
                replaceChildren(...nodes: (string | Node)[]): void;
                readonly assignedSlot: HTMLSlotElement;
                oncopy: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                oncut: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                onpaste: (this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any;
                readonly style: CSSStyleDeclaration;
                contentEditable: string;
                enterKeyHint: string;
                inputMode: string;
                readonly isContentEditable: boolean;
                onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
                onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
                oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
                onchange: (this: GlobalEventHandlers, ev: Event) => any;
                onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onclose: (this: GlobalEventHandlers, ev: Event) => any;
                oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
                ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
                ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
                onemptied: (this: GlobalEventHandlers, ev: Event) => any;
                onended: (this: GlobalEventHandlers, ev: Event) => any;
                onerror: OnErrorEventHandlerNonNull;
                onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
                onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
                ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                oninput: (this: GlobalEventHandlers, ev: Event) => any;
                oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
                onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
                onload: (this: GlobalEventHandlers, ev: Event) => any;
                onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
                onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
                onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
                onpause: (this: GlobalEventHandlers, ev: Event) => any;
                onplay: (this: GlobalEventHandlers, ev: Event) => any;
                onplaying: (this: GlobalEventHandlers, ev: Event) => any;
                onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
                onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
                onratechange: (this: GlobalEventHandlers, ev: Event) => any;
                onreset: (this: GlobalEventHandlers, ev: Event) => any;
                onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
                onscroll: (this: GlobalEventHandlers, ev: Event) => any;
                onseeked: (this: GlobalEventHandlers, ev: Event) => any;
                onseeking: (this: GlobalEventHandlers, ev: Event) => any;
                onselect: (this: GlobalEventHandlers, ev: Event) => any;
                onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
                onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
                onstalled: (this: GlobalEventHandlers, ev: Event) => any;
                onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
                onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
                ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
                ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
                ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
                ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
                onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
                onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
                onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
                onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
                autofocus: boolean;
                readonly dataset: DOMStringMap;
                nonce?: string;
                tabIndex: number;
                blur(): void;
                focus(options?: FocusOptions): void;
            };
        } & typeof import("../features/example/components/xiome-example/xiome-example.js").XiomeExample;
        XioId: typeof import("../features/xio-components/id/xio-id.js").XioId;
        XioOp: typeof import("../features/xio-components/op/xio-op.js").XioOp;
        XioAvatar: typeof import("../features/xio-components/avatar/xio-avatar.js").XioAvatar;
        XioButton: typeof import("../features/xio-components/button/xio-button.js").XioButton;
        XioExample: typeof import("../features/xio-components/example/xio-example.js").XioExample;
        XioCheckbox: typeof import("../features/xio-components/checkbox/xio-checkbox.js").XioCheckbox;
        XioTextInput: typeof import("../features/xio-components/inputs/xio-text-input.js").XioTextInput;
        XioProfileCard: typeof import("../features/xio-components/profile-card/xio-profile-card.js").XioProfileCard;
    };
    models: {
        exampleModel: {
            state: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
            }>;
            subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
            }>) => void) => () => void;
            updateAccessOp: (op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>) => void;
        };
        appsModel: {
            state: import("../toolbox/snapstate/parts/types.js").Readable<{
                active: boolean;
                appRecords: import("../framework/ops.js").Op<import("../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
                addingNewApp: import("../framework/ops.js").Op<null>;
            }>;
            subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                active: boolean;
                appRecords: import("../framework/ops.js").Op<import("../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
                addingNewApp: import("../framework/ops.js").Op<null>;
            }>) => void) => () => void;
            appEditService: {
                updateApp({ appId: appIdString, appDraft }: {
                    appId: string;
                    appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                }): Promise<void>;
                deleteApp({ appId: appIdString }: {
                    appId: string;
                }): Promise<void>;
                listAdmins({ appId: appIdString }: {
                    appId: string;
                }): Promise<import("../features/auth/aspects/apps/types/admin-email-display.js").AdminEmailDisplay[]>;
                assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }: {
                    appId: string;
                    platformUserId: string;
                }): Promise<void>;
                assignAdmin({ appId: appIdString, email }: {
                    appId: string;
                    email: string;
                }): Promise<void>;
                revokeAdmin({ appId: appIdString, userId: userIdString }: {
                    appId: string;
                    userId: string;
                }): Promise<void>;
            };
            getApp(appId: string): import("../features/auth/aspects/apps/types/app-display.js").AppDisplay;
            loadApps: () => Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay[]>;
            deleteApp: (appId: string) => Promise<void>;
            updateApp: (appId: string, appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<void>;
            registerApp: (appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay>;
            updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
        };
        chatModel: {
            state: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                connectionOp: import("../framework/ops.js").Op<import("../features/chat/common/types/chat-concepts.js").ChatConnection>;
                cache: {
                    mutedUserIds: string[];
                    rooms: {
                        [key: string]: {
                            status: import("../features/chat/common/types/chat-concepts.js").ChatStatus;
                            posts: import("../features/chat/common/types/chat-concepts.js").ChatPost[];
                        };
                    };
                };
            }>;
            subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                connectionOp: import("../framework/ops.js").Op<import("../features/chat/common/types/chat-concepts.js").ChatConnection>;
                cache: {
                    mutedUserIds: string[];
                    rooms: {
                        [key: string]: {
                            status: import("../features/chat/common/types/chat-concepts.js").ChatStatus;
                            posts: import("../features/chat/common/types/chat-concepts.js").ChatPost[];
                        };
                    };
                };
            }>) => void) => () => void;
            subscribeToChange: (...listeners: (() => void | Promise<void>)[]) => () => void;
            readonly allowance: {
                moderateAllChats: boolean;
                participateInAllChats: boolean;
                viewAllChats: boolean;
                banned: boolean;
            };
            updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            session: (label: string) => Promise<{
                dispose: () => void;
                room: {
                    readonly posts: import("../features/chat/common/types/chat-concepts.js").ChatPost[];
                    readonly status: import("../features/chat/common/types/chat-concepts.js").ChatStatus;
                    readonly muted: string[];
                    readonly weAreMuted: boolean;
                    readonly weAreBanned: boolean;
                    setRoomStatus(status: import("../features/chat/common/types/chat-concepts.js").ChatStatus): void;
                    post(draft: import("../features/chat/common/types/chat-concepts.js").ChatDraft): void;
                    remove(postIds: string[]): void;
                    clear(): void;
                    mute(userId: string): void;
                    unmute(userId: string): void;
                    unmuteAll(): void;
                };
            }>;
            disconnect: () => Promise<void>;
            reconnect: () => Promise<import("../features/chat/common/types/chat-concepts.js").ChatConnection>;
        };
        accessModel: {
            getAccessOp(): import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
            getAccess(): import("../features/auth/types/auth-tokens.js").AccessPayload;
            getValidAccess(): Promise<import("../features/auth/types/auth-tokens.js").AccessPayload>;
            useExistingLogin(): Promise<void>;
            sendLoginLink(email: string): Promise<void>;
            login(loginToken: string): Promise<void>;
            logout(): Promise<void>;
            reauthorize(): Promise<void>;
            readable: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
            }>;
            track: <X>(observer: import("../toolbox/snapstate/parts/types.js").Observer<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
            }, X>, reaction?: import("../toolbox/snapstate/parts/types.js").Reaction<X>) => () => void;
            subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
            }>) => void) => () => void;
        };
        videoModels: {
            dacastModel: {
                state: import("../toolbox/snapstate/parts/types.js").Readable<{
                    accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                    linkedAccountOp: import("../framework/ops.js").Op<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                }>;
                subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                    accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                    linkedAccountOp: import("../framework/ops.js").Op<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                }>) => void) => () => void;
                onLinkChange: (listener: (context: import("../features/videos/types/dacast-link.js").DacastLinkDisplay) => void) => () => void;
                updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                initialize(): Promise<void>;
                readonly linkedAccount: import("../features/videos/types/dacast-link.js").DacastLinkDisplay;
                linkAccount({ apiKey }: {
                    apiKey: string;
                }): Promise<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                unlinkAccount(): Promise<void>;
            };
            contentModel: {
                state: import("../toolbox/snapstate/parts/types.js").Readable<{
                    accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                    catalogOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                    viewsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoView[]>;
                    privilegesOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                    showsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                }>;
                subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                    accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                    catalogOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                    viewsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoView[]>;
                    privilegesOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                    showsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                }>) => void) => () => void;
                updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                onVideoHostingUpdate(): Promise<void>;
                initializeForModerationData(): Promise<void>;
                initializeForVideo(label: string): Promise<void>;
                readonly allowance: {
                    canModerateVideos: boolean;
                    canViewAllVideos: boolean;
                };
                readonly catalog: import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[];
                readonly views: import("../features/videos/types/video-concepts.js").VideoView[];
                readonly privileges: import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[];
                readonly shows: import("../features/videos/types/video-concepts.js").VideoShow[];
                getView(label: string): import("../features/videos/types/video-concepts.js").VideoView;
                getPrivilege(id: string): import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay;
                getShow(label: string): import("../features/videos/types/video-concepts.js").VideoShow;
                setView(options: {
                    label: string;
                    privileges: string[];
                    reference: import("../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
                }): Promise<void>;
                deleteView(label: string): Promise<void>;
            };
            updateAccessOp(accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): void;
        };
        notesModel: {
            initialize: () => Promise<import("../features/notes/types/notes-concepts.js").NotesStats>;
            state: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                statsOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>;
            }>;
            stateSubscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                statsOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>;
            }>) => void) => () => void;
            updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            readonly isLoggedIn: boolean;
            readonly stats: import("../features/notes/types/notes-concepts.js").NotesStats;
            propagateChangeToOtherTabs: import("../toolbox/subbies.js").Subbie<undefined>;
            loadStats: () => Promise<import("../features/notes/types/notes-concepts.js").NotesStats>;
            overwriteStatsOp(op: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>): void;
            createNotesCacheDetails: () => {
                cache: {
                    subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                        old: boolean;
                        pageNumber: number;
                        pageSize: number;
                        notesOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                    }>) => void) => () => void;
                    cacheState: import("../toolbox/snapstate/parts/types.js").Readable<{
                        old: boolean;
                        pageNumber: number;
                        pageSize: number;
                        notesOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                    }>;
                    loginStatusChanged(): Promise<void>;
                    readonly notes: import("../features/notes/types/notes-concepts.js").Notes.Any[];
                    fetchAppropriateNotes: () => Promise<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                    switchTabNew(): Promise<void>;
                    switchTabOld(): Promise<void>;
                    readonly isNextPageAvailable: boolean;
                    readonly isPreviousPageAvailable: boolean;
                    nextPage(): Promise<void>;
                    previousPage(): Promise<void>;
                    markAllNotesOld(): Promise<void>;
                    markSpecificNoteOld(noteId: string): Promise<void>;
                    markSpecificNoteNew(noteId: string): Promise<void>;
                    readonly totalPages: number;
                };
                setup: () => () => void;
            };
        };
        personalModel: {
            track: <X_1>(observer: import("../toolbox/snapstate/parts/types.js").Observer<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                submitDraftOp: import("../framework/ops.js").Op<void>;
            }, X_1>, reaction?: import("../toolbox/snapstate/parts/types.js").Reaction<X_1>) => () => void;
            subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                submitDraftOp: import("../framework/ops.js").Op<void>;
            }>) => void) => () => void;
            readable: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                submitDraftOp: import("../framework/ops.js").Op<void>;
            }>;
            saveProfile(profileDraft: import("../features/auth/aspects/users/routines/personal/types/profile-draft.js").ProfileDraft): Promise<void>;
            updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): void;
        };
        questionsModel: {
            onStateChange: import("../toolbox/pubsub.js").Subscribe<import("../toolbox/pubsub.js").AnyListener>;
            makeBoardModel: (board: string) => {
                getPermissions(): {
                    readonly "read questions": boolean;
                    readonly "post questions": boolean;
                    readonly "moderate questions": boolean;
                    readonly "answer questions": boolean;
                    readonly "like questions": boolean;
                    readonly "report questions": boolean;
                };
                getBoardName(): string;
                getAccess(): import("../features/auth/types/auth-tokens.js").AccessPayload;
                getBoardOp(): import("../framework/ops.js").Op<void>;
                getPostingOp(): import("../framework/ops.js").Op<void>;
                getQuestions(): {
                    answers: import("../features/questions/api/types/questions-and-answers.js").Answer[];
                    questionId: string;
                    authorUserId: string;
                    board: string;
                    content: string;
                    archive: boolean;
                    timePosted: number;
                    liked: boolean;
                    likes: number;
                    reports: number;
                    reported: boolean;
                }[];
                getUser(userId: string): import("../features/auth/aspects/users/types/user.js").User;
                loadQuestions(): Promise<void>;
                postQuestion({ content }: {
                    content: string;
                }): Promise<import("../features/questions/api/types/questions-and-answers.js").Question>;
                postAnswer(questionId: string, answerDraft: import("../features/questions/api/types/answer-draft.js").AnswerDraft): Promise<import("../features/questions/api/types/questions-and-answers.js").Answer>;
                likeQuestion(questionId: string, like: boolean): Promise<void>;
                likeAnswer(questionId: string, answerId: string, like: boolean): Promise<void>;
                reportQuestion(questionId: string, report: boolean): Promise<void>;
                reportAnswer(questionId: string, answerId: string, report: boolean): Promise<void>;
                archiveQuestion(questionId: string, archive: boolean): Promise<void>;
                archiveAnswer(questionId: string, answerId: string, archive: boolean): Promise<void>;
                archiveBoard(): Promise<void>;
            };
            accessChange: (access: import("../features/auth/types/auth-tokens.js").AccessPayload) => void;
        };
        permissionsModel: {
            readable: import("../toolbox/snapstate/parts/types.js").Readable<{
                active: boolean;
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            }>;
            subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                active: boolean;
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            }>) => void) => () => void;
            track: <X_2>(observer: import("../toolbox/snapstate/parts/types.js").Observer<{
                active: boolean;
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            }, X_2>, reaction?: import("../toolbox/snapstate/parts/types.js").Reaction<X_2>) => () => void;
            getAccess: () => import("../features/auth/types/auth-tokens.js").AccessPayload;
            initialize: () => Promise<void>;
            getUserCanCustomizePermissions: () => boolean;
            createRole: ({ label }: {
                label: string;
            }) => Promise<void>;
            deleteRole: ({ roleId: roleIdString }: {
                roleId: string;
            }) => Promise<void>;
            assignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                roleId: string;
                privilegeId: string;
            }) => Promise<void>;
            unassignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                roleId: string;
                privilegeId: string;
            }) => Promise<void>;
            deletePrivilege: ({ privilegeId: privilegeIdString }: {
                privilegeId: string;
            }) => Promise<void>;
            createPrivilege: ({ label }: {
                label: string;
            }) => Promise<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
            updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
        };
        administrativeModel: {
            state: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            }>;
            subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            }>) => void) => () => void;
            getAccess: () => import("../features/auth/types/auth-tokens.js").AccessPayload;
            initialize: () => Promise<void>;
            readonly isAllowed: (privilege: "universal" | "banned" | "view all chats" | "participate in all chats" | "read questions" | "post questions" | "like questions" | "report questions" | "moderate all chats" | "control stripe account" | "manage store" | "give away freebies" | "view all videos" | "moderate videos" | "edit any profile" | "customize permissions" | "answer questions" | "moderate questions" | "view stats" | "administrate user roles") => boolean;
            reauthorize: () => Promise<void>;
            searchUsers: (options: {
                term: string;
            }) => Promise<{
                user: {
                    userId: string;
                    profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                    roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                    stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                };
                roleIds: string[];
            }[]>;
            assignRoleToUser: (options: {
                roleId: string;
                userId: string;
                isPublic: boolean;
                timeframeEnd: number;
                timeframeStart: number;
            }) => Promise<void>;
            revokeRoleFromUser: (options: {
                roleId: string;
                userId: string;
            }) => Promise<void>;
            updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
        };
    };
    modals: import("./frontend/modal/types/modal-system.js").ModalSystem;
    modalsElement: HTMLDivElement;
    remote: import("renraku").ApiRemote<{
        auth: {
            apps: {
                appService: import("renraku").Service<import("../features/auth/types/auth-metas.js").PlatformUserMeta, import("../features/auth/types/auth-metas.js").PlatformUserAuth, {
                    listApps({ ownerUserId: ownerUserIdString }: {
                        ownerUserId: string;
                    }): Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay[]>;
                    registerApp({ appDraft, ownerUserId: ownerUserIdString }: {
                        appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                        ownerUserId: string;
                    }): Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay>;
                }>;
                appEditService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AppOwnerMeta, import("../features/auth/types/auth-metas.js").AppOwnerAuth, {
                    updateApp({ appId: appIdString, appDraft }: {
                        appId: string;
                        appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                    }): Promise<void>;
                    deleteApp({ appId: appIdString }: {
                        appId: string;
                    }): Promise<void>;
                    listAdmins({ appId: appIdString }: {
                        appId: string;
                    }): Promise<import("../features/auth/aspects/apps/types/admin-email-display.js").AdminEmailDisplay[]>;
                    assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }: {
                        appId: string;
                        platformUserId: string;
                    }): Promise<void>;
                    assignAdmin({ appId: appIdString, email }: {
                        appId: string;
                        email: string;
                    }): Promise<void>;
                    revokeAdmin({ appId: appIdString, userId: userIdString }: {
                        appId: string;
                        userId: string;
                    }): Promise<void>;
                }>;
            };
            users: {
                greenService: import("renraku").Service<undefined, import("../features/auth/types/auth-metas.js").GreenAuth, {
                    authorize({ scope, refreshToken, appId: appIdString, }: {
                        scope: import("../features/auth/types/auth-tokens.js").CoreScope;
                        appId: string;
                        refreshToken?: string;
                    }): Promise<string>;
                }>;
                loginService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AnonMeta, import("../features/auth/types/auth-metas.js").LoginAuth, {
                    sendLoginLink(inputs: {
                        email: string;
                    }): Promise<void>;
                    authenticateViaLoginToken({ loginToken }: {
                        loginToken: string;
                    }): Promise<import("../toolbox/concurrent.js").AwaitProps<{
                        accessToken: Promise<string>;
                        refreshToken: Promise<string>;
                    }>>;
                }>;
                userService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AnonMeta, import("../features/auth/types/auth-metas.js").LoginAuth, {
                    getUser({ userId }: {
                        userId: string;
                    }): Promise<{
                        userId: string;
                        profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                        roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                        stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                    }>;
                }>;
                personalService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth, {
                    setProfile({ userId: userIdString, profileDraft }: {
                        userId: string;
                        profileDraft: import("../features/auth/aspects/users/routines/personal/types/profile-draft.js").ProfileDraft;
                    }): Promise<void>;
                }>;
            };
            permissions: {
                permissionsService: import("renraku").Service<import("../features/auth/aspects/permissions/types/permissions-auth-and-metas.js").PermissionsMeta, {
                    engine: {
                        getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                            userIds: string[];
                            onlyGetPublicRoles: boolean;
                        }) => Promise<{
                            userId: string;
                            userHasRoles: {
                                userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                timeframeStart: number;
                                timeframeEnd: number;
                                public: boolean;
                                hard: boolean;
                                time: number;
                            }[];
                        }[]>;
                        getAnonymousPrivileges: () => Promise<string[]>;
                        getPrivilegesForUsers: (userIds: string[]) => Promise<{
                            userId: string;
                            privileges: string[];
                        }[]>;
                        getPublicRolesForUsers: (userIds: string[]) => Promise<{
                            userId: string;
                            publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                        }[]>;
                        getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        getPrivileges: (privilegeIds: string[]) => Promise<{
                            hard: boolean;
                            label: string;
                            time: number;
                            privilegeId: string;
                        }[]>;
                        getAllPrivileges: () => Promise<{
                            hard: boolean;
                            label: string;
                            time: number;
                            privilegeId: string;
                        }[]>;
                        getUserPrivileges: (userId: string) => Promise<string[]>;
                    };
                    access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                    authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                    checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                        universal: string;
                        banned: string;
                        "moderate all chats": string;
                        "control stripe account": string;
                        "manage store": string;
                        "give away freebies": string;
                        "view all videos": string;
                        "moderate videos": string;
                        "edit any profile": string;
                        "customize permissions": string;
                        "answer questions": string;
                        "moderate questions": string;
                        "view stats": string;
                        "administrate user roles": string;
                        "view all chats": string;
                        "participate in all chats": string;
                        "read questions": string;
                        "post questions": string;
                        "like questions": string;
                        "report questions": string;
                    }>;
                }, {
                    fetchPermissions(): Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    createRole({ label }: {
                        label: string;
                    }): Promise<void>;
                    deleteRole({ roleId: roleIdString }: {
                        roleId: string;
                    }): Promise<void>;
                    assignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                        roleId: string;
                        privilegeId: string;
                    }): Promise<void>;
                    unassignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                        roleId: string;
                        privilegeId: string;
                    }): Promise<void>;
                    createPrivilege({ label }: {
                        label: string;
                    }): Promise<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
                    deletePrivilege({ privilegeId: privilegeIdString }: {
                        privilegeId: string;
                    }): Promise<void>;
                }>;
            };
        };
        administrative: {
            roleAssignmentService: import("renraku").Service<import("../features/auth/aspects/permissions/types/permissions-auth-and-metas.js").PermissionsMeta, {
                engine: {
                    getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                        userIds: string[];
                        onlyGetPublicRoles: boolean;
                    }) => Promise<{
                        userId: string;
                        userHasRoles: {
                            userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                            roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                            timeframeStart: number;
                            timeframeEnd: number;
                            public: boolean;
                            hard: boolean;
                            time: number;
                        }[];
                    }[]>;
                    getAnonymousPrivileges: () => Promise<string[]>;
                    getPrivilegesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        privileges: string[];
                    }[]>;
                    getPublicRolesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                    }[]>;
                    getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    getPrivileges: (privilegeIds: string[]) => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getAllPrivileges: () => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getUserPrivileges: (userId: string) => Promise<string[]>;
                };
                access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                    universal: string;
                    banned: string;
                    "moderate all chats": string;
                    "control stripe account": string;
                    "manage store": string;
                    "give away freebies": string;
                    "view all videos": string;
                    "moderate videos": string;
                    "edit any profile": string;
                    "customize permissions": string;
                    "answer questions": string;
                    "moderate questions": string;
                    "view stats": string;
                    "administrate user roles": string;
                    "view all chats": string;
                    "participate in all chats": string;
                    "read questions": string;
                    "post questions": string;
                    "like questions": string;
                    "report questions": string;
                }>;
            }, {
                fetchPermissions(): Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                searchUsers(options: {
                    term: string;
                }): Promise<{
                    user: {
                        userId: string;
                        profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                        roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                        stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                    };
                    roleIds: string[];
                }[]>;
                assignRoleToUser(options: {
                    roleId: string;
                    userId: string;
                    isPublic: boolean;
                    timeframeEnd: number;
                    timeframeStart: number;
                }): Promise<void>;
                revokeRoleFromUser(options: {
                    roleId: string;
                    userId: string;
                }): Promise<void>;
            }>;
        };
        questions: {
            questionsReadingService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AnonMeta, import("../features/auth/types/auth-metas.js").LoginAuth & {
                questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
            }, {
                fetchQuestions({ board }: {
                    board: string;
                }): Promise<{
                    users: {
                        userId: string;
                        profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                        roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                        stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                    }[];
                    questions: {
                        answers: import("../features/questions/api/types/questions-and-answers.js").Answer[];
                        questionId: string;
                        authorUserId: string;
                        board: string;
                        content: string;
                        archive: boolean;
                        timePosted: number;
                        liked: boolean;
                        likes: number;
                        reports: number;
                        reported: boolean;
                    }[];
                }>;
            }>;
            questionsPostingService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth & {
                questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
            }, {
                postQuestion(inputs: {
                    questionDraft: import("../features/questions/api/types/question-draft.js").QuestionDraft;
                }): Promise<import("../features/questions/api/types/questions-and-answers.js").Question>;
                archiveQuestion(inputs: {
                    archive: boolean;
                    questionId: string;
                }): Promise<void>;
                likeQuestion(inputs: {
                    like: boolean;
                    questionId: string;
                }): Promise<void>;
                reportQuestion(inputs: {
                    report: boolean;
                    questionId: string;
                }): Promise<void>;
            }>;
            questionsAnsweringService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth & {
                questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
            }, {
                postAnswer(inputs: {
                    questionId: string;
                    answerDraft: import("../features/questions/api/types/answer-draft.js").AnswerDraft;
                }): Promise<import("../features/questions/api/types/questions-and-answers.js").Answer>;
                archiveAnswer(inputs: {
                    archive: boolean;
                    answerId: string;
                }): Promise<void>;
                likeAnswer(inputs: {
                    like: boolean;
                    answerId: string;
                }): Promise<void>;
                reportAnswer(inputs: {
                    report: boolean;
                    answerId: string;
                }): Promise<void>;
            }>;
            questionsModerationService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth & {
                questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
            }, {
                archiveBoard({ board }: {
                    board: string;
                }): Promise<void>;
                fetchReportedQuestions(): Promise<void>;
            }>;
        };
        example: {
            exampleService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, {
                exampleTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                }, import("../features/example/api/types/example-tables.js").ExampleTables>;
                access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                    universal: string;
                    banned: string;
                    "moderate all chats": string;
                    "control stripe account": string;
                    "manage store": string;
                    "give away freebies": string;
                    "view all videos": string;
                    "moderate videos": string;
                    "edit any profile": string;
                    "customize permissions": string;
                    "answer questions": string;
                    "moderate questions": string;
                    "view stats": string;
                    "administrate user roles": string;
                    "view all chats": string;
                    "participate in all chats": string;
                    "read questions": string;
                    "post questions": string;
                    "like questions": string;
                    "report questions": string;
                }>;
            }, {
                exampleFunction({ something }: {
                    something: string;
                }): Promise<void>;
            }>;
        };
        videos: {
            dacastService: import("renraku").Service<import("../features/videos/types/video-auth.js").VideoMeta, {
                checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                    "view all videos": string;
                    "moderate videos": string;
                }>;
                engine: {
                    getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                        userIds: string[];
                        onlyGetPublicRoles: boolean;
                    }) => Promise<{
                        userId: string;
                        userHasRoles: {
                            userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                            roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                            timeframeStart: number;
                            timeframeEnd: number;
                            public: boolean;
                            hard: boolean;
                            time: number;
                        }[];
                    }[]>;
                    getAnonymousPrivileges: () => Promise<string[]>;
                    getPrivilegesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        privileges: string[];
                    }[]>;
                    getPublicRolesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                    }[]>;
                    getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    getPrivileges: (privilegeIds: string[]) => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getAllPrivileges: () => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getUserPrivileges: (userId: string) => Promise<string[]>;
                };
                videoTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                }, import("../features/videos/types/video-tables.js").VideoTables>;
                access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                authTables: import("../features/auth/types/auth-tables.js").AuthTables;
            }, {
                getLink(): Promise<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                setLink(inputs: {
                    apiKey: string;
                }): Promise<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                clearLink(): Promise<void>;
            }>;
            contentService: import("renraku").Service<import("../features/videos/types/video-auth.js").VideoMeta, {
                engine: {
                    getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                        userIds: string[];
                        onlyGetPublicRoles: boolean;
                    }) => Promise<{
                        userId: string;
                        userHasRoles: {
                            userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                            roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                            timeframeStart: number;
                            timeframeEnd: number;
                            public: boolean;
                            hard: boolean;
                            time: number;
                        }[];
                    }[]>;
                    getAnonymousPrivileges: () => Promise<string[]>;
                    getPrivilegesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        privileges: string[];
                    }[]>;
                    getPublicRolesForUsers: (userIds: string[]) => Promise<{
                        userId: string;
                        publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                    }[]>;
                    getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    getPrivileges: (privilegeIds: string[]) => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getAllPrivileges: () => Promise<{
                        hard: boolean;
                        label: string;
                        time: number;
                        privilegeId: string;
                    }[]>;
                    getUserPrivileges: (userId: string) => Promise<string[]>;
                };
                checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                    "view all videos": string;
                    "moderate videos": string;
                }>;
                videoTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                }, import("../features/videos/types/video-tables.js").VideoTables>;
                access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                authTables: import("../features/auth/types/auth-tables.js").AuthTables;
            }, {
                fetchModerationData(): Promise<import("../features/videos/types/video-concepts.js").VideoModerationData>;
                writeView({ label, privileges, reference, }: {
                    label: string;
                    privileges: string[];
                    reference: import("../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
                }): Promise<void>;
                deleteView({ label }: {
                    label: string;
                }): Promise<void>;
                getShows({ labels }: {
                    labels: string[];
                }): Promise<import("../features/videos/types/video-concepts.js").VideoShow[]>;
            }>;
        };
        notes: {
            notesService: import("renraku").Service<import("../features/notes/api/types/notes-auth.js").NotesMeta, {
                notesTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                    "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                }, import("../features/notes/api/tables/notes-tables.js").NotesTables>;
                access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                    universal: string;
                    banned: string;
                    "moderate all chats": string;
                    "control stripe account": string;
                    "manage store": string;
                    "give away freebies": string;
                    "view all videos": string;
                    "moderate videos": string;
                    "edit any profile": string;
                    "customize permissions": string;
                    "answer questions": string;
                    "moderate questions": string;
                    "view stats": string;
                    "administrate user roles": string;
                    "view all chats": string;
                    "participate in all chats": string;
                    "read questions": string;
                    "post questions": string;
                    "like questions": string;
                    "report questions": string;
                }>;
            }, {
                getNotesStats(): Promise<import("../features/notes/types/notes-concepts.js").NotesStats>;
                getNewNotes(pagination: import("../features/notes/types/notes-concepts.js").Pagination): Promise<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                getOldNotes(pagination: import("../features/notes/types/notes-concepts.js").Pagination): Promise<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                markAllNotesOld(): Promise<void>;
                markNotesNewOrOld(input: {
                    old: boolean;
                    noteIds: string[];
                }): Promise<void>;
            }>;
        };
    }>;
    storage: import("../toolbox/flex-storage/types/flex-storage.js").FlexStorage;
    authMediator: {
        subscribeToAccessChange: import("../toolbox/pubsub.js").Subscribe<import("../features/auth/mediator/types/access-event-listener.js").AccessEventListener>;
        subscribeToTokenChange: import("../toolbox/pubsub.js").Subscribe<() => void>;
        initialize(): Promise<import("../features/auth/types/auth-tokens.js").AccessPayload>;
        getValidAccess(): Promise<import("../features/auth/types/auth-tokens.js").AccessPayload>;
        getValidAccessToken(): Promise<string>;
        login(tokens: import("../features/auth/types/auth-tokens.js").AuthTokens): Promise<import("../features/auth/types/auth-tokens.js").AccessPayload>;
        logout(): Promise<import("../features/auth/types/auth-tokens.js").AccessPayload>;
        reauthorize(): Promise<import("../features/auth/types/auth-tokens.js").AccessPayload>;
    };
    backend: {
        rando: {
            random: () => number;
            compare: (a: string, b: string) => boolean;
            randomId: () => import("../toolbox/damnedb/damn-id.js").DamnId;
            randomBuffer: (bytes: number) => ArrayBuffer;
            randomSample: <T_4>(palette: T_4[]) => T_4;
            randomSequence: (length: number, palette: string[]) => string;
        };
        api: {
            auth: {
                apps: {
                    appService: import("renraku").Service<import("../features/auth/types/auth-metas.js").PlatformUserMeta, import("../features/auth/types/auth-metas.js").PlatformUserAuth, {
                        listApps({ ownerUserId: ownerUserIdString }: {
                            ownerUserId: string;
                        }): Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay[]>;
                        registerApp({ appDraft, ownerUserId: ownerUserIdString }: {
                            appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                            ownerUserId: string;
                        }): Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay>;
                    }>;
                    appEditService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AppOwnerMeta, import("../features/auth/types/auth-metas.js").AppOwnerAuth, {
                        updateApp({ appId: appIdString, appDraft }: {
                            appId: string;
                            appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                        }): Promise<void>;
                        deleteApp({ appId: appIdString }: {
                            appId: string;
                        }): Promise<void>;
                        listAdmins({ appId: appIdString }: {
                            appId: string;
                        }): Promise<import("../features/auth/aspects/apps/types/admin-email-display.js").AdminEmailDisplay[]>;
                        assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }: {
                            appId: string;
                            platformUserId: string;
                        }): Promise<void>;
                        assignAdmin({ appId: appIdString, email }: {
                            appId: string;
                            email: string;
                        }): Promise<void>;
                        revokeAdmin({ appId: appIdString, userId: userIdString }: {
                            appId: string;
                            userId: string;
                        }): Promise<void>;
                    }>;
                };
                users: {
                    greenService: import("renraku").Service<undefined, import("../features/auth/types/auth-metas.js").GreenAuth, {
                        authorize({ scope, refreshToken, appId: appIdString, }: {
                            scope: import("../features/auth/types/auth-tokens.js").CoreScope;
                            appId: string;
                            refreshToken?: string;
                        }): Promise<string>;
                    }>;
                    loginService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AnonMeta, import("../features/auth/types/auth-metas.js").LoginAuth, {
                        sendLoginLink(inputs: {
                            email: string;
                        }): Promise<void>;
                        authenticateViaLoginToken({ loginToken }: {
                            loginToken: string;
                        }): Promise<import("../toolbox/concurrent.js").AwaitProps<{
                            accessToken: Promise<string>;
                            refreshToken: Promise<string>;
                        }>>;
                    }>;
                    userService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AnonMeta, import("../features/auth/types/auth-metas.js").LoginAuth, {
                        getUser({ userId }: {
                            userId: string;
                        }): Promise<{
                            userId: string;
                            profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                            roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                            stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                        }>;
                    }>;
                    personalService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth, {
                        setProfile({ userId: userIdString, profileDraft }: {
                            userId: string;
                            profileDraft: import("../features/auth/aspects/users/routines/personal/types/profile-draft.js").ProfileDraft;
                        }): Promise<void>;
                    }>;
                };
                permissions: {
                    permissionsService: import("renraku").Service<import("../features/auth/aspects/permissions/types/permissions-auth-and-metas.js").PermissionsMeta, {
                        engine: {
                            getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                                userIds: string[];
                                onlyGetPublicRoles: boolean;
                            }) => Promise<{
                                userId: string;
                                userHasRoles: {
                                    userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                    roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                    timeframeStart: number;
                                    timeframeEnd: number;
                                    public: boolean;
                                    hard: boolean;
                                    time: number;
                                }[];
                            }[]>;
                            getAnonymousPrivileges: () => Promise<string[]>;
                            getPrivilegesForUsers: (userIds: string[]) => Promise<{
                                userId: string;
                                privileges: string[];
                            }[]>;
                            getPublicRolesForUsers: (userIds: string[]) => Promise<{
                                userId: string;
                                publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                            }[]>;
                            getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                            getPrivileges: (privilegeIds: string[]) => Promise<{
                                hard: boolean;
                                label: string;
                                time: number;
                                privilegeId: string;
                            }[]>;
                            getAllPrivileges: () => Promise<{
                                hard: boolean;
                                label: string;
                                time: number;
                                privilegeId: string;
                            }[]>;
                            getUserPrivileges: (userId: string) => Promise<string[]>;
                        };
                        access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                        authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                        checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                            universal: string;
                            banned: string;
                            "moderate all chats": string;
                            "control stripe account": string;
                            "manage store": string;
                            "give away freebies": string;
                            "view all videos": string;
                            "moderate videos": string;
                            "edit any profile": string;
                            "customize permissions": string;
                            "answer questions": string;
                            "moderate questions": string;
                            "view stats": string;
                            "administrate user roles": string;
                            "view all chats": string;
                            "participate in all chats": string;
                            "read questions": string;
                            "post questions": string;
                            "like questions": string;
                            "report questions": string;
                        }>;
                    }, {
                        fetchPermissions(): Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        createRole({ label }: {
                            label: string;
                        }): Promise<void>;
                        deleteRole({ roleId: roleIdString }: {
                            roleId: string;
                        }): Promise<void>;
                        assignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                            roleId: string;
                            privilegeId: string;
                        }): Promise<void>;
                        unassignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                            roleId: string;
                            privilegeId: string;
                        }): Promise<void>;
                        createPrivilege({ label }: {
                            label: string;
                        }): Promise<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
                        deletePrivilege({ privilegeId: privilegeIdString }: {
                            privilegeId: string;
                        }): Promise<void>;
                    }>;
                };
            };
            administrative: {
                roleAssignmentService: import("renraku").Service<import("../features/auth/aspects/permissions/types/permissions-auth-and-metas.js").PermissionsMeta, {
                    engine: {
                        getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                            userIds: string[];
                            onlyGetPublicRoles: boolean;
                        }) => Promise<{
                            userId: string;
                            userHasRoles: {
                                userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                timeframeStart: number;
                                timeframeEnd: number;
                                public: boolean;
                                hard: boolean;
                                time: number;
                            }[];
                        }[]>;
                        getAnonymousPrivileges: () => Promise<string[]>;
                        getPrivilegesForUsers: (userIds: string[]) => Promise<{
                            userId: string;
                            privileges: string[];
                        }[]>;
                        getPublicRolesForUsers: (userIds: string[]) => Promise<{
                            userId: string;
                            publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                        }[]>;
                        getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        getPrivileges: (privilegeIds: string[]) => Promise<{
                            hard: boolean;
                            label: string;
                            time: number;
                            privilegeId: string;
                        }[]>;
                        getAllPrivileges: () => Promise<{
                            hard: boolean;
                            label: string;
                            time: number;
                            privilegeId: string;
                        }[]>;
                        getUserPrivileges: (userId: string) => Promise<string[]>;
                    };
                    access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                    authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                    checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                        universal: string;
                        banned: string;
                        "moderate all chats": string;
                        "control stripe account": string;
                        "manage store": string;
                        "give away freebies": string;
                        "view all videos": string;
                        "moderate videos": string;
                        "edit any profile": string;
                        "customize permissions": string;
                        "answer questions": string;
                        "moderate questions": string;
                        "view stats": string;
                        "administrate user roles": string;
                        "view all chats": string;
                        "participate in all chats": string;
                        "read questions": string;
                        "post questions": string;
                        "like questions": string;
                        "report questions": string;
                    }>;
                }, {
                    fetchPermissions(): Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                    searchUsers(options: {
                        term: string;
                    }): Promise<{
                        user: {
                            userId: string;
                            profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                            roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                            stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                        };
                        roleIds: string[];
                    }[]>;
                    assignRoleToUser(options: {
                        roleId: string;
                        userId: string;
                        isPublic: boolean;
                        timeframeEnd: number;
                        timeframeStart: number;
                    }): Promise<void>;
                    revokeRoleFromUser(options: {
                        roleId: string;
                        userId: string;
                    }): Promise<void>;
                }>;
            };
            questions: {
                questionsReadingService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AnonMeta, import("../features/auth/types/auth-metas.js").LoginAuth & {
                    questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                        "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                    }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                }, {
                    fetchQuestions({ board }: {
                        board: string;
                    }): Promise<{
                        users: {
                            userId: string;
                            profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                            roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                            stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                        }[];
                        questions: {
                            answers: import("../features/questions/api/types/questions-and-answers.js").Answer[];
                            questionId: string;
                            authorUserId: string;
                            board: string;
                            content: string;
                            archive: boolean;
                            timePosted: number;
                            liked: boolean;
                            likes: number;
                            reports: number;
                            reported: boolean;
                        }[];
                    }>;
                }>;
                questionsPostingService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth & {
                    questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                        "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                    }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                }, {
                    postQuestion(inputs: {
                        questionDraft: import("../features/questions/api/types/question-draft.js").QuestionDraft;
                    }): Promise<import("../features/questions/api/types/questions-and-answers.js").Question>;
                    archiveQuestion(inputs: {
                        archive: boolean;
                        questionId: string;
                    }): Promise<void>;
                    likeQuestion(inputs: {
                        like: boolean;
                        questionId: string;
                    }): Promise<void>;
                    reportQuestion(inputs: {
                        report: boolean;
                        questionId: string;
                    }): Promise<void>;
                }>;
                questionsAnsweringService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth & {
                    questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                        "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                    }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                }, {
                    postAnswer(inputs: {
                        questionId: string;
                        answerDraft: import("../features/questions/api/types/answer-draft.js").AnswerDraft;
                    }): Promise<import("../features/questions/api/types/questions-and-answers.js").Answer>;
                    archiveAnswer(inputs: {
                        archive: boolean;
                        answerId: string;
                    }): Promise<void>;
                    likeAnswer(inputs: {
                        like: boolean;
                        answerId: string;
                    }): Promise<void>;
                    reportAnswer(inputs: {
                        report: boolean;
                        answerId: string;
                    }): Promise<void>;
                }>;
                questionsModerationService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth & {
                    questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                        "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                    }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                }, {
                    archiveBoard({ board }: {
                        board: string;
                    }): Promise<void>;
                    fetchReportedQuestions(): Promise<void>;
                }>;
            };
            example: {
                exampleService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, {
                    exampleTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                        "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                    }, import("../features/example/api/types/example-tables.js").ExampleTables>;
                    access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                    authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                    checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                        universal: string;
                        banned: string;
                        "moderate all chats": string;
                        "control stripe account": string;
                        "manage store": string;
                        "give away freebies": string;
                        "view all videos": string;
                        "moderate videos": string;
                        "edit any profile": string;
                        "customize permissions": string;
                        "answer questions": string;
                        "moderate questions": string;
                        "view stats": string;
                        "administrate user roles": string;
                        "view all chats": string;
                        "participate in all chats": string;
                        "read questions": string;
                        "post questions": string;
                        "like questions": string;
                        "report questions": string;
                    }>;
                }, {
                    exampleFunction({ something }: {
                        something: string;
                    }): Promise<void>;
                }>;
            };
            videos: {
                dacastService: import("renraku").Service<import("../features/videos/types/video-auth.js").VideoMeta, {
                    checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                        "view all videos": string;
                        "moderate videos": string;
                    }>;
                    engine: {
                        getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                            userIds: string[];
                            onlyGetPublicRoles: boolean;
                        }) => Promise<{
                            userId: string;
                            userHasRoles: {
                                userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                timeframeStart: number;
                                timeframeEnd: number;
                                public: boolean;
                                hard: boolean;
                                time: number;
                            }[];
                        }[]>;
                        getAnonymousPrivileges: () => Promise<string[]>;
                        getPrivilegesForUsers: (userIds: string[]) => Promise<{
                            userId: string;
                            privileges: string[];
                        }[]>;
                        getPublicRolesForUsers: (userIds: string[]) => Promise<{
                            userId: string;
                            publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                        }[]>;
                        getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        getPrivileges: (privilegeIds: string[]) => Promise<{
                            hard: boolean;
                            label: string;
                            time: number;
                            privilegeId: string;
                        }[]>;
                        getAllPrivileges: () => Promise<{
                            hard: boolean;
                            label: string;
                            time: number;
                            privilegeId: string;
                        }[]>;
                        getUserPrivileges: (userId: string) => Promise<string[]>;
                    };
                    videoTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                        "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                    }, import("../features/videos/types/video-tables.js").VideoTables>;
                    access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                    authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                }, {
                    getLink(): Promise<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                    setLink(inputs: {
                        apiKey: string;
                    }): Promise<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                    clearLink(): Promise<void>;
                }>;
                contentService: import("renraku").Service<import("../features/videos/types/video-auth.js").VideoMeta, {
                    engine: {
                        getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                            userIds: string[];
                            onlyGetPublicRoles: boolean;
                        }) => Promise<{
                            userId: string;
                            userHasRoles: {
                                userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                timeframeStart: number;
                                timeframeEnd: number;
                                public: boolean;
                                hard: boolean;
                                time: number;
                            }[];
                        }[]>;
                        getAnonymousPrivileges: () => Promise<string[]>;
                        getPrivilegesForUsers: (userIds: string[]) => Promise<{
                            userId: string;
                            privileges: string[];
                        }[]>;
                        getPublicRolesForUsers: (userIds: string[]) => Promise<{
                            userId: string;
                            publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                        }[]>;
                        getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        getPrivileges: (privilegeIds: string[]) => Promise<{
                            hard: boolean;
                            label: string;
                            time: number;
                            privilegeId: string;
                        }[]>;
                        getAllPrivileges: () => Promise<{
                            hard: boolean;
                            label: string;
                            time: number;
                            privilegeId: string;
                        }[]>;
                        getUserPrivileges: (userId: string) => Promise<string[]>;
                    };
                    checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                        "view all videos": string;
                        "moderate videos": string;
                    }>;
                    videoTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                        "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                    }, import("../features/videos/types/video-tables.js").VideoTables>;
                    access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                    authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                }, {
                    fetchModerationData(): Promise<import("../features/videos/types/video-concepts.js").VideoModerationData>;
                    writeView({ label, privileges, reference, }: {
                        label: string;
                        privileges: string[];
                        reference: import("../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
                    }): Promise<void>;
                    deleteView({ label }: {
                        label: string;
                    }): Promise<void>;
                    getShows({ labels }: {
                        labels: string[];
                    }): Promise<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                }>;
            };
            notes: {
                notesService: import("renraku").Service<import("../features/notes/api/types/notes-auth.js").NotesMeta, {
                    notesTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                        "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                    }, import("../features/notes/api/tables/notes-tables.js").NotesTables>;
                    access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                    authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                    checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                        universal: string;
                        banned: string;
                        "moderate all chats": string;
                        "control stripe account": string;
                        "manage store": string;
                        "give away freebies": string;
                        "view all videos": string;
                        "moderate videos": string;
                        "edit any profile": string;
                        "customize permissions": string;
                        "answer questions": string;
                        "moderate questions": string;
                        "view stats": string;
                        "administrate user roles": string;
                        "view all chats": string;
                        "participate in all chats": string;
                        "read questions": string;
                        "post questions": string;
                        "like questions": string;
                        "report questions": string;
                    }>;
                }, {
                    getNotesStats(): Promise<import("../features/notes/types/notes-concepts.js").NotesStats>;
                    getNewNotes(pagination: import("../features/notes/types/notes-concepts.js").Pagination): Promise<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                    getOldNotes(pagination: import("../features/notes/types/notes-concepts.js").Pagination): Promise<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                    markAllNotesOld(): Promise<void>;
                    markNotesNewOrOld(input: {
                        old: boolean;
                        noteIds: string[];
                    }): Promise<void>;
                }>;
            };
        };
        config: import("./backend/types/secret-config.js").SecretConfig;
        emails: {
            sendEmail: import("../features/auth/types/emails/send-email.js").SendEmail;
            enableEmails: () => void;
            disableEmails: () => void;
            sendLoginEmail: (details: import("../features/auth/aspects/users/types/emails/login-email-details.js").LoginEmailDetails) => Promise<void>;
            recallLatestLoginEmail: () => import("../features/auth/aspects/users/types/emails/login-email-details.js").LoginEmailDetails;
        };
        database: import("./backend/types/database.js").DatabaseFinal;
        stripeLiaison: {
            accounts: {
                create(params: import("stripe").Stripe.AccountCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Account>>;
                retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Account>>;
                createLoginLink(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.LoginLink>>;
            };
            accountLinks: {
                create(params: import("stripe").Stripe.AccountLinkCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.AccountLink>>;
            };
            account(stripeAccount: string): {
                customers: {
                    create(params: import("stripe").Stripe.CustomerCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Customer>>;
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Customer | import("stripe").Stripe.DeletedCustomer>>;
                    update(id: string, params: import("stripe").Stripe.CustomerUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Customer>>;
                };
                products: {
                    create(params: import("stripe").Stripe.ProductCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Product>>;
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Product>>;
                    update(id: string, params: import("stripe").Stripe.ProductUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Product>>;
                };
                prices: {
                    create(params: import("stripe").Stripe.PriceCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Price>>;
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Price>>;
                    update(id: string, params: import("stripe").Stripe.PriceUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Price>>;
                };
                paymentMethods: {
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.PaymentMethod>>;
                };
                setupIntents: {
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.SetupIntent>>;
                };
                subscriptions: {
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Subscription>>;
                    update(id: string, params: import("stripe").Stripe.SubscriptionUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Subscription>>;
                };
                checkout: {
                    sessions: {
                        create(params: import("stripe").Stripe.Checkout.SessionCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Checkout.Session>>;
                    };
                };
            };
        };
        mockStripeOperations: {
            linkStripeAccount(stripeAccountId: string): Promise<void>;
            linkStripeAccountThatIsIncomplete(stripeAccountId: string): Promise<void>;
        };
        platformAppId: string;
        prepareNotesDepositBox: (appId: import("../toolbox/damnedb/damn-id.js").DamnId) => {
            sendNotes: (drafts: import("../features/notes/types/notes-concepts.js").DraftForNote<import("../features/notes/types/notes-concepts.js").Notes.Any>[]) => Promise<{
                noteId: string;
            }[]>;
            sendNote: (draft: import("../features/notes/types/notes-concepts.js").DraftForNote<import("../features/notes/types/notes-concepts.js").Notes.Any>) => Promise<{
                noteId: string;
            }>;
        };
        mockBrowser: () => Promise<{
            mockAppWindow: ({ appId }: {
                appId: string;
            }) => Promise<{
                models: {
                    exampleModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }>) => void) => () => void;
                        updateAccessOp: (op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>) => void;
                    };
                    appsModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            active: boolean;
                            appRecords: import("../framework/ops.js").Op<import("../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
                            addingNewApp: import("../framework/ops.js").Op<null>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            active: boolean;
                            appRecords: import("../framework/ops.js").Op<import("../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
                            addingNewApp: import("../framework/ops.js").Op<null>;
                        }>) => void) => () => void;
                        appEditService: {
                            updateApp({ appId: appIdString, appDraft }: {
                                appId: string;
                                appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                            }): Promise<void>;
                            deleteApp({ appId: appIdString }: {
                                appId: string;
                            }): Promise<void>;
                            listAdmins({ appId: appIdString }: {
                                appId: string;
                            }): Promise<import("../features/auth/aspects/apps/types/admin-email-display.js").AdminEmailDisplay[]>;
                            assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }: {
                                appId: string;
                                platformUserId: string;
                            }): Promise<void>;
                            assignAdmin({ appId: appIdString, email }: {
                                appId: string;
                                email: string;
                            }): Promise<void>;
                            revokeAdmin({ appId: appIdString, userId: userIdString }: {
                                appId: string;
                                userId: string;
                            }): Promise<void>;
                        };
                        getApp(appId: string): import("../features/auth/aspects/apps/types/app-display.js").AppDisplay;
                        loadApps: () => Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay[]>;
                        deleteApp: (appId: string) => Promise<void>;
                        updateApp: (appId: string, appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<void>;
                        registerApp: (appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay>;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                    };
                    chatModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            connectionOp: import("../framework/ops.js").Op<import("../features/chat/common/types/chat-concepts.js").ChatConnection>;
                            cache: {
                                mutedUserIds: string[];
                                rooms: {
                                    [key: string]: {
                                        status: import("../features/chat/common/types/chat-concepts.js").ChatStatus;
                                        posts: import("../features/chat/common/types/chat-concepts.js").ChatPost[];
                                    };
                                };
                            };
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            connectionOp: import("../framework/ops.js").Op<import("../features/chat/common/types/chat-concepts.js").ChatConnection>;
                            cache: {
                                mutedUserIds: string[];
                                rooms: {
                                    [key: string]: {
                                        status: import("../features/chat/common/types/chat-concepts.js").ChatStatus;
                                        posts: import("../features/chat/common/types/chat-concepts.js").ChatPost[];
                                    };
                                };
                            };
                        }>) => void) => () => void;
                        subscribeToChange: (...listeners: (() => void | Promise<void>)[]) => () => void;
                        readonly allowance: {
                            moderateAllChats: boolean;
                            participateInAllChats: boolean;
                            viewAllChats: boolean;
                            banned: boolean;
                        };
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                        session: (label: string) => Promise<{
                            dispose: () => void;
                            room: {
                                readonly posts: import("../features/chat/common/types/chat-concepts.js").ChatPost[];
                                readonly status: import("../features/chat/common/types/chat-concepts.js").ChatStatus;
                                readonly muted: string[];
                                readonly weAreMuted: boolean;
                                readonly weAreBanned: boolean;
                                setRoomStatus(status: import("../features/chat/common/types/chat-concepts.js").ChatStatus): void;
                                post(draft: import("../features/chat/common/types/chat-concepts.js").ChatDraft): void;
                                remove(postIds: string[]): void;
                                clear(): void;
                                mute(userId: string): void;
                                unmute(userId: string): void;
                                unmuteAll(): void;
                            };
                        }>;
                        disconnect: () => Promise<void>;
                        reconnect: () => Promise<import("../features/chat/common/types/chat-concepts.js").ChatConnection>;
                    };
                    accessModel: {
                        getAccessOp(): import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        getAccess(): import("../features/auth/types/auth-tokens.js").AccessPayload;
                        getValidAccess(): Promise<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        useExistingLogin(): Promise<void>;
                        sendLoginLink(email: string): Promise<void>;
                        login(loginToken: string): Promise<void>;
                        logout(): Promise<void>;
                        reauthorize(): Promise<void>;
                        readable: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }>;
                        track: <X>(observer: import("../toolbox/snapstate/parts/types.js").Observer<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }, X>, reaction?: import("../toolbox/snapstate/parts/types.js").Reaction<X>) => () => void;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                        }>) => void) => () => void;
                    };
                    videoModels: {
                        dacastModel: {
                            state: import("../toolbox/snapstate/parts/types.js").Readable<{
                                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                                linkedAccountOp: import("../framework/ops.js").Op<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                            }>;
                            subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                                linkedAccountOp: import("../framework/ops.js").Op<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                            }>) => void) => () => void;
                            onLinkChange: (listener: (context: import("../features/videos/types/dacast-link.js").DacastLinkDisplay) => void) => () => void;
                            updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                            initialize(): Promise<void>;
                            readonly linkedAccount: import("../features/videos/types/dacast-link.js").DacastLinkDisplay;
                            linkAccount({ apiKey }: {
                                apiKey: string;
                            }): Promise<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                            unlinkAccount(): Promise<void>;
                        };
                        contentModel: {
                            state: import("../toolbox/snapstate/parts/types.js").Readable<{
                                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                                catalogOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                                viewsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoView[]>;
                                privilegesOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                                showsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                            }>;
                            subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                                accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                                catalogOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                                viewsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoView[]>;
                                privilegesOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                                showsOp: import("../framework/ops.js").Op<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                            }>) => void) => () => void;
                            updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                            onVideoHostingUpdate(): Promise<void>;
                            initializeForModerationData(): Promise<void>;
                            initializeForVideo(label: string): Promise<void>;
                            readonly allowance: {
                                canModerateVideos: boolean;
                                canViewAllVideos: boolean;
                            };
                            readonly catalog: import("../features/videos/types/video-concepts.js").VideoHosting.DacastContent[];
                            readonly views: import("../features/videos/types/video-concepts.js").VideoView[];
                            readonly privileges: import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[];
                            readonly shows: import("../features/videos/types/video-concepts.js").VideoShow[];
                            getView(label: string): import("../features/videos/types/video-concepts.js").VideoView;
                            getPrivilege(id: string): import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay;
                            getShow(label: string): import("../features/videos/types/video-concepts.js").VideoShow;
                            setView(options: {
                                label: string;
                                privileges: string[];
                                reference: import("../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
                            }): Promise<void>;
                            deleteView(label: string): Promise<void>;
                        };
                        updateAccessOp(accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): void;
                    };
                    notesModel: {
                        initialize: () => Promise<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            statsOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        }>;
                        stateSubscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            statsOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        }>) => void) => () => void;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                        readonly isLoggedIn: boolean;
                        readonly stats: import("../features/notes/types/notes-concepts.js").NotesStats;
                        propagateChangeToOtherTabs: import("../toolbox/subbies.js").Subbie<undefined>;
                        loadStats: () => Promise<import("../features/notes/types/notes-concepts.js").NotesStats>;
                        overwriteStatsOp(op: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").NotesStats>): void;
                        createNotesCacheDetails: () => {
                            cache: {
                                subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                                    old: boolean;
                                    pageNumber: number;
                                    pageSize: number;
                                    notesOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                                }>) => void) => () => void;
                                cacheState: import("../toolbox/snapstate/parts/types.js").Readable<{
                                    old: boolean;
                                    pageNumber: number;
                                    pageSize: number;
                                    notesOp: import("../framework/ops.js").Op<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                                }>;
                                loginStatusChanged(): Promise<void>;
                                readonly notes: import("../features/notes/types/notes-concepts.js").Notes.Any[];
                                fetchAppropriateNotes: () => Promise<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                                switchTabNew(): Promise<void>;
                                switchTabOld(): Promise<void>;
                                readonly isNextPageAvailable: boolean;
                                readonly isPreviousPageAvailable: boolean;
                                nextPage(): Promise<void>;
                                previousPage(): Promise<void>;
                                markAllNotesOld(): Promise<void>;
                                markSpecificNoteOld(noteId: string): Promise<void>;
                                markSpecificNoteNew(noteId: string): Promise<void>;
                                readonly totalPages: number;
                            };
                            setup: () => () => void;
                        };
                    };
                    personalModel: {
                        track: <X_1>(observer: import("../toolbox/snapstate/parts/types.js").Observer<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            submitDraftOp: import("../framework/ops.js").Op<void>;
                        }, X_1>, reaction?: import("../toolbox/snapstate/parts/types.js").Reaction<X_1>) => () => void;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            submitDraftOp: import("../framework/ops.js").Op<void>;
                        }>) => void) => () => void;
                        readable: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            submitDraftOp: import("../framework/ops.js").Op<void>;
                        }>;
                        saveProfile(profileDraft: import("../features/auth/aspects/users/routines/personal/types/profile-draft.js").ProfileDraft): Promise<void>;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): void;
                    };
                    questionsModel: {
                        onStateChange: import("../toolbox/pubsub.js").Subscribe<import("../toolbox/pubsub.js").AnyListener>;
                        makeBoardModel: (board: string) => {
                            getPermissions(): {
                                readonly "read questions": boolean;
                                readonly "post questions": boolean;
                                readonly "moderate questions": boolean;
                                readonly "answer questions": boolean;
                                readonly "like questions": boolean;
                                readonly "report questions": boolean;
                            };
                            getBoardName(): string;
                            getAccess(): import("../features/auth/types/auth-tokens.js").AccessPayload;
                            getBoardOp(): import("../framework/ops.js").Op<void>;
                            getPostingOp(): import("../framework/ops.js").Op<void>;
                            getQuestions(): {
                                answers: import("../features/questions/api/types/questions-and-answers.js").Answer[];
                                questionId: string;
                                authorUserId: string;
                                board: string;
                                content: string;
                                archive: boolean;
                                timePosted: number;
                                liked: boolean;
                                likes: number;
                                reports: number;
                                reported: boolean;
                            }[];
                            getUser(userId: string): import("../features/auth/aspects/users/types/user.js").User;
                            loadQuestions(): Promise<void>;
                            postQuestion({ content }: {
                                content: string;
                            }): Promise<import("../features/questions/api/types/questions-and-answers.js").Question>;
                            postAnswer(questionId: string, answerDraft: import("../features/questions/api/types/answer-draft.js").AnswerDraft): Promise<import("../features/questions/api/types/questions-and-answers.js").Answer>;
                            likeQuestion(questionId: string, like: boolean): Promise<void>;
                            likeAnswer(questionId: string, answerId: string, like: boolean): Promise<void>;
                            reportQuestion(questionId: string, report: boolean): Promise<void>;
                            reportAnswer(questionId: string, answerId: string, report: boolean): Promise<void>;
                            archiveQuestion(questionId: string, archive: boolean): Promise<void>;
                            archiveAnswer(questionId: string, answerId: string, archive: boolean): Promise<void>;
                            archiveBoard(): Promise<void>;
                        };
                        accessChange: (access: import("../features/auth/types/auth-tokens.js").AccessPayload) => void;
                    };
                    permissionsModel: {
                        readable: import("../toolbox/snapstate/parts/types.js").Readable<{
                            active: boolean;
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            active: boolean;
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }>) => void) => () => void;
                        track: <X_2>(observer: import("../toolbox/snapstate/parts/types.js").Observer<{
                            active: boolean;
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsDisplay: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }, X_2>, reaction?: import("../toolbox/snapstate/parts/types.js").Reaction<X_2>) => () => void;
                        getAccess: () => import("../features/auth/types/auth-tokens.js").AccessPayload;
                        initialize: () => Promise<void>;
                        getUserCanCustomizePermissions: () => boolean;
                        createRole: ({ label }: {
                            label: string;
                        }) => Promise<void>;
                        deleteRole: ({ roleId: roleIdString }: {
                            roleId: string;
                        }) => Promise<void>;
                        assignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                            roleId: string;
                            privilegeId: string;
                        }) => Promise<void>;
                        unassignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                            roleId: string;
                            privilegeId: string;
                        }) => Promise<void>;
                        deletePrivilege: ({ privilegeId: privilegeIdString }: {
                            privilegeId: string;
                        }) => Promise<void>;
                        createPrivilege: ({ label }: {
                            label: string;
                        }) => Promise<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                    };
                    administrativeModel: {
                        state: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }>;
                        subscribe: (listener: (context: import("../toolbox/snapstate/parts/types.js").Readable<{
                            accessOp: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>;
                            permissionsOp: import("../framework/ops.js").Op<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                        }>) => void) => () => void;
                        getAccess: () => import("../features/auth/types/auth-tokens.js").AccessPayload;
                        initialize: () => Promise<void>;
                        readonly isAllowed: (privilege: "universal" | "banned" | "view all chats" | "participate in all chats" | "read questions" | "post questions" | "like questions" | "report questions" | "moderate all chats" | "control stripe account" | "manage store" | "give away freebies" | "view all videos" | "moderate videos" | "edit any profile" | "customize permissions" | "answer questions" | "moderate questions" | "view stats" | "administrate user roles") => boolean;
                        reauthorize: () => Promise<void>;
                        searchUsers: (options: {
                            term: string;
                        }) => Promise<{
                            user: {
                                userId: string;
                                profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                                roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                            };
                            roleIds: string[];
                        }[]>;
                        assignRoleToUser: (options: {
                            roleId: string;
                            userId: string;
                            isPublic: boolean;
                            timeframeEnd: number;
                            timeframeStart: number;
                        }) => Promise<void>;
                        revokeRoleFromUser: (options: {
                            roleId: string;
                            userId: string;
                        }) => Promise<void>;
                        updateAccessOp(op: import("../framework/ops.js").Op<import("../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
                    };
                };
                remote: import("renraku").ApiRemote<{
                    auth: {
                        apps: {
                            appService: import("renraku").Service<import("../features/auth/types/auth-metas.js").PlatformUserMeta, import("../features/auth/types/auth-metas.js").PlatformUserAuth, {
                                listApps({ ownerUserId: ownerUserIdString }: {
                                    ownerUserId: string;
                                }): Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay[]>;
                                registerApp({ appDraft, ownerUserId: ownerUserIdString }: {
                                    appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                                    ownerUserId: string;
                                }): Promise<import("../features/auth/aspects/apps/types/app-display.js").AppDisplay>;
                            }>;
                            appEditService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AppOwnerMeta, import("../features/auth/types/auth-metas.js").AppOwnerAuth, {
                                updateApp({ appId: appIdString, appDraft }: {
                                    appId: string;
                                    appDraft: import("../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                                }): Promise<void>;
                                deleteApp({ appId: appIdString }: {
                                    appId: string;
                                }): Promise<void>;
                                listAdmins({ appId: appIdString }: {
                                    appId: string;
                                }): Promise<import("../features/auth/aspects/apps/types/admin-email-display.js").AdminEmailDisplay[]>;
                                assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }: {
                                    appId: string;
                                    platformUserId: string;
                                }): Promise<void>;
                                assignAdmin({ appId: appIdString, email }: {
                                    appId: string;
                                    email: string;
                                }): Promise<void>;
                                revokeAdmin({ appId: appIdString, userId: userIdString }: {
                                    appId: string;
                                    userId: string;
                                }): Promise<void>;
                            }>;
                        };
                        users: {
                            greenService: import("renraku").Service<undefined, import("../features/auth/types/auth-metas.js").GreenAuth, {
                                authorize({ scope, refreshToken, appId: appIdString, }: {
                                    scope: import("../features/auth/types/auth-tokens.js").CoreScope;
                                    appId: string;
                                    refreshToken?: string;
                                }): Promise<string>;
                            }>;
                            loginService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AnonMeta, import("../features/auth/types/auth-metas.js").LoginAuth, {
                                sendLoginLink(inputs: {
                                    email: string;
                                }): Promise<void>;
                                authenticateViaLoginToken({ loginToken }: {
                                    loginToken: string;
                                }): Promise<import("../toolbox/concurrent.js").AwaitProps<{
                                    accessToken: Promise<string>;
                                    refreshToken: Promise<string>;
                                }>>;
                            }>;
                            userService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AnonMeta, import("../features/auth/types/auth-metas.js").LoginAuth, {
                                getUser({ userId }: {
                                    userId: string;
                                }): Promise<{
                                    userId: string;
                                    profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                                    roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                    stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                                }>;
                            }>;
                            personalService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth, {
                                setProfile({ userId: userIdString, profileDraft }: {
                                    userId: string;
                                    profileDraft: import("../features/auth/aspects/users/routines/personal/types/profile-draft.js").ProfileDraft;
                                }): Promise<void>;
                            }>;
                        };
                        permissions: {
                            permissionsService: import("renraku").Service<import("../features/auth/aspects/permissions/types/permissions-auth-and-metas.js").PermissionsMeta, {
                                engine: {
                                    getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                                        userIds: string[];
                                        onlyGetPublicRoles: boolean;
                                    }) => Promise<{
                                        userId: string;
                                        userHasRoles: {
                                            userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                            roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                            timeframeStart: number;
                                            timeframeEnd: number;
                                            public: boolean;
                                            hard: boolean;
                                            time: number;
                                        }[];
                                    }[]>;
                                    getAnonymousPrivileges: () => Promise<string[]>;
                                    getPrivilegesForUsers: (userIds: string[]) => Promise<{
                                        userId: string;
                                        privileges: string[];
                                    }[]>;
                                    getPublicRolesForUsers: (userIds: string[]) => Promise<{
                                        userId: string;
                                        publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                    }[]>;
                                    getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                                    getPrivileges: (privilegeIds: string[]) => Promise<{
                                        hard: boolean;
                                        label: string;
                                        time: number;
                                        privilegeId: string;
                                    }[]>;
                                    getAllPrivileges: () => Promise<{
                                        hard: boolean;
                                        label: string;
                                        time: number;
                                        privilegeId: string;
                                    }[]>;
                                    getUserPrivileges: (userId: string) => Promise<string[]>;
                                };
                                access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                                authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                                checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                                    universal: string;
                                    banned: string;
                                    "moderate all chats": string;
                                    "control stripe account": string;
                                    "manage store": string;
                                    "give away freebies": string;
                                    "view all videos": string;
                                    "moderate videos": string;
                                    "edit any profile": string;
                                    "customize permissions": string;
                                    "answer questions": string;
                                    "moderate questions": string;
                                    "view stats": string;
                                    "administrate user roles": string;
                                    "view all chats": string;
                                    "participate in all chats": string;
                                    "read questions": string;
                                    "post questions": string;
                                    "like questions": string;
                                    "report questions": string;
                                }>;
                            }, {
                                fetchPermissions(): Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                                createRole({ label }: {
                                    label: string;
                                }): Promise<void>;
                                deleteRole({ roleId: roleIdString }: {
                                    roleId: string;
                                }): Promise<void>;
                                assignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                                    roleId: string;
                                    privilegeId: string;
                                }): Promise<void>;
                                unassignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                                    roleId: string;
                                    privilegeId: string;
                                }): Promise<void>;
                                createPrivilege({ label }: {
                                    label: string;
                                }): Promise<import("../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
                                deletePrivilege({ privilegeId: privilegeIdString }: {
                                    privilegeId: string;
                                }): Promise<void>;
                            }>;
                        };
                    };
                    administrative: {
                        roleAssignmentService: import("renraku").Service<import("../features/auth/aspects/permissions/types/permissions-auth-and-metas.js").PermissionsMeta, {
                            engine: {
                                getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                                    userIds: string[];
                                    onlyGetPublicRoles: boolean;
                                }) => Promise<{
                                    userId: string;
                                    userHasRoles: {
                                        userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                        roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                        timeframeStart: number;
                                        timeframeEnd: number;
                                        public: boolean;
                                        hard: boolean;
                                        time: number;
                                    }[];
                                }[]>;
                                getAnonymousPrivileges: () => Promise<string[]>;
                                getPrivilegesForUsers: (userIds: string[]) => Promise<{
                                    userId: string;
                                    privileges: string[];
                                }[]>;
                                getPublicRolesForUsers: (userIds: string[]) => Promise<{
                                    userId: string;
                                    publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                }[]>;
                                getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                                getPrivileges: (privilegeIds: string[]) => Promise<{
                                    hard: boolean;
                                    label: string;
                                    time: number;
                                    privilegeId: string;
                                }[]>;
                                getAllPrivileges: () => Promise<{
                                    hard: boolean;
                                    label: string;
                                    time: number;
                                    privilegeId: string;
                                }[]>;
                                getUserPrivileges: (userId: string) => Promise<string[]>;
                            };
                            access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                            authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                            checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                                universal: string;
                                banned: string;
                                "moderate all chats": string;
                                "control stripe account": string;
                                "manage store": string;
                                "give away freebies": string;
                                "view all videos": string;
                                "moderate videos": string;
                                "edit any profile": string;
                                "customize permissions": string;
                                "answer questions": string;
                                "moderate questions": string;
                                "view stats": string;
                                "administrate user roles": string;
                                "view all chats": string;
                                "participate in all chats": string;
                                "read questions": string;
                                "post questions": string;
                                "like questions": string;
                                "report questions": string;
                            }>;
                        }, {
                            fetchPermissions(): Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                            searchUsers(options: {
                                term: string;
                            }): Promise<{
                                user: {
                                    userId: string;
                                    profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                                    roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                    stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                                };
                                roleIds: string[];
                            }[]>;
                            assignRoleToUser(options: {
                                roleId: string;
                                userId: string;
                                isPublic: boolean;
                                timeframeEnd: number;
                                timeframeStart: number;
                            }): Promise<void>;
                            revokeRoleFromUser(options: {
                                roleId: string;
                                userId: string;
                            }): Promise<void>;
                        }>;
                    };
                    questions: {
                        questionsReadingService: import("renraku").Service<import("../features/auth/types/auth-metas.js").AnonMeta, import("../features/auth/types/auth-metas.js").LoginAuth & {
                            questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                                "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                            }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                        }, {
                            fetchQuestions({ board }: {
                                board: string;
                            }): Promise<{
                                users: {
                                    userId: string;
                                    profile: import("../features/auth/aspects/users/types/profile.js").Profile;
                                    roles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                    stats: import("../features/auth/aspects/users/types/user-stats.js").UserStats;
                                }[];
                                questions: {
                                    answers: import("../features/questions/api/types/questions-and-answers.js").Answer[];
                                    questionId: string;
                                    authorUserId: string;
                                    board: string;
                                    content: string;
                                    archive: boolean;
                                    timePosted: number;
                                    liked: boolean;
                                    likes: number;
                                    reports: number;
                                    reported: boolean;
                                }[];
                            }>;
                        }>;
                        questionsPostingService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth & {
                            questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                                "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                            }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                        }, {
                            postQuestion(inputs: {
                                questionDraft: import("../features/questions/api/types/question-draft.js").QuestionDraft;
                            }): Promise<import("../features/questions/api/types/questions-and-answers.js").Question>;
                            archiveQuestion(inputs: {
                                archive: boolean;
                                questionId: string;
                            }): Promise<void>;
                            likeQuestion(inputs: {
                                like: boolean;
                                questionId: string;
                            }): Promise<void>;
                            reportQuestion(inputs: {
                                report: boolean;
                                questionId: string;
                            }): Promise<void>;
                        }>;
                        questionsAnsweringService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth & {
                            questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                                "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                            }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                        }, {
                            postAnswer(inputs: {
                                questionId: string;
                                answerDraft: import("../features/questions/api/types/answer-draft.js").AnswerDraft;
                            }): Promise<import("../features/questions/api/types/questions-and-answers.js").Answer>;
                            archiveAnswer(inputs: {
                                archive: boolean;
                                answerId: string;
                            }): Promise<void>;
                            likeAnswer(inputs: {
                                like: boolean;
                                answerId: string;
                            }): Promise<void>;
                            reportAnswer(inputs: {
                                report: boolean;
                                answerId: string;
                            }): Promise<void>;
                        }>;
                        questionsModerationService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, import("../features/auth/types/auth-metas.js").UserAuth & {
                            questionsTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                                "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                            }, import("../features/questions/api/tables/types/questions-tables.js").QuestionsTables>;
                        }, {
                            archiveBoard({ board }: {
                                board: string;
                            }): Promise<void>;
                            fetchReportedQuestions(): Promise<void>;
                        }>;
                    };
                    example: {
                        exampleService: import("renraku").Service<import("../features/auth/types/auth-metas.js").UserMeta, {
                            exampleTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                                "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                            }, import("../features/example/api/types/example-tables.js").ExampleTables>;
                            access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                            authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                            checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                                universal: string;
                                banned: string;
                                "moderate all chats": string;
                                "control stripe account": string;
                                "manage store": string;
                                "give away freebies": string;
                                "view all videos": string;
                                "moderate videos": string;
                                "edit any profile": string;
                                "customize permissions": string;
                                "answer questions": string;
                                "moderate questions": string;
                                "view stats": string;
                                "administrate user roles": string;
                                "view all chats": string;
                                "participate in all chats": string;
                                "read questions": string;
                                "post questions": string;
                                "like questions": string;
                                "report questions": string;
                            }>;
                        }, {
                            exampleFunction({ something }: {
                                something: string;
                            }): Promise<void>;
                        }>;
                    };
                    videos: {
                        dacastService: import("renraku").Service<import("../features/videos/types/video-auth.js").VideoMeta, {
                            checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                                "view all videos": string;
                                "moderate videos": string;
                            }>;
                            engine: {
                                getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                                    userIds: string[];
                                    onlyGetPublicRoles: boolean;
                                }) => Promise<{
                                    userId: string;
                                    userHasRoles: {
                                        userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                        roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                        timeframeStart: number;
                                        timeframeEnd: number;
                                        public: boolean;
                                        hard: boolean;
                                        time: number;
                                    }[];
                                }[]>;
                                getAnonymousPrivileges: () => Promise<string[]>;
                                getPrivilegesForUsers: (userIds: string[]) => Promise<{
                                    userId: string;
                                    privileges: string[];
                                }[]>;
                                getPublicRolesForUsers: (userIds: string[]) => Promise<{
                                    userId: string;
                                    publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                }[]>;
                                getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                                getPrivileges: (privilegeIds: string[]) => Promise<{
                                    hard: boolean;
                                    label: string;
                                    time: number;
                                    privilegeId: string;
                                }[]>;
                                getAllPrivileges: () => Promise<{
                                    hard: boolean;
                                    label: string;
                                    time: number;
                                    privilegeId: string;
                                }[]>;
                                getUserPrivileges: (userId: string) => Promise<string[]>;
                            };
                            videoTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                                "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                            }, import("../features/videos/types/video-tables.js").VideoTables>;
                            access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                            authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                        }, {
                            getLink(): Promise<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                            setLink(inputs: {
                                apiKey: string;
                            }): Promise<import("../features/videos/types/dacast-link.js").DacastLinkDisplay>;
                            clearLink(): Promise<void>;
                        }>;
                        contentService: import("renraku").Service<import("../features/videos/types/video-auth.js").VideoMeta, {
                            engine: {
                                getUsersHaveRoles: ({ userIds, onlyGetPublicRoles }: {
                                    userIds: string[];
                                    onlyGetPublicRoles: boolean;
                                }) => Promise<{
                                    userId: string;
                                    userHasRoles: {
                                        userId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                        roleId: import("../toolbox/damnedb/damn-id.js").DamnId;
                                        timeframeStart: number;
                                        timeframeEnd: number;
                                        public: boolean;
                                        hard: boolean;
                                        time: number;
                                    }[];
                                }[]>;
                                getAnonymousPrivileges: () => Promise<string[]>;
                                getPrivilegesForUsers: (userIds: string[]) => Promise<{
                                    userId: string;
                                    privileges: string[];
                                }[]>;
                                getPublicRolesForUsers: (userIds: string[]) => Promise<{
                                    userId: string;
                                    publicUserRoles: import("../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                                }[]>;
                                getPermissionsDisplay: () => Promise<import("../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
                                getPrivileges: (privilegeIds: string[]) => Promise<{
                                    hard: boolean;
                                    label: string;
                                    time: number;
                                    privilegeId: string;
                                }[]>;
                                getAllPrivileges: () => Promise<{
                                    hard: boolean;
                                    label: string;
                                    time: number;
                                    privilegeId: string;
                                }[]>;
                                getUserPrivileges: (userId: string) => Promise<string[]>;
                            };
                            checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                                "view all videos": string;
                                "moderate videos": string;
                            }>;
                            videoTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                                "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                            }, import("../features/videos/types/video-tables.js").VideoTables>;
                            access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                            authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                        }, {
                            fetchModerationData(): Promise<import("../features/videos/types/video-concepts.js").VideoModerationData>;
                            writeView({ label, privileges, reference, }: {
                                label: string;
                                privileges: string[];
                                reference: import("../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
                            }): Promise<void>;
                            deleteView({ label }: {
                                label: string;
                            }): Promise<void>;
                            getShows({ labels }: {
                                labels: string[];
                            }): Promise<import("../features/videos/types/video-concepts.js").VideoShow[]>;
                        }>;
                    };
                    notes: {
                        notesService: import("renraku").Service<import("../features/notes/api/types/notes-auth.js").NotesMeta, {
                            notesTables: import("../toolbox/dbby/dbby-types.js").DbbyConstrainTables<{
                                "namespace-appId": import("../toolbox/damnedb/damn-id.js").DamnId;
                            }, import("../features/notes/api/tables/notes-tables.js").NotesTables>;
                            access: import("../features/auth/types/auth-tokens.js").AccessPayload;
                            authTables: import("../features/auth/types/auth-tables.js").AuthTables;
                            checker: import("../features/auth/aspects/permissions/types/privilege-checker.js").PrivilegeChecker<{
                                universal: string;
                                banned: string;
                                "moderate all chats": string;
                                "control stripe account": string;
                                "manage store": string;
                                "give away freebies": string;
                                "view all videos": string;
                                "moderate videos": string;
                                "edit any profile": string;
                                "customize permissions": string;
                                "answer questions": string;
                                "moderate questions": string;
                                "view stats": string;
                                "administrate user roles": string;
                                "view all chats": string;
                                "participate in all chats": string;
                                "read questions": string;
                                "post questions": string;
                                "like questions": string;
                                "report questions": string;
                            }>;
                        }, {
                            getNotesStats(): Promise<import("../features/notes/types/notes-concepts.js").NotesStats>;
                            getNewNotes(pagination: import("../features/notes/types/notes-concepts.js").Pagination): Promise<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                            getOldNotes(pagination: import("../features/notes/types/notes-concepts.js").Pagination): Promise<import("../features/notes/types/notes-concepts.js").Notes.Any[]>;
                            markAllNotesOld(): Promise<void>;
                            markNotesNewOrOld(input: {
                                old: boolean;
                                noteIds: string[];
                            }): Promise<void>;
                        }>;
                    };
                }>;
                nextModalResults: {
                    confirm: boolean;
                    prompt: {
                        value: any;
                    };
                };
            }>;
        }>;
    };
    popups: {
        triggerStripeConnectPopup: import("../features/store/types/store-popups.js").TriggerStripeConnectPopup;
        triggerCheckoutPopup: import("../features/store/types/store-popups.js").TriggerCheckoutPopup;
    };
    setMockLatency: (value: import("renraku").MockLatency) => void;
    chatConnect: import("../features/chat/common/types/chat-concepts.js").ChatConnect;
}>;
