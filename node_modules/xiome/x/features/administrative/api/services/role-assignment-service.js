import * as renraku from "renraku";
import { DamnId } from "../../../../toolbox/damnedb/damn-id.js";
import { escapeRegex } from "../../../../toolbox/escape-regex.js";
import { find, or } from "../../../../toolbox/dbby/dbby-helpers.js";
import { schema, boolean } from "../../../../toolbox/darkvalley.js";
import { validateTimeframe } from "./validation/validate-timeframe.js";
import { validateId } from "../../../../common/validators/validate-id.js";
import { validateUserSearchTerm } from "./validation/validate-user-search-term.js";
import { fetchUsers } from "../../../auth/aspects/users/routines/user/fetch-users.js";
import { runValidation } from "../../../../toolbox/topic-validation/run-validation.js";
import { makePermissionsEngine } from "../../../../assembly/backend/permissions/permissions-engine.js";
export const makeRoleAssignmentService = ({ config, authPolicies, }) => renraku.service()
    .policy(async (meta, headers) => {
    const auth = await authPolicies.userPolicy(meta, headers);
    auth.checker.requirePrivilege("administrate user roles");
    const engine = makePermissionsEngine({
        permissionsTables: auth.authTables.permissions,
        isPlatform: auth.access.appId === config.platform.appDetails.appId,
    });
    return { ...auth, engine };
})
    .expose(({ engine, authTables, }) => ({
    async fetchPermissions() {
        return engine.getPermissionsDisplay();
    },
    async searchUsers(options) {
        const { term } = runValidation(options, schema({
            term: validateUserSearchTerm,
        }));
        const regex = new RegExp(escapeRegex(term), "i");
        const profiles = await authTables.users.profiles.read({
            limit: 100,
            conditions: DamnId.isId(term)
                ? or({ equal: { userId: DamnId.fromString(term) } })
                : or({ search: { nickname: regex } }, { search: { tagline: regex } })
        });
        const userIds = profiles.map(profile => profile.userId);
        if (!userIds.length)
            return [];
        const users = await fetchUsers({
            userIds,
            authTables,
            permissionsEngine: engine,
        });
        const usersAndRoles = await engine.getUsersHaveRoles({
            userIds: users.map(user => user.userId),
            onlyGetPublicRoles: false,
        });
        return users.map(user => ({
            user,
            roleIds: usersAndRoles
                .find(u => u.userId === user.userId)
                .userHasRoles
                .map(role => role.roleId.toString())
        }));
    },
    async assignRoleToUser(options) {
        const { roleId: roleIdString, userId: userIdString, isPublic, timeframeEnd, timeframeStart } = (runValidation(options, schema({
            roleId: validateId,
            userId: validateId,
            isPublic: boolean(),
            timeframeEnd: validateTimeframe,
            timeframeStart: validateTimeframe,
        })));
        const roleId = DamnId.fromString(roleIdString);
        const userId = DamnId.fromString(userIdString);
        const existing = await authTables.permissions.userHasRole.one(find({
            userId,
            roleId,
        }));
        if (existing?.hard)
            throw new renraku.ApiError(400, "hard role assignment cannot be overwritten");
        else
            await authTables.permissions.userHasRole.assert({
                conditions: or({ equal: { roleId, userId } }),
                make: async () => ({
                    hard: false,
                    public: isPublic,
                    roleId,
                    userId,
                    timeframeEnd,
                    timeframeStart,
                    time: Date.now(),
                }),
            });
    },
    async revokeRoleFromUser(options) {
        const { roleId: roleIdString, userId: userIdString } = runValidation(options, schema({
            roleId: validateId,
            userId: validateId,
        }));
        const roleId = DamnId.fromString(roleIdString);
        const userId = DamnId.fromString(userIdString);
        const existing = await authTables.permissions.userHasRole.one(find({
            userId,
            roleId,
        }));
        if (existing?.hard)
            throw new renraku.ApiError(400, "hard role assignment cannot be overwritten");
        else
            await authTables.permissions.userHasRole.delete({
                conditions: or({ equal: { roleId, userId } }),
            });
    },
}));
//# sourceMappingURL=role-assignment-service.js.map