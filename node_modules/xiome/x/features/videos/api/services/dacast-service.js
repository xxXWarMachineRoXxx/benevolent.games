import * as renraku from "renraku";
import { videoPrivileges } from "../video-privileges.js";
import { schema } from "../../../../toolbox/darkvalley.js";
import { DamnId } from "../../../../toolbox/damnedb/damn-id.js";
import { runValidation } from "../../../../toolbox/topic-validation/run-validation.js";
import { validateDacastApiKeyAllowingMock } from "../validation/validate-dacast-api-key.js";
import { makePermissionsEngine } from "../../../../assembly/backend/permissions/permissions-engine.js";
import { makePrivilegeChecker } from "../../../auth/aspects/permissions/tools/make-privilege-checker.js";
function toLinkDisplay(secret) {
    return secret
        ? { time: secret.time }
        : undefined;
}
export const makeDacastService = ({ config, dacastSdk, videoTables: rawVideoTables, basePolicy, }) => renraku.service()
    .policy(async (meta, request) => {
    const auth = await basePolicy(meta, request);
    const appId = DamnId.fromString(auth.access.appId);
    const checker = makePrivilegeChecker(auth.access.permit, videoPrivileges);
    checker.requirePrivilege("moderate videos");
    const engine = makePermissionsEngine({
        isPlatform: auth.access.appId === config.platform.appDetails.appId,
        permissionsTables: auth.authTables.permissions,
    });
    return {
        ...auth,
        checker,
        engine,
        videoTables: rawVideoTables.namespaceForApp(appId),
    };
})
    .expose(({ videoTables }) => ({
    async getLink() {
        const secret = await videoTables.dacastAccountLinks.one({
            conditions: false,
        });
        return toLinkDisplay(secret);
    },
    async setLink(inputs) {
        const { apiKey } = runValidation(inputs, schema({
            apiKey: validateDacastApiKeyAllowingMock,
        }));
        const good = await dacastSdk.verifyApiKey(apiKey);
        let secret;
        if (good) {
            secret = { apiKey, time: Date.now() };
            await videoTables.dacastAccountLinks.update({
                conditions: false,
                upsert: secret,
            });
        }
        return toLinkDisplay(secret);
    },
    async clearLink() {
        await videoTables.dacastAccountLinks.delete({
            conditions: false,
        });
        return undefined;
    },
}));
//# sourceMappingURL=dacast-service.js.map