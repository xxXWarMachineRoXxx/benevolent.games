import { find } from "../../../../toolbox/dbby/dbby-helpers.js";
import { dbbyConstrainTables } from "../../../../toolbox/dbby/dbby-constrain.js";
export function mockStripeLiaison({ rando, tables, webhooks, }) {
    const generateId = () => rando.randomId();
    function respond(resource) {
        return {
            headers: {},
            lastResponse: undefined,
            ...resource,
        };
    }
    const rawTables = tables;
    return {
        accounts: {
            async create(params) {
                const account = {
                    id: generateId().toString(),
                    type: params.type,
                    email: params.email,
                };
                await tables.accounts.create(account);
                return respond(account);
            },
            async retrieve(id) {
                const account = await tables.accounts.one(find({ id }));
                return respond(account);
            },
            async createLoginLink(id) {
                const loginLink = {
                    created: Date.now(),
                    url: `https://fake.xiome.io/stripe-account-login-link`,
                };
                return respond(loginLink);
            },
        },
        accountLinks: {
            async create(params) {
                const accountLink = {
                    url: `https://fake.xiome.io/stripe-account-setup`,
                };
                return respond(accountLink);
            },
        },
        account(stripeAccount) {
            async function webhookEvent(type, object) {
                return webhooks[type]({
                    type,
                    data: { object },
                });
            }
            const tables = dbbyConstrainTables({
                tables: rawTables,
                namespace: { "_connectedAccount": stripeAccount },
            });
            function ignoreUndefined(input) {
                const output = {};
                for (const [key, value] of Object.entries(input)) {
                    if (value !== undefined)
                        output[key] = value;
                }
                return output;
            }
            function prepMockResource(table) {
                return {
                    create({ makeData, hook = async () => { } }) {
                        return async function (params) {
                            const resource = {
                                id: generateId(),
                                ...makeData(params),
                            };
                            await table.create(resource);
                            await hook(resource);
                            return respond(resource);
                        };
                    },
                    retrieve() {
                        return async function (id) {
                            const resource = await table.one(find({ id }));
                            return respond(resource);
                        };
                    },
                    update({ makeData, hook = async () => { } }) {
                        return async function (id, params) {
                            await table.update({
                                ...find({ id }),
                                write: ignoreUndefined(makeData(params)),
                            });
                            const resource = await table.one(find({ id }));
                            await hook(resource);
                            return respond(resource);
                        };
                    },
                    delete() {
                        return async function (id) {
                            await table.delete(find({ id }));
                        };
                    },
                };
            }
            function mockResource({ table, createData, updateData, createHook, updateHook, }) {
                const context = prepMockResource(table);
                return {
                    create: context.create({
                        makeData: createData,
                        hook: createHook,
                    }),
                    retrieve: context.retrieve(),
                    update: context.update({
                        makeData: updateData,
                        hook: updateHook,
                    }),
                    delete: context.delete(),
                };
            }
            return {
                customers: mockResource({
                    table: tables.customers,
                    createData: params => ({
                        email: params.email,
                        invoice_settings: params.invoice_settings
                            ?? { default_payment_method: undefined },
                    }),
                    updateData: params => ({
                        email: params.email,
                        invoice_settings: params.invoice_settings,
                    }),
                }),
                products: mockResource({
                    table: tables.products,
                    createData: params => ({
                        name: params.name,
                        description: params.description,
                    }),
                    updateData: params => ({
                        name: params.name,
                        description: params.description,
                    }),
                }),
                prices: mockResource({
                    table: tables.prices,
                    createData: params => ({
                        product: params.product,
                        currency: params.currency,
                        unit_amount: params.unit_amount,
                        recurring: params.recurring,
                    }),
                    updateData: params => ({
                        active: params.active,
                    }),
                }),
                checkout: {
                    sessions: mockResource({
                        table: tables.checkoutSessions,
                        createData: params => ({
                            customer: params.customer,
                        }),
                        updateData: params => ({}),
                        createHook: async (session) => {
                            await webhookEvent("checkout.session.completed", session);
                        },
                        updateHook: async (session) => {
                            await webhookEvent("checkout.session.completed", session);
                        },
                    }),
                },
                paymentMethods: mockResource({
                    table: tables.paymentMethods,
                    createData: params => ({
                        type: params.type,
                        customer: params.customer,
                    }),
                    updateData: params => ({}),
                }),
                setupIntents: mockResource({
                    table: tables.setupIntents,
                    createData: params => ({
                        customer: params.customer,
                        payment_method: params.payment_method,
                        usage: params.usage,
                    }),
                    updateData: params => ({
                        payment_method: params.payment_method,
                    }),
                }),
                subscriptions: mockResource({
                    table: tables.subscriptions,
                    createData: params => ({
                        customer: params.customer,
                        default_payment_method: params.default_payment_method,
                        cancel_at_period_end: params.cancel_at_period_end,
                        items: {
                            url: "",
                            object: "list",
                            has_more: false,
                            data: params.items.map(itemParams => ({
                                id: generateId(),
                                billing_thresholds: itemParams.billing_thresholds,
                                price: itemParams.price,
                                price_data: itemParams.price_data,
                                quantity: itemParams.quantity,
                                tax_rates: itemParams.tax_rates,
                            })),
                        },
                    }),
                    updateData: params => ({
                        cancel_at_period_end: params.cancel_at_period_end,
                        default_payment_method: params.default_payment_method,
                    }),
                    updateHook: async (subscription) => {
                        await webhookEvent("customer.subscription.updated", subscription);
                    },
                }),
            };
        }
    };
}
//# sourceMappingURL=mock-stripe-liaison.js.map