import { DamnId } from "../../../../../toolbox/damnedb/damn-id.js";
import { find, findAll } from "../../../../../toolbox/dbby/dbby-helpers.js";
import { stripeAttempt } from "../../../stripe/liaison/helpers/stripe-attempt.js";
export const helpersForListingSubscriptions = ({ storeTables, stripeAccountId, stripeLiaisonAccount, }) => ({
    async fetchOurSubscriptionPlanRecords() {
        return storeTables.subscription.plans.read(find({ stripeAccountId }));
    },
    async crossReferencePlansWithStripeProducts(planRows) {
        return crossReferenceWithStripe({
            rows: planRows,
            getRowId: row => row.planId,
            getStripeResource: row => stripeLiaisonAccount.products.retrieve(row.stripeProductId),
        });
    },
    async deletePlans(planIds) {
        if (planIds.length)
            await storeTables.subscription.plans.delete(findAll(planIds, planId => ({ planId, stripeAccountId })));
    },
    async fetchOurRecordsOfPlanTiers(planIds) {
        return planIds.length
            ? storeTables.subscription.tiers.read(findAll(planIds, planId => ({ planId, stripeAccountId })))
            : [];
    },
    async crossReferenceTiersWithStripePrices(tierRows) {
        return crossReferenceWithStripe({
            rows: tierRows,
            getRowId: row => row.tierId,
            getStripeResource: row => stripeLiaisonAccount.products.retrieve(row.stripePriceId),
        });
    },
    async deleteTiers(tierIds) {
        if (tierIds.length) {
            await storeTables.subscription.tiers.delete(findAll(tierIds, tierId => ({ tierId, stripeAccountId })));
        }
    },
    identifyTiersWithoutParentPlan(tierRows, presentPlanIds) {
        const stringPresentPlanIds = presentPlanIds.map(p => p.toString());
        return tierRows
            .filter(row => stringPresentPlanIds.includes(row.planId.toString()))
            .map(row => row.tierId);
    },
    dedupeIds(ids) {
        const stringIds = ids.map(id => id.toString());
        const deduped = [...new Set(stringIds)];
        return deduped.map(id => DamnId.fromString(id));
    },
    async deleteTiersWithoutParentPlan(tierIds) {
        if (tierIds.length) {
            await storeTables.subscription.tiers.delete(findAll(tierIds, tierId => ({ tierId, stripeAccountId })));
        }
    },
    assembleSubscriptionPlans({ plans, tiers }) {
        const presentPlanRows = plans.rows
            .filter(({ planId }) => plans.cross.presentIds.includes(planId));
        const presentTierRows = tiers.rows
            .filter(({ tierId }) => tiers.cross.presentIds.includes(tierId));
        return presentPlanRows.map(row => ({
            time: row.time,
            label: row.label,
            planId: row.planId.toString(),
            active: plans.cross.activeIds.includes(row.planId),
            tiers: presentTierRows
                .filter(({ planId }) => {
            })
                .map(p => undefined),
        }));
    },
});
async function crossReferenceWithStripe({ rows, getRowId, getStripeResource }) {
    const rowsWithStripeResources = await Promise.all(rows.map(async (row) => ({
        row,
        stripeResource: await stripeAttempt(() => getStripeResource(row)),
    })));
    return discriminateMissingPresentAndActive(rowsWithStripeResources.map(c => ({
        id: getRowId(c.row),
        stripeResource: c.stripeResource,
    })));
}
function discriminateMissingPresentAndActive(manifest) {
    const missingIds = [];
    const presentIds = [];
    const activeIds = [];
    for (const { stripeResource, id } of manifest) {
        if (stripeResource === undefined)
            missingIds.push(id);
        else {
            presentIds.push(id);
            if (stripeResource.active)
                activeIds.push(id);
        }
    }
    return { missingIds, presentIds, activeIds };
}
//# sourceMappingURL=helpers-for-listing-subscriptions.js.map