import { objectMap } from "../../../../../toolbox/object-map.js";
import { DamnId } from "../../../../../toolbox/damnedb/damn-id.js";
import { subbies } from "../../../../../toolbox/subbies.js";
import { AssertiveMap } from "../../../../../toolbox/assertive-map.js";
import { find, findAll } from "../../../../../toolbox/dbby/dbby-helpers.js";
import { ChatStatus } from "../../../common/types/chat-concepts.js";
import { mockStorageTables } from "../../../../../assembly/backend/tools/mock-storage-tables.js";
import { UnconstrainedTables } from "../../../../../framework/api/types/table-namespacing-for-apps.js";
import { maximumNumberOfPostsShownAtOnce } from "../../../common/chat-constants.js";
export async function mockChatPersistence(storage) {
    const chatTablesUnconstrained = new UnconstrainedTables(await mockStorageTables(storage, {
        posts: true,
        mutes: true,
        roomStatuses: true,
    }));
    const events = {
        roomStatusChanged: subbies(),
        postsAdded: subbies(),
        postsRemoved: subbies(),
        roomCleared: subbies(),
        mutes: subbies(),
        unmutes: subbies(),
        unmuteAll: subbies(),
    };
    const eventSubscribers = objectMap(events, (event) => event.subscribe);
    const getAppCache = (() => {
        const appCaches = new AssertiveMap(() => ({
            mutedUserIds: new Set()
        }));
        return (appId) => appCaches.assert(appId);
    })();
    // listen to events to update cache
    {
        eventSubscribers.mutes(({ appId, userIds }) => {
            const cache = getAppCache(appId);
            for (const userId of userIds)
                cache.mutedUserIds.add(userId);
        });
        eventSubscribers.unmutes(({ appId, userIds }) => {
            const cache = getAppCache(appId);
            for (const userId of userIds)
                cache.mutedUserIds.delete(userId);
        });
        eventSubscribers.unmuteAll(({ appId }) => {
            const cache = getAppCache(appId);
            cache.mutedUserIds.clear();
        });
    }
    function namespaceForApp(appId) {
        const appCache = getAppCache(appId);
        const chatTables = chatTablesUnconstrained
            .namespaceForApp(DamnId.fromString(appId));
        return {
            isMuted(userId) {
                return appCache.mutedUserIds.has(userId);
            },
            async addPosts(room, posts) {
                await chatTables.posts.create(...posts.map(post => ({
                    room: post.room,
                    time: post.time,
                    content: post.content,
                    nickname: post.nickname,
                    userId: DamnId.fromString(post.userId),
                    postId: DamnId.fromString(post.postId),
                })));
                events.postsAdded.publish({ appId, room, posts });
            },
            async removePosts(room, postIds) {
                if (postIds.length) {
                    await chatTables.posts.delete(findAll(postIds, postId => ({
                        room,
                        postId: DamnId.fromString(postId)
                    })));
                    events.postsRemoved.publish({ appId, room, postIds });
                }
            },
            async fetchRecentPosts(room) {
                const rawPosts = await chatTables.posts.read({
                    ...find({ room }),
                    limit: maximumNumberOfPostsShownAtOnce,
                    order: { time: "descend" },
                });
                const recentPosts = rawPosts.map(post => ({
                    room: post.room,
                    time: post.time,
                    content: post.content,
                    nickname: post.nickname,
                    postId: post.postId.toString(),
                    userId: post.userId.toString(),
                }));
                const postsSortedByTime = recentPosts.sort((a, b) => a.time - b.time);
                return postsSortedByTime;
            },
            async fetchMutes() {
                const rows = await chatTables.mutes.read({ conditions: false });
                return rows.map(row => ({ userId: row.userId.toString() }));
            },
            async clearRoom(room) {
                await chatTables.posts.delete(find({ room }));
                events.roomCleared.publish({ appId, room });
            },
            async addMute(userIds) {
                if (userIds.length) {
                    const existingMutes = await chatTables.mutes.read(findAll(userIds, userId => ({
                        userId: DamnId.fromString(userId),
                    })));
                    const userIdsAlreadyMuted = existingMutes.map(row => row.userId.toString());
                    const userIdsToBeMuted = userIds.filter(userId => !userIdsAlreadyMuted.includes(userId));
                    const newMutes = userIdsToBeMuted.map(userId => ({
                        userId: DamnId.fromString(userId)
                    }));
                    await chatTables.mutes.create(...newMutes);
                    events.mutes.publish({ appId, userIds: userIdsToBeMuted });
                }
            },
            async removeMute(userIds) {
                if (userIds.length) {
                    await chatTables.mutes.delete(findAll(userIds, userId => ({ userId: DamnId.fromString(userId) })));
                    events.unmutes.publish({ appId, userIds });
                }
            },
            async unmuteAll() {
                await chatTables.mutes.delete({ conditions: false });
                events.unmuteAll.publish({ appId });
            },
            async setRoomStatus(room, status) {
                await chatTables.roomStatuses.update({
                    ...find({ room }),
                    upsert: { room, status },
                });
                events.roomStatusChanged.publish({ appId, room, status });
            },
            async getRoomStatus(room) {
                const row = await chatTables.roomStatuses.one(find({ room }));
                return row
                    ? row.status
                    : ChatStatus.Offline;
            },
        };
    }
    return {
        events: eventSubscribers,
        namespaceForApp,
    };
}
//# sourceMappingURL=mock-chat-persistence.js.map