import { objectMap } from "../object-map.js";
import { escapeRegex } from "../escape-regex.js";
import { _dbbyTableSymbol } from "./dbby-table-symbol.js";
import { up, ups, down, downs, valueUp } from "./dbby-mongo-row-processing.js";
export function dbbyMongo({ collection }) {
    return {
        [_dbbyTableSymbol]: true,
        async create(...rows) {
            await collection.insertMany(ups(rows));
        },
        async read({ order, offset = 0, limit = 10000, ...conditional }) {
            const query = prepareQuery(conditional);
            let cursor = collection.find(query, undefined);
            if (offset)
                cursor = cursor.skip(offset);
            if (order)
                cursor = cursor.sort(orderToSort(order));
            if (limit)
                cursor = cursor.limit(limit);
            const rows = await cursor.toArray();
            return downs(rows);
        },
        async one(conditional) {
            const query = prepareQuery(conditional);
            const row = await collection.findOne(query);
            return down(row);
        },
        async assert({ make, ...conditional }) {
            const query = prepareQuery(conditional);
            let row = down(await collection.findOne(query));
            if (!row) {
                row = await make();
                await collection.insertOne(up(row));
            }
            return row;
        },
        async update({ write, whole, upsert, ...conditional }) {
            const query = prepareQuery(conditional);
            if (write) {
                await collection.updateMany(query, { $set: up(write) }, { upsert: false });
            }
            else if (upsert) {
                await collection.updateOne(query, { $set: up(upsert) }, { upsert: true });
            }
            else if (whole) {
                await collection.deleteMany(query);
                await collection.insertOne(up(whole));
            }
            else
                throw new Error("invalid update");
        },
        async delete(conditional) {
            const query = prepareQuery(conditional);
            await collection.deleteMany(query);
        },
        async count(conditional) {
            const query = prepareQuery(conditional);
            return collection.countDocuments(query);
        },
    };
}
function prepareQuery({ conditions }) {
    if (!conditions)
        return {};
    function recurse(tree) {
        const [operator, ...conds] = tree;
        const query = conds
            .map(cond => Array.isArray(cond)
            ? recurse(cond)
            : conditionsToMongoQuery(cond))
            .filter(cond => !!cond);
        return operator === "and"
            ? { $and: query }
            : { $or: query };
    }
    return recurse(conditions);
}
function orderToSort(order) {
    return objectMap(order, value => !!value
        ? value === "ascend"
            ? 1
            : -1
        : 1);
}
function isSet(a) {
    return a !== undefined && a !== null;
}
function mapwise(x, y) {
    const y2 = (value, key) => y(valueUp(value, key));
    return x && objectMap(x, y2);
}
function notwise(x, y) {
    const cond = mapwise(x, y);
    return cond && { $nor: [cond] };
}
const mongoloids = {
    set: value => ({ $exists: value }),
    equal: value => ({ $eq: value }),
    greater: value => ({ $gt: value }),
    greatery: value => ({ $gte: value }),
    less: value => ({ $lt: value }),
    lessy: value => ({ $lte: value }),
    listed: value => ({ $in: [value] }),
    search: value => ({
        $regex: typeof value === "string"
            ? escapeRegex(value)
            : value
    }),
};
function conditionsToMongoQuery(conditions) {
    return conditions
        ? {
            $and: [
                mapwise(conditions.set, mongoloids.set),
                mapwise(conditions.equal, mongoloids.equal),
                mapwise(conditions.greater, mongoloids.greater),
                mapwise(conditions.greatery, mongoloids.greatery),
                mapwise(conditions.less, mongoloids.less),
                mapwise(conditions.lessy, mongoloids.lessy),
                mapwise(conditions.listed, mongoloids.listed),
                mapwise(conditions.search, mongoloids.search),
                notwise(conditions.notSet, mongoloids.set),
                notwise(conditions.notEqual, mongoloids.equal),
                notwise(conditions.notGreater, mongoloids.greater),
                notwise(conditions.notGreatery, mongoloids.greatery),
                notwise(conditions.notLess, mongoloids.less),
                notwise(conditions.notLessy, mongoloids.lessy),
                notwise(conditions.notListed, mongoloids.listed),
                notwise(conditions.notSearch, mongoloids.search),
            ].filter(isSet)
        }
        : {};
}
//# sourceMappingURL=dbby-mongo.js.map