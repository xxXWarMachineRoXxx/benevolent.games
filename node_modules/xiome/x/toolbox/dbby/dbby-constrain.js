import { objectMap } from "../object-map.js";
import { and, isDbbyTable } from "./dbby-helpers.js";
import { _dbbyTableSymbol } from "./dbby-table-symbol.js";
export function dbbyConstrain({ table, namespace, }) {
    const spike = (conditionTree) => (conditionTree
        ? and({ equal: namespace }, conditionTree)
        : and({ equal: namespace }));
    return {
        [_dbbyTableSymbol]: true,
        async create(...rows) {
            return table.create(...rows.map(row => ({ ...row, ...namespace })));
        },
        async read(options) {
            return table.read({
                ...options,
                conditions: spike(options.conditions),
            });
        },
        async one(options) {
            return table.one({
                ...options,
                conditions: spike(options.conditions),
            });
        },
        async assert(options) {
            return table.assert({
                ...options,
                conditions: spike(options.conditions),
                make: async () => {
                    const row = await options.make();
                    return { ...row, ...namespace };
                },
            });
        },
        async update(options) {
            const opts = options;
            return table.update({
                ...options,
                conditions: spike(options.conditions),
                upsert: opts.upsert
                    ? { ...opts.upsert, ...namespace }
                    : undefined,
                whole: opts.whole
                    ? { ...opts.whole, ...namespace }
                    : undefined,
                write: opts.write
                    ? { ...opts.write, ...namespace }
                    : undefined,
            });
        },
        async delete(options) {
            return table.delete({
                ...options,
                conditions: spike(options.conditions),
            });
        },
        async count(options) {
            return table.count({
                ...options,
                conditions: spike(options.conditions),
            });
        },
    };
}
export function dbbyConstrainTables({ namespace, tables, }) {
    return objectMap(tables, value => {
        return isDbbyTable(value)
            ? dbbyConstrain({ namespace, table: value })
            : dbbyConstrainTables({ namespace, tables: value });
    });
}
//# sourceMappingURL=dbby-constrain.js.map