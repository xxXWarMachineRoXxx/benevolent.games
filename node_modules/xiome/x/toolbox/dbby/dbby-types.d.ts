import { DamnId } from "../damnedb/damn-id.js";
import { _dbbyTableSymbol } from "./dbby-table-symbol.js";
export declare type DbbyValue = DamnId | undefined | boolean | number | string | bigint;
export declare type DbbyRow = {
    [key: string]: DbbyValue;
};
export declare type AsDbbyRow<T extends DbbyRow> = T;
export declare const asDbbyValue: <Value extends DbbyValue>(value: Value) => Value;
export declare const asDbbyRow: <Row extends DbbyRow>(row: Row) => Row;
export declare type ToDbbyRow<Row extends DbbyRow> = {
    [P in keyof Row]: Row[P] extends DbbyValue ? Row[P] : never;
};
export declare const toDbbyRow: <Row extends {}>(row: ToDbbyRow<Row>) => ToDbbyRow<Row>;
export interface DbbyCondition<Row extends DbbyRow> {
    set?: Partial<{
        [P in keyof Row]: true;
    }>;
    equal?: Partial<Row>;
    less?: Partial<Row>;
    lessy?: Partial<Row>;
    greater?: Partial<Row>;
    greatery?: Partial<Row>;
    listed?: Partial<Row>;
    search?: Partial<{
        [P in keyof Row]: string | RegExp;
    }>;
    notSet?: Partial<{
        [P in keyof Row]: true;
    }>;
    notEqual?: Partial<Row>;
    notLess?: Partial<Row>;
    notLessy?: Partial<Row>;
    notGreater?: Partial<Row>;
    notGreatery?: Partial<Row>;
    notListed?: Partial<Row>;
    notSearch?: Partial<{
        [P in keyof Row]: string | RegExp;
    }>;
}
export declare type DbbyConditionOperation = "and" | "or";
export declare type DbbyConditionLeaf<Row extends DbbyRow> = DbbyCondition<Row> | DbbyConditions<Row>;
export declare type DbbyConditionBranch<Op extends DbbyConditionOperation, Row extends DbbyRow> = [
    Op,
    ...DbbyConditionLeaf<Row>[]
];
export declare type DbbyConditionTree<Row extends DbbyRow> = DbbyConditionBranch<"and", Row> | DbbyConditionBranch<"or", Row>;
export declare type DbbyConditions<Row extends DbbyRow> = false | DbbyConditionTree<Row>;
export interface DbbyConditional<Row extends DbbyRow> {
    conditions: DbbyConditions<Row>;
}
export declare type DbbyOrder<Row extends DbbyRow> = Partial<{
    [P in keyof Row]: "ascend" | "descend" | undefined;
}>;
export declare type DbbyPaginated<Row extends DbbyRow> = DbbyConditional<Row> & {
    limit?: number;
    offset?: number;
    order?: DbbyOrder<Row>;
};
export declare type DbbyUpsert<Row extends DbbyRow> = DbbyConditional<Row> & {
    upsert: Row;
};
export declare type DbbyWrite<Row extends DbbyRow> = DbbyConditional<Row> & {
    write: Partial<Row>;
};
export declare type DbbyWhole<Row extends DbbyRow> = DbbyConditional<Row> & {
    whole: Row;
};
export declare type DbbyUpdate<Row extends DbbyRow> = DbbyWrite<Row> | DbbyWhole<Row> | DbbyUpsert<Row>;
export declare type DbbyUpdateAmbiguated<Row extends DbbyRow> = DbbyWrite<Row> & DbbyWhole<Row> & DbbyUpsert<Row>;
export declare type DbbyAssertion<Row extends DbbyRow> = DbbyConditional<Row> & {
    make: () => Promise<Row>;
};
export declare type DbbyConditionHelper<Op extends DbbyConditionOperation, Row extends DbbyRow, C extends DbbyConditionLeaf<Row>[] = DbbyConditionLeaf<Row>[]> = (...conditions: C) => DbbyConditionBranch<Op, Row>;
export interface DbbyTable<Row extends DbbyRow> {
    [_dbbyTableSymbol]: true;
    create(...rows: Row[]): Promise<void>;
    read(options: DbbyPaginated<Row>): Promise<Row[]>;
    one(options: DbbyConditional<Row>): Promise<Row>;
    assert(options: DbbyAssertion<Row>): Promise<Row>;
    update(options: DbbyUpdate<Row>): Promise<void>;
    delete(options: DbbyConditional<Row>): Promise<void>;
    count(options: DbbyConditional<Row>): Promise<number>;
}
export declare type DbbyExtractRow<xTable extends DbbyTable<DbbyRow>> = xTable extends DbbyTable<infer xRow> ? xRow : never;
export declare type DbbyTables = {
    [key: string]: DbbyTable<DbbyRow> | DbbyTables;
};
export declare type AsDbbyTables<xTables extends DbbyTables> = xTables;
export declare type DbbyUnconstrainRow<xNamespace extends DbbyRow, xRow extends DbbyRow> = xNamespace & xRow;
export declare type DbbyConstrainRow<xNamespace extends DbbyRow, xRow extends DbbyRow> = Omit<xRow, keyof xNamespace>;
export declare type DbbyUnconstrainTable<xNamespace extends DbbyRow, xTable extends DbbyTable<DbbyRow>> = xTable extends DbbyTable<infer xRow> ? DbbyTable<DbbyUnconstrainRow<xNamespace, xRow>> : never;
export declare type DbbyConstrainTable<xNamespace extends DbbyRow, xTable extends DbbyTable<DbbyRow>> = xTable extends DbbyTable<infer xRow> ? DbbyTable<DbbyConstrainRow<xNamespace, xRow>> : never;
export declare type DbbyUnconstrainTables<xNamespace extends DbbyRow, xTables extends DbbyTables> = {
    [P in keyof xTables]: xTables[P] extends DbbyTable<DbbyRow> ? DbbyUnconstrainTable<xNamespace, xTables[P]> : xTables[P] extends DbbyTables ? DbbyUnconstrainTables<xNamespace, xTables[P]> : never;
};
export declare type DbbyConstrainTables<xNamespace extends DbbyRow, xTables extends DbbyTables> = {
    [P in keyof xTables]: xTables[P] extends DbbyTable<DbbyRow> ? DbbyConstrainTable<xNamespace, xTables[P]> : xTables[P] extends DbbyTables ? DbbyConstrainTables<xNamespace, xTables[P]> : never;
};
